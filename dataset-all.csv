project_name,bug_type,file,procedure,line,warning,source,snippet,buggy
bundletool-1.15.1,NULL_DEREFERENCE,src/main/java/com/android/tools/build/bundletool/model/utils/OsPlatform.java,com.android.tools.build.bundletool.model.utils.OsPlatform.getCurrentPlatform():com.android.tools.build.bundletool.model.utils.OsPlatform,28,object `os` last assigned on line 27 could be null and is dereferenced at line 28.,"26: public static OsPlatform getCurrentPlatform() {
 27: String os = System.getProperty(""os.name"");
 28: if (os.startsWith(""Mac OS"")) {","public static OsPlatform getCurrentPlatform() {
    String os = System.getProperty(""os.name"");
    if (os.startsWith(""Mac OS"")) {
      return MACOS;
    } else if (os.startsWith(""Windows"")) {
      return WINDOWS;
    } else if (os.startsWith(""Linux"")) {
      return LINUX;
    } else {
      return OTHER;
    }
}",1
bundletool-1.15.1,NULL_DEREFERENCE,src/main/java/com/android/tools/build/bundletool/model/ZipPath.java,com.android.tools.build.bundletool.model.ZipPath.resolveSibling(com.android.tools.build.bundletool.model.AutoValue_ZipPath):com.android.tools.build.bundletool.model.ZipPath,94,object returned by `getParent()` could be null and is dereferenced at line 94.,https://github.com/google/bundletool/blob/1.15.1/src/main/java/com/android/tools/build/bundletool/model/ZipPath.java,"public ZipPath resolveSibling(ZipPath path) {
    checkNotNull(path, ""Path cannot be null."");
    checkState(!getNames().isEmpty(), ""Root has not sibling."");
    return getParent().resolve(path);
  }",1
bundletool-1.15.1,NULL_DEREFERENCE,src/main/java/com/android/tools/build/bundletool/commands/PrintDeviceTargetingConfigCommand.java,com.android.tools.build.bundletool.commands.PrintDeviceTargetingConfigCommand.execute():void,98,object `config.deviceTierSet_` last assigned on line 96 could be null and is dereferenced by call to `validateDeviceTierConfig(...)` at line 98.,https://github.com/google/bundletool/blob/1.15.1/src/main/java/com/android/tools/build/bundletool/commands/PrintDeviceTargetingConfigCommand.java,"public void execute() throws IOException {
    try (Reader configReader = BufferedIo.reader(getDeviceTargetingConfigurationPath())) {
      DeviceTierConfig.Builder configBuilder = DeviceTierConfig.newBuilder();
      JsonFormat.parser().merge(configReader, configBuilder);
      DeviceTierConfig config = configBuilder.build();

      DeviceTierConfigValidator.validateDeviceTierConfig(config);

      for (DeviceGroup deviceGroup : config.getDeviceGroupsList()) {
        printDeviceGroup(deviceGroup, INDENT);
      }

      printDeviceTierSet(config);
      config.getUserCountrySetsList().forEach(countrySet -> printCountrySet(countrySet, """"));
    }
  }",0
bundletool-1.15.1,NULL_DEREFERENCE,src/main/java/com/android/tools/build/bundletool/model/SizeConfiguration.java,com.android.tools.build.bundletool.model.SizeConfiguration.getScreenDensityName(com.android.bundle.Targeting$ScreenDensityTargeting):java.util.Optional,106,object returned by `screenDensity.getDensityOneofCase()` could be null and is dereferenced at line 106.,https://github.com/google/bundletool/blob/1.15.1/src/main/java/com/android/tools/build/bundletool/model/SizeConfiguration.java,"public static Optional<String> getScreenDensityName(
      ScreenDensityTargeting screenDensityTargeting) {
    if (screenDensityTargeting.getValueList().isEmpty()) {
      return Optional.empty();
    }

    ScreenDensity screenDensity = Iterables.getOnlyElement(screenDensityTargeting.getValueList());
    return Optional.of(
        screenDensity.getDensityOneofCase().equals(DENSITY_ALIAS)
            ? screenDensity.getDensityAlias().name()
            : Integer.toString(screenDensity.getDensityDpi()));
  }",1
bundletool-1.15.1,NULL_DEREFERENCE,src/main/java/com/android/tools/build/bundletool/device/DdmlibAdbServer.java,com.android.tools.build.bundletool.device.DdmlibAdbServer.getDevicesInternal():com.google.common.collect.ImmutableList,114,object `DdmlibAdbServer.adb` last accessed on line 114 could be null and is dereferenced at line 114.,"112: public synchronized ImmutableList<Device> getDevicesInternal() {
 113: checkState(state.equals(State.INITIALIZED), ""Android Debug Bridge is not initialized."");
 114: return Arrays.stream(adb.getDevices()).map(DdmlibDevice::new).collect(toImmutableList());","public synchronized ImmutableList<Device> getDevicesInternal() {
    checkState(state.equals(State.INITIALIZED), ""Android Debug Bridge is not initialized."");
    return Arrays.stream(adb.getDevices()).map(DdmlibDevice::new).collect(toImmutableList());
  }",1
bundletool-1.15.1,NULL_DEREFERENCE,src/main/java/com/android/tools/build/bundletool/device/DdmlibAdbServer.java,com.android.tools.build.bundletool.device.DdmlibAdbServer.hasInitialDeviceList():boolean,120,object `DdmlibAdbServer.adb` last accessed on line 120 could be null and is dereferenced at line 120.,"118: public synchronized boolean hasInitialDeviceList() {
 119: checkState(state.equals(State.INITIALIZED), ""Android Debug Bridge is not initialized."");
 120: return adb.hasInitialDeviceList();","public synchronized boolean hasInitialDeviceList() {
    checkState(state.equals(State.INITIALIZED), ""Android Debug Bridge is not initialized."");
    return adb.hasInitialDeviceList();
  }",1
bundletool-1.15.1,NULL_DEREFERENCE,src/main/java/com/android/tools/build/bundletool/transparency/BundleTransparencyCheckUtils.java,com.android.tools.build.bundletool.transparency.BundleTransparencyCheckUtils.getSource(com.android.bundle.CodeTransparencyOuterClass$CodeRelatedFile):java.lang.String,139,object returned by `codeRelatedFile.getSourceCase()` could be null and is dereferenced at line 139.,"138: private static String getSource(CodeRelatedFile codeRelatedFile) {
 139: switch (codeRelatedFile.getSourceCase()) {
 140: case PATH:
 141: return codeRelatedFile.getPath();
 142: case BUNDLETOOL_REPO_PATH:
 143: return codeRelatedFile.getBundletoolRepoPath();
 144: case SOURCE_NOT_SET:
 145: logger.warning(""CodeRelatedFile has unset `source`: "" + codeRelatedFile);
 146: }
 147: throw InvalidBundleException.builder()","private static String getSource(CodeRelatedFile codeRelatedFile) {
    switch (codeRelatedFile.getSourceCase()) {
      case PATH:
        return codeRelatedFile.getPath();
      case BUNDLETOOL_REPO_PATH:
        return codeRelatedFile.getBundletoolRepoPath();
      case SOURCE_NOT_SET:
        logger.warning(""CodeRelatedFile has unset `source`: "" + codeRelatedFile);
    }
    throw InvalidBundleException.builder()
        .withUserMessage(""Failed to get value of `source`"")
        .build();
  }",1
bundletool-1.15.1,NULL_DEREFERENCE,src/main/java/com/android/tools/build/bundletool/mergers/SameTargetingMerger.java,com.android.tools.build.bundletool.mergers.SameTargetingMerger.mergeSplits(com.google.common.collect.ImmutableCollection):com.android.tools.build.bundletool.model.ModuleSplit,149,object `sparseEncoding` last assigned on line 75 could be null and is dereferenced at line 149.,"63: private ModuleSplit mergeSplits(ImmutableCollection<ModuleSplit> splits) {
 64: ModuleSplit.Builder builder = ModuleSplit.builder();
 65: ImmutableList.Builder<ModuleEntry> entries = ImmutableList.builder();
 66: AndroidManifest mergedManifest = null;
 67: ResourceTable mergedResourceTable = null;
 68: NativeLibraries mergedNativeConfig = null;
 69: Map<String, TargetedAssetsDirectory> mergedAssetsConfig = new HashMap<>();
 70: ApexImages mergedApexConfig = null;
 71: ImmutableList<ApexEmbeddedApkConfig> mergedApexEmbeddedApkConfigs = null;
 72: BundleModuleName mergedModuleName = null;
 73: Boolean mergedIsMasterSplit = null;
 74: VariantTargeting mergedVariantTargeting = null;
 75: Boolean sparseEncoding = null;
 76: 
 77: for (ModuleSplit split : splits) {
 78: mergedManifest =
 79: getSameValueOrNonNull(mergedManifest, split.getAndroidManifest())
 80: .orElseThrow(
 81: () ->
 82: new IllegalStateException(
 83: ""Encountered two distinct manifests while merging.""));
 84: if (split.getResourceTable().isPresent()) {
 85: mergedResourceTable =
 86: getSameValueOrNonNull(mergedResourceTable, split.getResourceTable().get())
 87: .orElseThrow(
 88: () ->
 89: new IllegalStateException(
 90: ""Unsupported case: encountered two distinct resource tables while ""
 91: + ""merging.""));
 92: }
 93: if (split.getNativeConfig().isPresent()) {
 94: mergedNativeConfig =
 95: getSameValueOrNonNull(mergedNativeConfig, split.getNativeConfig().get())
 96: .orElseThrow(
 97: () ->
 98: new IllegalStateException(
 99: ""Encountered two distinct native configs while merging.""));
 100: }
 101: if (split.getApexConfig().isPresent()) {
 102: mergedApexConfig =
 103: getSameValueOrNonNull(mergedApexConfig, split.getApexConfig().get())
 104: .orElseThrow(
 105: () ->
 106: new IllegalStateException(
 107: ""Encountered two distinct apex configs while merging.""));
 108: }
 109: mergedApexEmbeddedApkConfigs =
 110: getSameValueOrNonNull(mergedApexEmbeddedApkConfigs, split.getApexEmbeddedApkConfigs())
 111: .orElseThrow(
 112: () ->
 113: new IllegalStateException(
 114: ""Encountered two distinct apex embedded apk configs while merging.""));
 115: mergedModuleName =
 116: getSameValueOrNonNull(mergedModuleName, split.getModuleName())
 117: .orElseThrow(
 118: () ->
 119: new IllegalStateException(
 120: ""Encountered two distinct module names while merging.""));
 121: mergedIsMasterSplit =
 122: getSameValueOrNonNull(mergedIsMasterSplit, Boolean.valueOf(split.isMasterSplit()))
 123: .orElseThrow(
 124: () ->
 125: new IllegalStateException(
 126: ""Encountered conflicting isMasterSplit flag values while merging.""));
 127: mergedVariantTargeting =
 128: getSameValueOrNonNull(mergedVariantTargeting, split.getVariantTargeting())
 129: .orElseThrow(
 130: () ->
 131: new IllegalStateException(
 132: ""Encountered conflicting variant targeting values while merging.""));
 133: entries.addAll(split.getEntries());
 134: builder.setApkTargeting(split.getApkTargeting());
 135: 
 136: split
 137: .getAssetsConfig()
 138: .ifPresent(
 139: assetsConfig ->
 140: mergeTargetedAssetsDirectories(
 141: mergedAssetsConfig, assetsConfig.getDirectoryList()));
 142: sparseEncoding =
 143: getSameValueOrNonNull(sparseEncoding, split.getSparseEncoding())
 144: .orElseThrow(
 145: () ->
 146: new IllegalStateException(
 147: ""Encountered different sparse encoding values while merging.""));
 148: }
 149: builder.setSparseEncoding(Boolean.valueOf(sparseEncoding));
 150: 
 151: if (mergedManifest != null) {
 152: builder.setAndroidManifest(mergedManifest);
 153: }
 154: if (mergedResourceTable != null) {
 155: builder.setResourceTable(mergedResourceTable);
 156: }
 157: if (mergedNativeConfig != null) {
 158: builder.setNativeConfig(mergedNativeConfig);
 159: }
 160: if (!mergedAssetsConfig.isEmpty()) {
 161: builder.setAssetsConfig(
 162: Assets.newBuilder().addAllDirectory(mergedAssetsConfig.values()).build());
 163: }
 164: if (mergedApexConfig != null) {
 165: builder.setApexConfig(mergedApexConfig);
 166: }
 167: if (mergedApexEmbeddedApkConfigs != null) {
 168: builder.setApexEmbeddedApkConfigs(mergedApexEmbeddedApkConfigs);
 169: }
 170: if (mergedModuleName != null) {
 171: builder.setModuleName(mergedModuleName);
 172: }
 173: if (mergedIsMasterSplit != null) {
 174: builder.setMasterSplit(mergedIsMasterSplit);
 175: }
 176: builder.setVariantTargeting(mergedVariantTargeting);
 177: builder.setEntries(entries.build());
 178: return builder.build();","private ModuleSplit mergeSplits(ImmutableCollection<ModuleSplit> splits) {
    ModuleSplit.Builder builder = ModuleSplit.builder();
    ImmutableList.Builder<ModuleEntry> entries = ImmutableList.builder();
    AndroidManifest mergedManifest = null;
    ResourceTable mergedResourceTable = null;
    NativeLibraries mergedNativeConfig = null;
    Map<String, TargetedAssetsDirectory> mergedAssetsConfig = new HashMap<>();
    ApexImages mergedApexConfig = null;
    ImmutableList<ApexEmbeddedApkConfig> mergedApexEmbeddedApkConfigs = null;
    BundleModuleName mergedModuleName = null;
    Boolean mergedIsMasterSplit = null;
    VariantTargeting mergedVariantTargeting = null;
    Boolean sparseEncoding = null;

    for (ModuleSplit split : splits) {
      mergedManifest =
          getSameValueOrNonNull(mergedManifest, split.getAndroidManifest())
              .orElseThrow(
                  () ->
                      new IllegalStateException(
                          ""Encountered two distinct manifests while merging.""));
      if (split.getResourceTable().isPresent()) {
        mergedResourceTable =
            getSameValueOrNonNull(mergedResourceTable, split.getResourceTable().get())
                .orElseThrow(
                    () ->
                        new IllegalStateException(
                            ""Unsupported case: encountered two distinct resource tables while ""
                                + ""merging.""));
      }
      if (split.getNativeConfig().isPresent()) {
        mergedNativeConfig =
            getSameValueOrNonNull(mergedNativeConfig, split.getNativeConfig().get())
                .orElseThrow(
                    () ->
                        new IllegalStateException(
                            ""Encountered two distinct native configs while merging.""));
      }
      if (split.getApexConfig().isPresent()) {
        mergedApexConfig =
            getSameValueOrNonNull(mergedApexConfig, split.getApexConfig().get())
                .orElseThrow(
                    () ->
                        new IllegalStateException(
                            ""Encountered two distinct apex configs while merging.""));
      }
      mergedApexEmbeddedApkConfigs =
          getSameValueOrNonNull(mergedApexEmbeddedApkConfigs, split.getApexEmbeddedApkConfigs())
              .orElseThrow(
                  () ->
                      new IllegalStateException(
                          ""Encountered two distinct apex embedded apk configs while merging.""));
      mergedModuleName =
          getSameValueOrNonNull(mergedModuleName, split.getModuleName())
              .orElseThrow(
                  () ->
                      new IllegalStateException(
                          ""Encountered two distinct module names while merging.""));
      mergedIsMasterSplit =
          getSameValueOrNonNull(mergedIsMasterSplit, Boolean.valueOf(split.isMasterSplit()))
              .orElseThrow(
                  () ->
                      new IllegalStateException(
                          ""Encountered conflicting isMasterSplit flag values while merging.""));
      mergedVariantTargeting =
          getSameValueOrNonNull(mergedVariantTargeting, split.getVariantTargeting())
              .orElseThrow(
                  () ->
                      new IllegalStateException(
                          ""Encountered conflicting variant targeting values while merging.""));
      entries.addAll(split.getEntries());
      builder.setApkTargeting(split.getApkTargeting());

      split
          .getAssetsConfig()
          .ifPresent(
              assetsConfig ->
                  mergeTargetedAssetsDirectories(
                      mergedAssetsConfig, assetsConfig.getDirectoryList()));
      sparseEncoding =
          getSameValueOrNonNull(sparseEncoding, split.getSparseEncoding())
              .orElseThrow(
                  () ->
                      new IllegalStateException(
                          ""Encountered different sparse encoding values while merging.""));
    }
    builder.setSparseEncoding(Boolean.valueOf(sparseEncoding));

    if (mergedManifest != null) {
      builder.setAndroidManifest(mergedManifest);
    }
    if (mergedResourceTable != null) {
      builder.setResourceTable(mergedResourceTable);
    }
    if (mergedNativeConfig != null) {
      builder.setNativeConfig(mergedNativeConfig);
    }
    if (!mergedAssetsConfig.isEmpty()) {
      builder.setAssetsConfig(
          Assets.newBuilder().addAllDirectory(mergedAssetsConfig.values()).build());
    }
    if (mergedApexConfig != null) {
      builder.setApexConfig(mergedApexConfig);
    }
    if (mergedApexEmbeddedApkConfigs != null) {
      builder.setApexEmbeddedApkConfigs(mergedApexEmbeddedApkConfigs);
    }
    if (mergedModuleName != null) {
      builder.setModuleName(mergedModuleName);
    }
    if (mergedIsMasterSplit != null) {
      builder.setMasterSplit(mergedIsMasterSplit);
    }
    builder.setVariantTargeting(mergedVariantTargeting);
    builder.setEntries(entries.build());
    return builder.build();
  }",0
bundletool-1.15.1,NULL_DEREFERENCE,src/main/java/com/android/tools/build/bundletool/commands/EvaluateDeviceTargetingConfigCommand.java,com.android.tools.build.bundletool.commands.EvaluateDeviceTargetingConfigCommand.execute(java.io.PrintStream):void,200,object `config.deviceTierSet_` last assigned on line 198 could be null and is dereferenced by call to `validateDeviceTierConfig(...)` at line 200.,https://github.com/google/bundletool/blob/1.15.1/src/main/java/com/android/tools/build/bundletool/commands/EvaluateDeviceTargetingConfigCommand.java,"public void execute(PrintStream out) throws IOException, TimeoutException {
    try (Reader configReader = BufferedIo.reader(getDeviceTargetingConfigurationPath())) {
      DeviceTierConfig.Builder configBuilder = DeviceTierConfig.newBuilder();
      JsonFormat.parser().merge(configReader, configBuilder);
      DeviceTierConfig config = configBuilder.build();

      DeviceTierConfigValidator.validateDeviceTierConfig(config);
      if (getCountryCode().isPresent()) {
        DeviceTierConfigValidator.validateCountryCode(getCountryCode().get());
      }",0
bundletool-1.15.1,NULL_DEREFERENCE,src/main/java/com/android/tools/build/bundletool/mergers/ResourceTableMerger.java,"com.android.tools.build.bundletool.mergers.ResourceTableMerger.mergeRepeatedValues(java.util.List,java.util.List,com.android.tools.build.bundletool.mergers.ResourceTableMerger$Lambda$_12_40,com.android.tools.build.bundletool.mergers.ResourceTableMerger$Lambda$_12_46):com.google.common.collect.ImmutableList",250,object `value2` last assigned on line 243 could be null and is dereferenced by call to `add(...)` at line 250.,"227: private <V, I extends Comparable<?>> ImmutableList<V> mergeRepeatedValues(
 228: List<V> values1, List<V> values2, Function<V, I> getIdFn, BiFunction<V, V, V> mergeValuesFn) {
 229: 
 230: ImmutableList.Builder<V> result = ImmutableList.builder();
 231: 
 232: Map<I, V> idToValue1 = Maps.uniqueIndex(values1, getIdFn::apply);
 233: Map<I, V> idToValue2 = Maps.uniqueIndex(values2, getIdFn::apply);
 234: 
 235: // Order the IDs (for better debugging of merged resource tables).
 236: ImmutableList<I> allIds =
 237: Sets.union(idToValue1.keySet(), idToValue2.keySet()).stream()
 238: .sorted()
 239: .collect(toImmutableList());
 240: 
 241: for (I id : allIds) {
 242: V value1 = idToValue1.get(id);
 243: V value2 = idToValue2.get(id);
 244: 
 245: if (value1 != null && value2 != null) {
 246: result.add(mergeValuesFn.apply(value1, value2));
 247: } else if (value1 != null) {
 248: result.add(value1);
 249: } else {
 250: result.add(value2);
 251: }
 252: }
 253: 
 254: return result.build();","private <V, I extends Comparable<?>> ImmutableList<V> mergeRepeatedValues(
      List<V> values1, List<V> values2, Function<V, I> getIdFn, BiFunction<V, V, V> mergeValuesFn) {

    ImmutableList.Builder<V> result = ImmutableList.builder();

    Map<I, V> idToValue1 = Maps.uniqueIndex(values1, getIdFn::apply);
    Map<I, V> idToValue2 = Maps.uniqueIndex(values2, getIdFn::apply);

    // Order the IDs (for better debugging of merged resource tables).
    ImmutableList<I> allIds =
        Sets.union(idToValue1.keySet(), idToValue2.keySet()).stream()
            .sorted()
            .collect(toImmutableList());

    for (I id : allIds) {
      V value1 = idToValue1.get(id);
      V value2 = idToValue2.get(id);

      if (value1 != null && value2 != null) {
        result.add(mergeValuesFn.apply(value1, value2));
      } else if (value1 != null) {
        result.add(value1);
      } else {
        result.add(value2);
      }
    }

    return result.build();
  }",0
bundletool-1.15.1,NULL_DEREFERENCE,src/main/java/com/android/tools/build/bundletool/model/ModuleSplit.java,com.android.tools.build.bundletool.model.ModuleSplit.findEntry(com.android.tools.build.bundletool.model.ZipPath):java.util.Optional,703,object returned by `path.getParent()` could be null and is dereferenced by call to `getEntriesInDirectory(...)` at line 703.,https://github.com/google/bundletool/blob/1.15.1/src/main/java/com/android/tools/build/bundletool/model/ModuleSplit.java,"public Optional<ModuleEntry> findEntry(ZipPath path) {
    return getEntriesInDirectory(path.getParent())
        .filter(entry -> entry.getPath().equals(path))
        .collect(toOptional());
  }",1
dolphinscheduler-2.0.9,NULL_DEREFERENCE,dolphinscheduler-alert/dolphinscheduler-alert-plugins/dolphinscheduler-alert-script/src/main/java/org/apache/dolphinscheduler/plugin/alert/script/OSUtils.java,org.apache.dolphinscheduler.plugin.alert.script.OSUtils.isWindows():java.lang.Boolean,26,"object returned by `getProperty(""os.name"")` could be null and is dereferenced at line 26.","25: static Boolean isWindows() {
 26: return System.getProperty(""os.name"").startsWith(""Windows"");","static Boolean isWindows() {
        return System.getProperty(""os.name"").startsWith(""Windows"");
    }",1
dolphinscheduler-2.0.9,NULL_DEREFERENCE,dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/master/dispatch/host/assign/LowerWeightRoundRobin.java,org.apache.dolphinscheduler.server.master.dispatch.host.assign.LowerWeightRoundRobin.doSelect(java.util.Collection):org.apache.dolphinscheduler.server.master.dispatch.host.assign.HostWeight,52,object `lowerNode` last assigned on line 42 could be null and is dereferenced at line 52.,"39: public HostWeight doSelect(Collection<HostWeight> sources) {
 40: double totalWeight = 0;
 41: double lowWeight = 0;
 42: HostWeight lowerNode = null;
 43: List<HostWeight> weights = canAssignTaskHost(sources);
 44: for (HostWeight hostWeight : weights) {
 45: totalWeight += hostWeight.getWeight();
 46: hostWeight.setCurrentWeight(hostWeight.getCurrentWeight() + hostWeight.getWeight());
 47: if (lowerNode == null || lowWeight > hostWeight.getCurrentWeight()) {
 48: lowerNode = hostWeight;
 49: lowWeight = hostWeight.getCurrentWeight();
 50: }
 51: }
 52: lowerNode.setCurrentWeight(lowerNode.getCurrentWeight() + totalWeight);
 53: return lowerNode;","public HostWeight doSelect(Collection<HostWeight> sources) {
        double totalWeight = 0;
        double lowWeight = 0;
        HostWeight lowerNode = null;
        List<HostWeight> weights = canAssignTaskHost(sources);
        for (HostWeight hostWeight : weights) {
            totalWeight += hostWeight.getWeight();
            hostWeight.setCurrentWeight(hostWeight.getCurrentWeight() + hostWeight.getWeight());
            if (lowerNode == null || lowWeight > hostWeight.getCurrentWeight()) {
                lowerNode = hostWeight;
                lowWeight = hostWeight.getCurrentWeight();
            }
        }
        lowerNode.setCurrentWeight(lowerNode.getCurrentWeight() + totalWeight);
        return lowerNode;
    }
",0
dolphinscheduler-2.0.9,NULL_DEREFERENCE,dolphinscheduler-datasource-plugin/dolphinscheduler-datasource-api/src/main/java/org/apache/dolphinscheduler/plugin/datasource/api/datasource/clickhouse/ClickHouseDatasourceProcessor.java,org.apache.dolphinscheduler.plugin.datasource.api.datasource.clickhouse.ClickHouseDatasourceProcessor.createDatasourceParamDTO(java.lang.String):org.apache.dolphinscheduler.plugin.datasource.api.datasource.BaseDataSourceParamDTO,44,object `connectionParams` last assigned on line 41 could be null and is dereferenced at line 44.,"40: public BaseDataSourceParamDTO createDatasourceParamDTO(String connectionJson) {
 41: ClickhouseConnectionParam connectionParams = (ClickhouseConnectionParam) createConnectionParams(connectionJson);
 42: 
 43: ClickHouseDatasourceParamDTO clickHouseDatasourceParamDTO = new ClickHouseDatasourceParamDTO();
 44: clickHouseDatasourceParamDTO.setDatabase(connectionParams.getDatabase());
 45: clickHouseDatasourceParamDTO.setUserName(connectionParams.getUser());
 46: clickHouseDatasourceParamDTO.setOther(parseOther(connectionParams.getOther()));
 47: 
 48: String[] hostSeperator = connectionParams.getAddress().split(Constants.DOUBLE_SLASH);
 49: String[] hostPortArray = hostSeperator[hostSeperator.length - 1].split(Constants.COMMA);
 50: clickHouseDatasourceParamDTO.setPort(Integer.parseInt(hostPortArray[0].split(Constants.COLON)[1]));
 51: clickHouseDatasourceParamDTO.setHost(hostPortArray[0].split(Constants.COLON)[0]);
 52: 
 53: return clickHouseDatasourceParamDTO;","public BaseDataSourceParamDTO createDatasourceParamDTO(String connectionJson) {
        ClickhouseConnectionParam connectionParams = (ClickhouseConnectionParam) createConnectionParams(connectionJson);

        ClickHouseDatasourceParamDTO clickHouseDatasourceParamDTO = new ClickHouseDatasourceParamDTO();
        clickHouseDatasourceParamDTO.setDatabase(connectionParams.getDatabase());
        clickHouseDatasourceParamDTO.setUserName(connectionParams.getUser());
        clickHouseDatasourceParamDTO.setOther(parseOther(connectionParams.getOther()));

        String[] hostSeperator = connectionParams.getAddress().split(Constants.DOUBLE_SLASH);
        String[] hostPortArray = hostSeperator[hostSeperator.length - 1].split(Constants.COMMA);
        clickHouseDatasourceParamDTO.setPort(Integer.parseInt(hostPortArray[0].split(Constants.COLON)[1]));
        clickHouseDatasourceParamDTO.setHost(hostPortArray[0].split(Constants.COLON)[0]);

        return clickHouseDatasourceParamDTO;
    }",1
dolphinscheduler-2.0.9,NULL_DEREFERENCE,dolphinscheduler-datasource-plugin/dolphinscheduler-datasource-api/src/main/java/org/apache/dolphinscheduler/plugin/datasource/api/datasource/db2/Db2DatasourceProcessor.java,org.apache.dolphinscheduler.plugin.datasource.api.datasource.db2.Db2DatasourceProcessor.createDatasourceParamDTO(java.lang.String):org.apache.dolphinscheduler.plugin.datasource.api.datasource.BaseDataSourceParamDTO,45,object `connectionParams` last assigned on line 42 could be null and is dereferenced at line 45.,"41: public BaseDataSourceParamDTO createDatasourceParamDTO(String connectionJson) {
 42: Db2ConnectionParam connectionParams = (Db2ConnectionParam) createConnectionParams(connectionJson);
 43: 
 44: Db2DatasourceParamDTO db2DatasourceParamDTO = new Db2DatasourceParamDTO();
 45: db2DatasourceParamDTO.setDatabase(connectionParams.getDatabase());
 46: db2DatasourceParamDTO.setOther(parseOther(connectionParams.getOther()));
 47: db2DatasourceParamDTO.setUserName(db2DatasourceParamDTO.getUserName());
 48: 
 49: String[] hostSeperator = connectionParams.getAddress().split(Constants.DOUBLE_SLASH);
 50: String[] hostPortArray = hostSeperator[hostSeperator.length - 1].split(Constants.COMMA);
 51: db2DatasourceParamDTO.setHost(hostPortArray[0].split(Constants.COLON)[0]);
 52: db2DatasourceParamDTO.setPort(Integer.parseInt(hostPortArray[0].split(Constants.COLON)[1]));
 53: 
 54: return db2DatasourceParamDTO;","public BaseDataSourceParamDTO createDatasourceParamDTO(String connectionJson) {
        Db2ConnectionParam connectionParams = (Db2ConnectionParam) createConnectionParams(connectionJson);

        Db2DatasourceParamDTO db2DatasourceParamDTO = new Db2DatasourceParamDTO();
        db2DatasourceParamDTO.setDatabase(connectionParams.getDatabase());
        db2DatasourceParamDTO.setOther(parseOther(connectionParams.getOther()));
        db2DatasourceParamDTO.setUserName(db2DatasourceParamDTO.getUserName());

        String[] hostSeperator = connectionParams.getAddress().split(Constants.DOUBLE_SLASH);
        String[] hostPortArray = hostSeperator[hostSeperator.length - 1].split(Constants.COMMA);
        db2DatasourceParamDTO.setHost(hostPortArray[0].split(Constants.COLON)[0]);
        db2DatasourceParamDTO.setPort(Integer.parseInt(hostPortArray[0].split(Constants.COLON)[1]));

        return db2DatasourceParamDTO;
    }",1
dolphinscheduler-2.0.9,NULL_DEREFERENCE,dolphinscheduler-datasource-plugin/dolphinscheduler-datasource-api/src/main/java/org/apache/dolphinscheduler/plugin/datasource/api/datasource/postgresql/PostgreSqlDatasourceProcessor.java,org.apache.dolphinscheduler.plugin.datasource.api.datasource.postgresql.PostgreSqlDatasourceProcessor.createDatasourceParamDTO(java.lang.String):org.apache.dolphinscheduler.plugin.datasource.api.datasource.BaseDataSourceParamDTO,44,object `connectionParams` last assigned on line 42 could be null and is dereferenced at line 44.,"41: public BaseDataSourceParamDTO createDatasourceParamDTO(String connectionJson) {
 42: PostgreSqlConnectionParam connectionParams = (PostgreSqlConnectionParam) createConnectionParams(connectionJson);
 43: PostgreSqlDatasourceParamDTO postgreSqlDatasourceParamDTO = new PostgreSqlDatasourceParamDTO();
 44: postgreSqlDatasourceParamDTO.setDatabase(connectionParams.getDatabase());
 45: postgreSqlDatasourceParamDTO.setUserName(connectionParams.getUser());
 46: postgreSqlDatasourceParamDTO.setOther(parseOther(connectionParams.getOther()));
 47: 
 48: String address = connectionParams.getAddress();
 49: String[] hostSeperator = address.split(Constants.DOUBLE_SLASH);
 50: String[] hostPortArray = hostSeperator[hostSeperator.length - 1].split(Constants.COMMA);
 51: postgreSqlDatasourceParamDTO.setHost(hostPortArray[0].split(Constants.COLON)[0]);
 52: postgreSqlDatasourceParamDTO.setPort(Integer.parseInt(hostPortArray[0].split(Constants.COLON)[1]));
 53: 
 54: return postgreSqlDatasourceParamDTO;","public BaseDataSourceParamDTO createDatasourceParamDTO(String connectionJson) {
        PostgreSqlConnectionParam connectionParams = (PostgreSqlConnectionParam) createConnectionParams(connectionJson);
        PostgreSqlDatasourceParamDTO postgreSqlDatasourceParamDTO = new PostgreSqlDatasourceParamDTO();
        postgreSqlDatasourceParamDTO.setDatabase(connectionParams.getDatabase());
        postgreSqlDatasourceParamDTO.setUserName(connectionParams.getUser());
        postgreSqlDatasourceParamDTO.setOther(parseOther(connectionParams.getOther()));

        String address = connectionParams.getAddress();
        String[] hostSeperator = address.split(Constants.DOUBLE_SLASH);
        String[] hostPortArray = hostSeperator[hostSeperator.length - 1].split(Constants.COMMA);
        postgreSqlDatasourceParamDTO.setHost(hostPortArray[0].split(Constants.COLON)[0]);
        postgreSqlDatasourceParamDTO.setPort(Integer.parseInt(hostPortArray[0].split(Constants.COLON)[1]));

        return postgreSqlDatasourceParamDTO;
    }
",1
dolphinscheduler-2.0.9,NULL_DEREFERENCE,dolphinscheduler-datasource-plugin/dolphinscheduler-datasource-api/src/main/java/org/apache/dolphinscheduler/plugin/datasource/api/datasource/sqlserver/SqlServerDatasourceProcessor.java,org.apache.dolphinscheduler.plugin.datasource.api.datasource.sqlserver.SqlServerDatasourceProcessor.createDatasourceParamDTO(java.lang.String):org.apache.dolphinscheduler.plugin.datasource.api.datasource.BaseDataSourceParamDTO,43,object `connectionParams` last assigned on line 42 could be null and is dereferenced at line 43.,"41: public BaseDataSourceParamDTO createDatasourceParamDTO(String connectionJson) {
 42: SqlServerConnectionParam connectionParams = (SqlServerConnectionParam) createConnectionParams(connectionJson);
 43: String[] hostSeperator = connectionParams.getAddress().split(Constants.DOUBLE_SLASH);
 44: String[] hostPortArray = hostSeperator[hostSeperator.length - 1].split(Constants.COMMA);
 45: 
 46: SqlServerDatasourceParamDTO sqlServerDatasourceParamDTO = new SqlServerDatasourceParamDTO();
 47: sqlServerDatasourceParamDTO.setDatabase(connectionParams.getDatabase());
 48: sqlServerDatasourceParamDTO.setUserName(connectionParams.getUser());
 49: sqlServerDatasourceParamDTO.setOther(parseOther(connectionParams.getOther()));
 50: sqlServerDatasourceParamDTO.setPort(Integer.parseInt(hostPortArray[0].split(Constants.COLON)[1]));
 51: sqlServerDatasourceParamDTO.setHost(hostPortArray[0].split(Constants.COLON)[0]);
 52: return sqlServerDatasourceParamDTO;","public BaseDataSourceParamDTO createDatasourceParamDTO(String connectionJson) {
        SqlServerConnectionParam connectionParams = (SqlServerConnectionParam) createConnectionParams(connectionJson);
        String[] hostSeperator = connectionParams.getAddress().split(Constants.DOUBLE_SLASH);
        String[] hostPortArray = hostSeperator[hostSeperator.length - 1].split(Constants.COMMA);

        SqlServerDatasourceParamDTO sqlServerDatasourceParamDTO = new SqlServerDatasourceParamDTO();
        sqlServerDatasourceParamDTO.setDatabase(connectionParams.getDatabase());
        sqlServerDatasourceParamDTO.setUserName(connectionParams.getUser());
        sqlServerDatasourceParamDTO.setOther(parseOther(connectionParams.getOther()));
        sqlServerDatasourceParamDTO.setPort(Integer.parseInt(hostPortArray[0].split(Constants.COLON)[1]));
        sqlServerDatasourceParamDTO.setHost(hostPortArray[0].split(Constants.COLON)[0]);
        return sqlServerDatasourceParamDTO;
    }",1
dolphinscheduler-2.0.9,NULL_DEREFERENCE,dolphinscheduler-datasource-plugin/dolphinscheduler-datasource-api/src/main/java/org/apache/dolphinscheduler/plugin/datasource/api/datasource/hive/HiveDatasourceProcessor.java,org.apache.dolphinscheduler.plugin.datasource.api.datasource.hive.HiveDatasourceProcessor.createDatasourceParamDTO(java.lang.String):org.apache.dolphinscheduler.plugin.datasource.api.datasource.BaseDataSourceParamDTO,47,object `hiveConnectionParam` last assigned on line 45 could be null and is dereferenced at line 47.,"43: public BaseDataSourceParamDTO createDatasourceParamDTO(String connectionJson) {
 44: HiveDataSourceParamDTO hiveDataSourceParamDTO = new HiveDataSourceParamDTO();
 45: HiveConnectionParam hiveConnectionParam = (HiveConnectionParam) createConnectionParams(connectionJson);
 46: 
 47: hiveDataSourceParamDTO.setDatabase(hiveConnectionParam.getDatabase());
 48: hiveDataSourceParamDTO.setUserName(hiveConnectionParam.getUser());
 49: hiveDataSourceParamDTO.setOther(parseOther(hiveConnectionParam.getOther()));
 50: hiveDataSourceParamDTO.setLoginUserKeytabUsername(hiveConnectionParam.getLoginUserKeytabUsername());
 51: hiveDataSourceParamDTO.setLoginUserKeytabPath(hiveConnectionParam.getLoginUserKeytabPath());
 52: hiveDataSourceParamDTO.setJavaSecurityKrb5Conf(hiveConnectionParam.getJavaSecurityKrb5Conf());
 53: 
 54: String[] tmpArray = hiveConnectionParam.getAddress().split(Constants.DOUBLE_SLASH);
 55: StringBuilder hosts = new StringBuilder();
 56: String[] hostPortArray = tmpArray[tmpArray.length - 1].split(Constants.COMMA);
 57: for (String hostPort : hostPortArray) {
 58: hosts.append(hostPort.split(Constants.COLON)[0]).append(Constants.COMMA);
 59: }
 60: hosts.deleteCharAt(hosts.length() - 1);
 61: hiveDataSourceParamDTO.setHost(hosts.toString());
 62: hiveDataSourceParamDTO.setPort(Integer.parseInt(hostPortArray[0].split(Constants.COLON)[1]));
 63: 
 64: return hiveDataSourceParamDTO;","public BaseDataSourceParamDTO createDatasourceParamDTO(String connectionJson) {
        HiveDataSourceParamDTO hiveDataSourceParamDTO = new HiveDataSourceParamDTO();
        HiveConnectionParam hiveConnectionParam = (HiveConnectionParam) createConnectionParams(connectionJson);

        hiveDataSourceParamDTO.setDatabase(hiveConnectionParam.getDatabase());
        hiveDataSourceParamDTO.setUserName(hiveConnectionParam.getUser());
        hiveDataSourceParamDTO.setOther(parseOther(hiveConnectionParam.getOther()));
        hiveDataSourceParamDTO.setLoginUserKeytabUsername(hiveConnectionParam.getLoginUserKeytabUsername());
        hiveDataSourceParamDTO.setLoginUserKeytabPath(hiveConnectionParam.getLoginUserKeytabPath());
        hiveDataSourceParamDTO.setJavaSecurityKrb5Conf(hiveConnectionParam.getJavaSecurityKrb5Conf());

        String[] tmpArray = hiveConnectionParam.getAddress().split(Constants.DOUBLE_SLASH);
        StringBuilder hosts = new StringBuilder();
        String[] hostPortArray = tmpArray[tmpArray.length - 1].split(Constants.COMMA);
        for (String hostPort : hostPortArray) {
            hosts.append(hostPort.split(Constants.COLON)[0]).append(Constants.COMMA);
        }
        hosts.deleteCharAt(hosts.length() - 1);
        hiveDataSourceParamDTO.setHost(hosts.toString());
        hiveDataSourceParamDTO.setPort(Integer.parseInt(hostPortArray[0].split(Constants.COLON)[1]));

        return hiveDataSourceParamDTO;
    }
",1
dolphinscheduler-2.0.9,NULL_DEREFERENCE,dolphinscheduler-datasource-plugin/dolphinscheduler-datasource-api/src/main/java/org/apache/dolphinscheduler/plugin/datasource/api/datasource/presto/PrestoDatasourceProcessor.java,org.apache.dolphinscheduler.plugin.datasource.api.datasource.presto.PrestoDatasourceProcessor.createDatasourceParamDTO(java.lang.String):org.apache.dolphinscheduler.plugin.datasource.api.datasource.BaseDataSourceParamDTO,46,object `connectionParams` last assigned on line 44 could be null and is dereferenced at line 46.,"43: public BaseDataSourceParamDTO createDatasourceParamDTO(String connectionJson) {
 44: PrestoConnectionParam connectionParams = (PrestoConnectionParam) createConnectionParams(connectionJson);
 45: 
 46: String[] hostSeperator = connectionParams.getAddress().split(Constants.DOUBLE_SLASH);
 47: String[] hostPortArray = hostSeperator[hostSeperator.length - 1].split(Constants.COMMA);
 48: 
 49: PrestoDatasourceParamDTO prestoDatasourceParamDTO = new PrestoDatasourceParamDTO();
 50: prestoDatasourceParamDTO.setPort(Integer.parseInt(hostPortArray[0].split(Constants.COLON)[1]));
 51: prestoDatasourceParamDTO.setHost(hostPortArray[0].split(Constants.COLON)[0]);
 52: prestoDatasourceParamDTO.setDatabase(connectionParams.getDatabase());
 53: prestoDatasourceParamDTO.setUserName(connectionParams.getUser());
 54: prestoDatasourceParamDTO.setOther(parseOther(connectionParams.getOther()));
 55: 
 56: return prestoDatasourceParamDTO;","public BaseDataSourceParamDTO createDatasourceParamDTO(String connectionJson) {
        PrestoConnectionParam connectionParams = (PrestoConnectionParam) createConnectionParams(connectionJson);

        String[] hostSeperator = connectionParams.getAddress().split(Constants.DOUBLE_SLASH);
        String[] hostPortArray = hostSeperator[hostSeperator.length - 1].split(Constants.COMMA);

        PrestoDatasourceParamDTO prestoDatasourceParamDTO = new PrestoDatasourceParamDTO();
        prestoDatasourceParamDTO.setPort(Integer.parseInt(hostPortArray[0].split(Constants.COLON)[1]));
        prestoDatasourceParamDTO.setHost(hostPortArray[0].split(Constants.COLON)[0]);
        prestoDatasourceParamDTO.setDatabase(connectionParams.getDatabase());
        prestoDatasourceParamDTO.setUserName(connectionParams.getUser());
        prestoDatasourceParamDTO.setOther(parseOther(connectionParams.getOther()));

        return prestoDatasourceParamDTO;
    }",1
dolphinscheduler-2.0.9,NULL_DEREFERENCE,dolphinscheduler-datasource-plugin/dolphinscheduler-datasource-api/src/main/java/org/apache/dolphinscheduler/plugin/datasource/api/datasource/oracle/OracleDatasourceProcessor.java,org.apache.dolphinscheduler.plugin.datasource.api.datasource.oracle.OracleDatasourceProcessor.createDatasourceParamDTO(java.lang.String):org.apache.dolphinscheduler.plugin.datasource.api.datasource.BaseDataSourceParamDTO,48,object `connectionParams` last assigned on line 45 could be null and is dereferenced at line 48.,"44: public BaseDataSourceParamDTO createDatasourceParamDTO(String connectionJson) {
 45: OracleConnectionParam connectionParams = (OracleConnectionParam) createConnectionParams(connectionJson);
 46: OracleDatasourceParamDTO oracleDatasourceParamDTO = new OracleDatasourceParamDTO();
 47: 
 48: oracleDatasourceParamDTO.setDatabase(connectionParams.getDatabase());
 49: oracleDatasourceParamDTO.setUserName(connectionParams.getUser());
 50: oracleDatasourceParamDTO.setOther(parseOther(connectionParams.getOther()));
 51: 
 52: String hostSeperator = Constants.DOUBLE_SLASH;
 53: if (DbConnectType.ORACLE_SID.equals(connectionParams.connectType)) {
 54: hostSeperator = Constants.AT_SIGN;
 55: }
 56: String[] hostPort = connectionParams.getAddress().split(hostSeperator);
 57: String[] hostPortArray = hostPort[hostPort.length - 1].split(Constants.COMMA);
 58: oracleDatasourceParamDTO.setPort(Integer.parseInt(hostPortArray[0].split(Constants.COLON)[1]));
 59: oracleDatasourceParamDTO.setHost(hostPortArray[0].split(Constants.COLON)[0]);
 60: 
 61: return oracleDatasourceParamDTO;","public BaseDataSourceParamDTO createDatasourceParamDTO(String connectionJson) {
        OracleConnectionParam connectionParams = (OracleConnectionParam) createConnectionParams(connectionJson);
        OracleDatasourceParamDTO oracleDatasourceParamDTO = new OracleDatasourceParamDTO();

        oracleDatasourceParamDTO.setDatabase(connectionParams.getDatabase());
        oracleDatasourceParamDTO.setUserName(connectionParams.getUser());
        oracleDatasourceParamDTO.setOther(parseOther(connectionParams.getOther()));

        String hostSeperator = Constants.DOUBLE_SLASH;
        if (DbConnectType.ORACLE_SID.equals(connectionParams.connectType)) {
            hostSeperator = Constants.AT_SIGN;
        }
        String[] hostPort = connectionParams.getAddress().split(hostSeperator);
        String[] hostPortArray = hostPort[hostPort.length - 1].split(Constants.COMMA);
        oracleDatasourceParamDTO.setPort(Integer.parseInt(hostPortArray[0].split(Constants.COLON)[1]));
        oracleDatasourceParamDTO.setHost(hostPortArray[0].split(Constants.COLON)[0]);

        return oracleDatasourceParamDTO;
    }",1
dolphinscheduler-2.0.9,NULL_DEREFERENCE,dolphinscheduler-remote/src/main/java/org/apache/dolphinscheduler/rpc/codec/NettyDecoder.java,"org.apache.dolphinscheduler.rpc.codec.NettyDecoder.decode(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List):void",76,object `serializer` last assigned on line 75 could be null and is dereferenced at line 76.,"45: protected void decode(ChannelHandlerContext channelHandlerContext, ByteBuf byteBuf, List<Object> list) throws Exception {
 46: if (byteBuf.readableBytes() < RpcProtocolConstants.HEADER_LENGTH) {
 47: return;
 48: }
 49: 
 50: byteBuf.markReaderIndex();
 51: 
 52: short magic = byteBuf.readShort();
 53: 
 54: if (RpcProtocolConstants.MAGIC != magic) {
 55: throw new IllegalArgumentException(""magic number is illegal, "" + magic);
 56: }
 57: byte eventType = byteBuf.readByte();
 58: byte version = byteBuf.readByte();
 59: byte serialization = byteBuf.readByte();
 60: long requestId = byteBuf.readLong();
 61: int dataLength = byteBuf.readInt();
 62: byte[] data = new byte[dataLength];
 63: 
 64: RpcProtocol rpcProtocol = new RpcProtocol();
 65: 
 66: MessageHeader header = new MessageHeader();
 67: header.setVersion(version);
 68: header.setSerialization(serialization);
 69: header.setRequestId(requestId);
 70: header.setEventType(eventType);
 71: header.setMsgLength(dataLength);
 72: byteBuf.readBytes(data);
 73: rpcProtocol.setMsgHeader(header);
 74: if (eventType != EventType.HEARTBEAT.getType()) {
 75: Serializer serializer = RpcSerializer.getSerializerByType(serialization);
 76: Object obj = serializer.deserialize(data, genericClass);
 77: rpcProtocol.setBody(obj);
 78: }
 79: list.add(rpcProtocol);","protected void decode(ChannelHandlerContext channelHandlerContext, ByteBuf byteBuf, List<Object> list) throws Exception {
        if (byteBuf.readableBytes() < RpcProtocolConstants.HEADER_LENGTH) {
            return;
        }

        byteBuf.markReaderIndex();

        short magic = byteBuf.readShort();

        if (RpcProtocolConstants.MAGIC != magic) {
            throw new IllegalArgumentException(""magic number is illegal, "" + magic);
        }
        byte eventType = byteBuf.readByte();
        byte version = byteBuf.readByte();
        byte serialization = byteBuf.readByte();
        long requestId = byteBuf.readLong();
        int dataLength = byteBuf.readInt();
        byte[] data = new byte[dataLength];

        RpcProtocol rpcProtocol = new RpcProtocol();

        MessageHeader header = new MessageHeader();
        header.setVersion(version);
        header.setSerialization(serialization);
        header.setRequestId(requestId);
        header.setEventType(eventType);
        header.setMsgLength(dataLength);
        byteBuf.readBytes(data);
        rpcProtocol.setMsgHeader(header);
        if (eventType != EventType.HEARTBEAT.getType()) {
            Serializer serializer = RpcSerializer.getSerializerByType(serialization);
            Object obj = serializer.deserialize(data, genericClass);
            rpcProtocol.setBody(obj);
        }
        list.add(rpcProtocol);
    }",0
dolphinscheduler-2.0.9,NULL_DEREFERENCE,dolphinscheduler-datasource-plugin/dolphinscheduler-datasource-api/src/main/java/org/apache/dolphinscheduler/plugin/datasource/api/datasource/spark/SparkDatasourceProcessor.java,org.apache.dolphinscheduler.plugin.datasource.api.datasource.spark.SparkDatasourceProcessor.createDatasourceParamDTO(java.lang.String):org.apache.dolphinscheduler.plugin.datasource.api.datasource.BaseDataSourceParamDTO,50,object `connectionParams` last assigned on line 47 could be null and is dereferenced at line 50.,"46: public BaseDataSourceParamDTO createDatasourceParamDTO(String connectionJson) {
 47: SparkConnectionParam connectionParams = (SparkConnectionParam) createConnectionParams(connectionJson);
 48: 
 49: SparkDatasourceParamDTO sparkDatasourceParamDTO = new SparkDatasourceParamDTO();
 50: sparkDatasourceParamDTO.setDatabase(connectionParams.getDatabase());
 51: sparkDatasourceParamDTO.setUserName(connectionParams.getUser());
 52: sparkDatasourceParamDTO.setOther(parseOther(connectionParams.getOther()));
 53: sparkDatasourceParamDTO.setJavaSecurityKrb5Conf(connectionParams.getJavaSecurityKrb5Conf());
 54: sparkDatasourceParamDTO.setLoginUserKeytabPath(connectionParams.getLoginUserKeytabPath());
 55: sparkDatasourceParamDTO.setLoginUserKeytabUsername(connectionParams.getLoginUserKeytabUsername());
 56: 
 57: StringBuilder hosts = new StringBuilder();
 58: String[] tmpArray = connectionParams.getAddress().split(Constants.DOUBLE_SLASH);
 59: String[] hostPortArray = tmpArray[tmpArray.length - 1].split(Constants.COMMA);
 60: Arrays.stream(hostPortArray).forEach(hostPort -> hosts.append(hostPort.split(Constants.COLON)[0]).append(Constants.COMMA));
 61: hosts.deleteCharAt(hosts.length() - 1);
 62: 
 63: sparkDatasourceParamDTO.setHost(hosts.toString());
 64: sparkDatasourceParamDTO.setPort(Integer.parseInt(hostPortArray[0].split(Constants.COLON)[1]));
 65: 
 66: return sparkDatasourceParamDTO;","public BaseDataSourceParamDTO createDatasourceParamDTO(String connectionJson) {
        SparkConnectionParam connectionParams = (SparkConnectionParam) createConnectionParams(connectionJson);

        SparkDatasourceParamDTO sparkDatasourceParamDTO = new SparkDatasourceParamDTO();
        sparkDatasourceParamDTO.setDatabase(connectionParams.getDatabase());
        sparkDatasourceParamDTO.setUserName(connectionParams.getUser());
        sparkDatasourceParamDTO.setOther(parseOther(connectionParams.getOther()));
        sparkDatasourceParamDTO.setJavaSecurityKrb5Conf(connectionParams.getJavaSecurityKrb5Conf());
        sparkDatasourceParamDTO.setLoginUserKeytabPath(connectionParams.getLoginUserKeytabPath());
        sparkDatasourceParamDTO.setLoginUserKeytabUsername(connectionParams.getLoginUserKeytabUsername());

        StringBuilder hosts = new StringBuilder();
        String[] tmpArray = connectionParams.getAddress().split(Constants.DOUBLE_SLASH);
        String[] hostPortArray = tmpArray[tmpArray.length - 1].split(Constants.COMMA);
        Arrays.stream(hostPortArray).forEach(hostPort -> hosts.append(hostPort.split(Constants.COLON)[0]).append(Constants.COMMA));
        hosts.deleteCharAt(hosts.length() - 1);

        sparkDatasourceParamDTO.setHost(hosts.toString());
        sparkDatasourceParamDTO.setPort(Integer.parseInt(hostPortArray[0].split(Constants.COLON)[1]));

        return sparkDatasourceParamDTO;
    }",1
dolphinscheduler-2.0.9,NULL_DEREFERENCE,dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/master/processor/CacheProcessor.java,"org.apache.dolphinscheduler.server.master.processor.CacheProcessor.process(io.netty.channel.Channel,org.apache.dolphinscheduler.remote.command.Command):void",54,object `cacheExpireCommand` last assigned on line 50 could be null and is dereferenced by call to `cacheExpire(...)` at line 54.,"47: public void process(Channel channel, Command command) {
 48: Preconditions.checkArgument(CommandType.CACHE_EXPIRE == command.getType(), String.format(""invalid command type: %s"", command.getType()));
 49: 
 50: CacheExpireCommand cacheExpireCommand = JSONUtils.parseObject(command.getBody(), CacheExpireCommand.class);
 51: 
 52: logger.info(""received command : {}"", cacheExpireCommand);
 53: 
 54: this.cacheExpire(cacheExpireCommand);","public void process(Channel channel, Command command) {
        Preconditions.checkArgument(CommandType.CACHE_EXPIRE == command.getType(), String.format(""invalid command type: %s"", command.getType()));

        CacheExpireCommand cacheExpireCommand = JSONUtils.parseObject(command.getBody(), CacheExpireCommand.class);

        logger.info(""received command : {}"", cacheExpireCommand);

        this.cacheExpire(cacheExpireCommand);
    }",1
dolphinscheduler-2.0.9,NULL_DEREFERENCE,dolphinscheduler-alert/dolphinscheduler-alert-plugins/dolphinscheduler-alert-slack/src/main/java/org/apache/dolphinscheduler/plugin/alert/slack/SlackSender.java,org.apache.dolphinscheduler.plugin.alert.slack.SlackSender.<init>(java.util.HashMap),55,object `SlackSender.webHookUrl` last assigned on line 52 could be null and is dereferenced at line 55.,"51 public SlackSender(Map<String, String> slackAlertParam) {
52 webHookUrl = slackAlertParam.get(SlackParamsConstants.SLACK_WEN_HOOK_URL_NAME);
53 botName = slackAlertParam.get(SlackParamsConstants.SLACK_BOT_NAME);
54 Preconditions.checkArgument(!Objects.isNull(webHookUrl), ""SlackWebHookURL can not be null"");
55 Preconditions.checkArgument(webHookUrl.startsWith(""https://hooks.slack.com/services/""), ""SlackWebHookURL invalidate"");
56 Preconditions.checkArgument(!Objects.isNull(botName), ""slack bot name can not be null"");
57 }","public SlackSender(Map<String, String> slackAlertParam) {
        webHookUrl = slackAlertParam.get(SlackParamsConstants.SLACK_WEN_HOOK_URL_NAME);
        botName = slackAlertParam.get(SlackParamsConstants.SLACK_BOT_NAME);
        Preconditions.checkArgument(!Objects.isNull(webHookUrl), ""SlackWebHookURL can not be null"");
        Preconditions.checkArgument(webHookUrl.startsWith(""https://hooks.slack.com/services/""), ""SlackWebHookURL invalidate"");
        Preconditions.checkArgument(!Objects.isNull(botName), ""slack bot name can not be null"");
    }",0
dolphinscheduler-2.0.9,NULL_DEREFERENCE,dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/worker/processor/HostUpdateProcessor.java,"org.apache.dolphinscheduler.server.worker.processor.HostUpdateProcessor.process(io.netty.channel.Channel,org.apache.dolphinscheduler.remote.command.Command):void",57,object `updateCommand` last assigned on line 55 could be null and is dereferenced at line 57.,"53: public void process(Channel channel, Command command) {
 54: Preconditions.checkArgument(CommandType.PROCESS_HOST_UPDATE_REQUEST == command.getType(), String.format(""invalid command type : %s"", command.getType()));
 55: HostUpdateCommand updateCommand = JSONUtils.parseObject(command.getBody(), HostUpdateCommand.class);
 56: logger.info(""received host update command : {}"", updateCommand);
 57: taskCallbackService.changeRemoteChannel(updateCommand.getTaskInstanceId(), new NettyRemoteChannel(channel, command.getOpaque()));","public void process(Channel channel, Command command) {
        Preconditions.checkArgument(CommandType.PROCESS_HOST_UPDATE_REQUEST == command.getType(), String.format(""invalid command type : %s"", command.getType()));
        HostUpdateCommand updateCommand = JSONUtils.parseObject(command.getBody(), HostUpdateCommand.class);
        logger.info(""received host update command : {}"", updateCommand);
        taskCallbackService.changeRemoteChannel(updateCommand.getTaskInstanceId(), new NettyRemoteChannel(channel, command.getOpaque()));

    }",1
dolphinscheduler-2.0.9,NULL_DEREFERENCE,dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/monitor/AbstractMonitor.java,"org.apache.dolphinscheduler.server.monitor.AbstractMonitor.restartServer(java.lang.String,java.lang.Integer,java.lang.String):void",74,object `needRestartServer` last assigned on line 71 could be null and is dereferenced at line 74.,"56: private void restartServer(String path,Integer port,String installPath) throws Exception{
 57: 
 58: String type = path.split(""/"")[2];
 59: String serverName = null;
 60: String nodes = null;
 61: if (""masters"".equals(type)){
 62: serverName = ""master-server"";
 63: nodes = runConfig.getMasters();
 64: }else if (""workers"".equals(type)){
 65: serverName = ""worker-server"";
 66: nodes = runConfig.getWorkers();
 67: }
 68: 
 69: Map<String, String> activeNodeMap = getActiveNodesByPath(path);
 70: 
 71: Set<String> needRestartServer = getNeedRestartServer(getRunConfigServer(nodes),
 72: activeNodeMap.keySet());
 73: 
 74: for (String node : needRestartServer){","private void restartServer(String path,Integer port,String installPath) throws Exception{

        String type = path.split(""/"")[2];
        String serverName = null;
        String nodes = null;
        if (""masters"".equals(type)){
            serverName = ""master-server"";
            nodes = runConfig.getMasters();
        }else if (""workers"".equals(type)){
            serverName = ""worker-server"";
            nodes = runConfig.getWorkers();
        }

        Map<String, String> activeNodeMap = getActiveNodesByPath(path);

        Set<String> needRestartServer = getNeedRestartServer(getRunConfigServer(nodes),
                activeNodeMap.keySet());

        for (String node : needRestartServer){
            // os.system('ssh -p ' + ssh_port + ' ' + self.get_ip_by_hostname(master) + ' sh ' + install_path + '/bin/dolphinscheduler-daemon.sh start master-server')
            String runCmd = ""ssh -p "" + port + "" "" +  node + "" sh ""  + installPath + ""/bin/dolphinscheduler-daemon.sh start "" + serverName;
            Runtime.getRuntime().exec(runCmd);
        }
    }
",1
dolphinscheduler-2.0.9,NULL_DEREFERENCE,dolphinscheduler-datasource-plugin/dolphinscheduler-datasource-api/src/main/java/org/apache/dolphinscheduler/plugin/datasource/api/datasource/mysql/MysqlDatasourceProcessor.java,org.apache.dolphinscheduler.plugin.datasource.api.datasource.mysql.MysqlDatasourceProcessor.createDatasourceParamDTO(java.lang.String):org.apache.dolphinscheduler.plugin.datasource.api.datasource.BaseDataSourceParamDTO,61,object `connectionParams` last assigned on line 58 could be null and is dereferenced at line 61.,"57: public BaseDataSourceParamDTO createDatasourceParamDTO(String connectionJson) {
 58: MysqlConnectionParam connectionParams = (MysqlConnectionParam) createConnectionParams(connectionJson);
 59: MysqlDatasourceParamDTO mysqlDatasourceParamDTO = new MysqlDatasourceParamDTO();
 60: 
 61: mysqlDatasourceParamDTO.setUserName(connectionParams.getUser());
 62: mysqlDatasourceParamDTO.setDatabase(connectionParams.getDatabase());
 63: mysqlDatasourceParamDTO.setOther(parseOther(connectionParams.getOther()));
 64: 
 65: String address = connectionParams.getAddress();
 66: String[] hostSeperator = address.split(Constants.DOUBLE_SLASH);
 67: String[] hostPortArray = hostSeperator[hostSeperator.length - 1].split(Constants.COMMA);
 68: mysqlDatasourceParamDTO.setPort(Integer.parseInt(hostPortArray[0].split(Constants.COLON)[1]));
 69: mysqlDatasourceParamDTO.setHost(hostPortArray[0].split(Constants.COLON)[0]);
 70: 
 71: return mysqlDatasourceParamDTO;","public BaseDataSourceParamDTO createDatasourceParamDTO(String connectionJson) {
        MysqlConnectionParam connectionParams = (MysqlConnectionParam) createConnectionParams(connectionJson);
        MysqlDatasourceParamDTO mysqlDatasourceParamDTO = new MysqlDatasourceParamDTO();

        mysqlDatasourceParamDTO.setUserName(connectionParams.getUser());
        mysqlDatasourceParamDTO.setDatabase(connectionParams.getDatabase());
        mysqlDatasourceParamDTO.setOther(parseOther(connectionParams.getOther()));

        String address = connectionParams.getAddress();
        String[] hostSeperator = address.split(Constants.DOUBLE_SLASH);
        String[] hostPortArray = hostSeperator[hostSeperator.length - 1].split(Constants.COMMA);
        mysqlDatasourceParamDTO.setPort(Integer.parseInt(hostPortArray[0].split(Constants.COLON)[1]));
        mysqlDatasourceParamDTO.setHost(hostPortArray[0].split(Constants.COLON)[0]);

        return mysqlDatasourceParamDTO;
    }",1
dolphinscheduler-2.0.9,NULL_DEREFERENCE,dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/master/processor/TaskRecallProcessor.java,"org.apache.dolphinscheduler.server.master.processor.TaskRecallProcessor.process(io.netty.channel.Channel,org.apache.dolphinscheduler.remote.command.Command):void",62,object `recallCommand` last assigned on line 59 could be null and is dereferenced at line 62.,"57: public void process(Channel channel, Command command) {
 58: Preconditions.checkArgument(CommandType.TASK_RECALL == command.getType(), String.format(""invalid command type : %s"", command.getType()));
 59: TaskRecallCommand recallCommand = JSONUtils.parseObject(command.getBody(), TaskRecallCommand.class);
 60: logger.info(""taskRecallCommand: {}, opaque: {}"", recallCommand, command.getOpaque());
 61: // TaskResponseEvent
 62: TaskResponseEvent taskResponseEvent = TaskResponseEvent.newRecall(ExecutionStatus.of(recallCommand.getStatus()), recallCommand.getEvent(),
 63: recallCommand.getTaskInstanceId(), recallCommand.getProcessInstanceId(), channel, command.getOpaque());
 64: taskResponseService.addResponse(taskResponseEvent);","public void process(Channel channel, Command command) {
        Preconditions.checkArgument(CommandType.TASK_RECALL == command.getType(), String.format(""invalid command type : %s"", command.getType()));
        TaskRecallCommand recallCommand = JSONUtils.parseObject(command.getBody(), TaskRecallCommand.class);
        logger.info(""taskRecallCommand: {}, opaque: {}"", recallCommand, command.getOpaque());
        // TaskResponseEvent
        TaskResponseEvent taskResponseEvent = TaskResponseEvent.newRecall(ExecutionStatus.of(recallCommand.getStatus()), recallCommand.getEvent(),
                recallCommand.getTaskInstanceId(), recallCommand.getProcessInstanceId(), channel, command.getOpaque());
        taskResponseService.addResponse(taskResponseEvent);
    }",1
dolphinscheduler-2.0.9,NULL_DEREFERENCE,dolphinscheduler-spi/src/main/java/org/apache/dolphinscheduler/spi/task/paramparser/ParamUtils.java,"org.apache.dolphinscheduler.spi.task.paramparser.ParamUtils.convert(org.apache.dolphinscheduler.spi.task.request.TaskRequest,org.apache.dolphinscheduler.spi.task.AbstractParameters):java.util.Map",109,object `globalParams` last assigned on line 60 could be null and is dereferenced at line 109.,"57: public static Map<String, Property> convert(TaskRequest taskExecutionContext, AbstractParameters parameters) {
 58: Preconditions.checkNotNull(taskExecutionContext);
 59: Preconditions.checkNotNull(parameters);
 60: Map<String, Property> globalParams = getUserDefParamsMap(taskExecutionContext.getDefinedParams());
 61: Map<String,String> globalParamsMap = taskExecutionContext.getDefinedParams();
 62: CommandType commandType = CommandType.of(taskExecutionContext.getCmdTypeIfComplement());
 63: Date scheduleTime = taskExecutionContext.getScheduleTime();
 64: 
 65: Map<String, Property> convertedParams = new HashMap<>();
 66: 
 67: // combining local and global parameters
 68: Map<String, Property> localParams = parameters.getLocalParametersMap();
 69: 
 70: Map<String, Property> varParams = parameters.getVarPoolMap();
 71: 
 72: if (MapUtils.isEmpty(globalParams) && MapUtils.isEmpty(localParams) && MapUtils.isEmpty(varParams)) {
 73: return null;
 74: }
 75: // if it is a complement,
 76: // you need to pass in the task instance id to locate the time
 77: // of the process instance complement
 78: Map<String,String> params = BusinessTimeUtils
 79: .getBusinessTime(commandType,
 80: scheduleTime);
 81: 
 82: if (MapUtils.isNotEmpty(globalParamsMap)) {
 83: params.putAll(globalParamsMap);
 84: }
 85: 
 86: if (StringUtils.isNotBlank(taskExecutionContext.getExecutePath())) {
 87: params.put(PARAMETER_TASK_EXECUTE_PATH, taskExecutionContext.getExecutePath());
 88: }
 89: params.put(PARAMETER_TASK_INSTANCE_ID, Integer.toString(taskExecutionContext.getTaskInstanceId()));
 90: 
 91: if (globalParams != null && localParams != null) {
 92: globalParams.putAll(localParams);
 93: for (Map.Entry<String, Property> entry : localParams.entrySet()) {
 94: convertedParams.put(entry.getKey(), entry.getValue());
 95: }
 96: } else if (globalParams == null && localParams != null) {
 97: globalParams = localParams;
 98: convertedParams = localParams;
 99: }
 100: if (varParams != null) {
 101: if (globalParams != null) {
 102: varParams.putAll(globalParams);
 103: }
 104: globalParams = varParams;
 105: for (Map.Entry<String, Property> entry : varParams.entrySet()) {
 106: convertedParams.put(entry.getKey(), entry.getValue());
 107: }
 108: }
 109: Iterator<Map.Entry<String, Property>> iter = globalParams.entrySet().iterator();
 110: while (iter.hasNext()) {
 111: Map.Entry<String, Property> en = iter.next();
 112: Property property = en.getValue();
 113: 
 114: if (StringUtils.isNotEmpty(property.getValue())
 115: && property.getValue().startsWith(""$"")) {
 116: /**
 117: * local parameter refers to global parameter with the same name
 118: * note: the global parameters of the process instance here are solidified parameters,
 119: * and there are no variables in them.
 120: */
 121: String val = property.getValue();
 122: 
 123: val = ParameterUtils.convertParameterPlaceholders(val, params);
 124: property.setValue(val);
 125: }
 126: 
 127: if (property.getProp().startsWith(START_UP_PARAMS_PREFIX)) {
 128: property.setProp(property.getProp().replaceFirst(START_UP_PARAMS_PREFIX, """"));
 129: convertedParams.put(property.getProp(), property);
 130: } else if (property.getProp().startsWith(GLOBAL_PARAMS_PREFIX)) {
 131: String prop = property.getProp().replaceFirst(GLOBAL_PARAMS_PREFIX, """");
 132: if (!convertedParams.containsKey(prop)) {
 133: property.setProp(prop);
 134: convertedParams.put(prop, property);
 135: }
 136: }
 137: }
 138: 
 139: return convertedParams;","public static Map<String, Property> convert(TaskRequest taskExecutionContext, AbstractParameters parameters) {
        Preconditions.checkNotNull(taskExecutionContext);
        Preconditions.checkNotNull(parameters);
        Map<String, Property> globalParams = getUserDefParamsMap(taskExecutionContext.getDefinedParams());
        Map<String,String> globalParamsMap = taskExecutionContext.getDefinedParams();
        CommandType commandType = CommandType.of(taskExecutionContext.getCmdTypeIfComplement());
        Date scheduleTime = taskExecutionContext.getScheduleTime();

        Map<String, Property> convertedParams = new HashMap<>();

        // combining local and global parameters
        Map<String, Property> localParams = parameters.getLocalParametersMap();

        Map<String, Property> varParams = parameters.getVarPoolMap();

        if (MapUtils.isEmpty(globalParams) && MapUtils.isEmpty(localParams) && MapUtils.isEmpty(varParams)) {
            return null;
        }
        // if it is a complement,
        // you need to pass in the task instance id to locate the time
        // of the process instance complement
        Map<String,String> params = BusinessTimeUtils
                .getBusinessTime(commandType,
                        scheduleTime);

        if (MapUtils.isNotEmpty(globalParamsMap)) {
            params.putAll(globalParamsMap);
        }

        if (StringUtils.isNotBlank(taskExecutionContext.getExecutePath())) {
            params.put(PARAMETER_TASK_EXECUTE_PATH, taskExecutionContext.getExecutePath());
        }
        params.put(PARAMETER_TASK_INSTANCE_ID, Integer.toString(taskExecutionContext.getTaskInstanceId()));

        if (globalParams != null && localParams != null) {
            globalParams.putAll(localParams);
            for (Map.Entry<String, Property> entry : localParams.entrySet()) {
                convertedParams.put(entry.getKey(), entry.getValue());
            }
        } else if (globalParams == null && localParams != null) {
            globalParams = localParams;
            convertedParams = localParams;
        }
        if (varParams != null) {
            if (globalParams != null) {
                varParams.putAll(globalParams);
            }
            globalParams = varParams;
            for (Map.Entry<String, Property> entry : varParams.entrySet()) {
                convertedParams.put(entry.getKey(), entry.getValue());
            }
        }
        Iterator<Map.Entry<String, Property>> iter = globalParams.entrySet().iterator();
        while (iter.hasNext()) {
            Map.Entry<String, Property> en = iter.next();
            Property property = en.getValue();

            if (StringUtils.isNotEmpty(property.getValue())
                    && property.getValue().startsWith(""$"")) {
                /**
                 *  local parameter refers to global parameter with the same name
                 *  note: the global parameters of the process instance here are solidified parameters,
                 *  and there are no variables in them.
                 */
                String val = property.getValue();

                val  = ParameterUtils.convertParameterPlaceholders(val, params);
                property.setValue(val);
            }

            if (property.getProp().startsWith(START_UP_PARAMS_PREFIX)) {
                property.setProp(property.getProp().replaceFirst(START_UP_PARAMS_PREFIX, """"));
                convertedParams.put(property.getProp(), property);
            } else if (property.getProp().startsWith(GLOBAL_PARAMS_PREFIX)) {
                String prop = property.getProp().replaceFirst(GLOBAL_PARAMS_PREFIX, """");
                if (!convertedParams.containsKey(prop)) {
                    property.setProp(prop);
                    convertedParams.put(prop, property);
                }
            }
        }

        return convertedParams;
    }
",0
dolphinscheduler-2.0.9,NULL_DEREFERENCE,dolphinscheduler-task-plugin/dolphinscheduler-task-api/src/main/java/org/apache/dolphinscheduler/plugin/task/util/OSUtils.java,org.apache.dolphinscheduler.plugin.task.util.OSUtils.isMacOS():boolean,59,object returned by `getOSName()` could be null and is dereferenced at line 59.,"58: public static boolean isMacOS() {
 59: return getOSName().startsWith(""Mac"");","public static boolean isMacOS() {
        return getOSName().startsWith(""Mac"");
    }",0
dolphinscheduler-2.0.9,NULL_DEREFERENCE,dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/master/processor/StateEventProcessor.java,"org.apache.dolphinscheduler.server.master.processor.StateEventProcessor.process(io.netty.channel.Channel,org.apache.dolphinscheduler.remote.command.Command):void",64,object `stateEventChangeCommand` last assigned on line 62 could be null and is dereferenced at line 64.,"59: public void process(Channel channel, Command command) {
 60: Preconditions.checkArgument(CommandType.STATE_EVENT_REQUEST == command.getType(), String.format(""invalid command type: %s"", command.getType()));
 61: 
 62: StateEventChangeCommand stateEventChangeCommand = JSONUtils.parseObject(command.getBody(), StateEventChangeCommand.class);
 63: StateEvent stateEvent = new StateEvent();
 64: stateEvent.setKey(stateEventChangeCommand.getKey());
 65: if (stateEventChangeCommand.getSourceProcessInstanceId() != stateEventChangeCommand.getDestProcessInstanceId()) {
 66: stateEvent.setExecutionStatus(ExecutionStatus.RUNNING_EXECUTION);
 67: } else {
 68: stateEvent.setExecutionStatus(stateEventChangeCommand.getSourceStatus());
 69: }
 70: stateEvent.setProcessInstanceId(stateEventChangeCommand.getDestProcessInstanceId());
 71: stateEvent.setTaskInstanceId(stateEventChangeCommand.getDestTaskInstanceId());
 72: StateEventType type = stateEvent.getTaskInstanceId() == 0 ? StateEventType.PROCESS_STATE_CHANGE : StateEventType.TASK_STATE_CHANGE;
 73: stateEvent.setType(type);
 74: 
 75: logger.info(""received command : {}"", stateEvent);
 76: stateEventResponseService.addResponse(stateEvent);","public void process(Channel channel, Command command) {
        Preconditions.checkArgument(CommandType.STATE_EVENT_REQUEST == command.getType(), String.format(""invalid command type: %s"", command.getType()));

        StateEventChangeCommand stateEventChangeCommand = JSONUtils.parseObject(command.getBody(), StateEventChangeCommand.class);
        StateEvent stateEvent = new StateEvent();
        stateEvent.setKey(stateEventChangeCommand.getKey());
        if (stateEventChangeCommand.getSourceProcessInstanceId() != stateEventChangeCommand.getDestProcessInstanceId()) {
            stateEvent.setExecutionStatus(ExecutionStatus.RUNNING_EXECUTION);
        } else {
            stateEvent.setExecutionStatus(stateEventChangeCommand.getSourceStatus());
        }
        stateEvent.setProcessInstanceId(stateEventChangeCommand.getDestProcessInstanceId());
        stateEvent.setTaskInstanceId(stateEventChangeCommand.getDestTaskInstanceId());
        StateEventType type = stateEvent.getTaskInstanceId() == 0 ? StateEventType.PROCESS_STATE_CHANGE : StateEventType.TASK_STATE_CHANGE;
        stateEvent.setType(type);

        logger.info(""received command : {}"", stateEvent);
        stateEventResponseService.addResponse(stateEvent);
    }",1
dolphinscheduler-2.0.9,NULL_DEREFERENCE,dolphinscheduler-task-plugin/dolphinscheduler-task-api/src/main/java/org/apache/dolphinscheduler/plugin/task/util/OSUtils.java,org.apache.dolphinscheduler.plugin.task.util.OSUtils.isWindows():boolean,68,object returned by `getOSName()` could be null and is dereferenced at line 68.,"67: public static boolean isWindows() {
 68: return getOSName().startsWith(""Windows"");","public static boolean isWindows() {
        return getOSName().startsWith(""Windows"");
    }",0
dolphinscheduler-2.0.9,NULL_DEREFERENCE,dolphinscheduler-task-plugin/dolphinscheduler-task-pigeon/src/main/java/org/apache/dolphinscheduler/plugin/task/pigeon/PigeonTask.java,org.apache.dolphinscheduler.plugin.task.pigeon.PigeonTask.init():void,71,object `PigeonTask.parameters` last assigned on line 70 could be null and is dereferenced at line 71.,"67: public void init() {
 68: super.init();
 69: logger.info(""PIGEON task params {}"", taskExecutionContext.getTaskParams());
 70: parameters = JSONUtils.parseObject(taskExecutionContext.getTaskParams(), PigeonParameters.class);
 71: if (!parameters.checkParameters()) {","public void init() {
        super.init();
        logger.info(""PIGEON task params {}"", taskExecutionContext.getTaskParams());
        parameters = JSONUtils.parseObject(taskExecutionContext.getTaskParams(), PigeonParameters.class);
        if (!parameters.checkParameters()) {
            throw new RuntimeException(""datax task params is not valid"");
        }
    }",0
dolphinscheduler-2.0.9,NULL_DEREFERENCE,dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/log/LoggerRequestProcessor.java,"org.apache.dolphinscheduler.server.log.LoggerRequestProcessor.process(io.netty.channel.Channel,org.apache.dolphinscheduler.remote.command.Command):void",79,object `getLogRequest` last assigned on line 77 could be null and is dereferenced at line 79.,https://github.com/apache/dolphinscheduler/blob/2.0.9-release/dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/log/LoggerRequestProcessor.java,"public void process(Channel channel, Command command) {
        logger.info(""received command : {}"", command);

        /**
         * reuqest task log command type
         */
        final CommandType commandType = command.getType();
        switch (commandType) {
            case GET_LOG_BYTES_REQUEST:
                GetLogBytesRequestCommand getLogRequest = JSONUtils.parseObject(
                        command.getBody(), GetLogBytesRequestCommand.class);
                String path = getLogRequest.getPath();
                if (!checkPathSecurity(path)) {
                    throw new IllegalArgumentException(""Illegal path"");
                }
                byte[] bytes = getFileContentBytes(path);
                GetLogBytesResponseCommand getLogResponse = new GetLogBytesResponseCommand(bytes);
                channel.writeAndFlush(getLogResponse.convert2Command(command.getOpaque()));
                break;
            case VIEW_WHOLE_LOG_REQUEST:
                ViewLogRequestCommand viewLogRequest = JSONUtils.parseObject(
                        command.getBody(), ViewLogRequestCommand.class);
                String viewLogPath = viewLogRequest.getPath();
                if (!checkPathSecurity(viewLogPath)) {
                    throw new IllegalArgumentException(""Illegal path"");
                }
                String msg = LoggerUtils.readWholeFileContent(viewLogPath);
                ViewLogResponseCommand viewLogResponse = new ViewLogResponseCommand(msg);
                channel.writeAndFlush(viewLogResponse.convert2Command(command.getOpaque()));
                break;
            case ROLL_VIEW_LOG_REQUEST:
                RollViewLogRequestCommand rollViewLogRequest = JSONUtils.parseObject(
                        command.getBody(), RollViewLogRequestCommand.class);

                String rollViewLogPath = rollViewLogRequest.getPath();
                if (!checkPathSecurity(rollViewLogPath)) {
                    throw new IllegalArgumentException(""Illegal path"");
                }

                List<String> lines = readPartFileContent(rollViewLogPath,
                        rollViewLogRequest.getSkipLineNum(), rollViewLogRequest.getLimit());
                StringBuilder builder = new StringBuilder();
                for (String line : lines) {
                    builder.append(line + ""\r\n"");
                }
                RollViewLogResponseCommand rollViewLogRequestResponse = new RollViewLogResponseCommand(builder.toString());
                channel.writeAndFlush(rollViewLogRequestResponse.convert2Command(command.getOpaque()));
                break;
            case REMOVE_TAK_LOG_REQUEST:
                RemoveTaskLogRequestCommand removeTaskLogRequest = JSONUtils.parseObject(
                        command.getBody(), RemoveTaskLogRequestCommand.class);

                String taskLogPath = removeTaskLogRequest.getPath();
                if (!checkPathSecurity(taskLogPath)) {
                    throw new IllegalArgumentException(""Illegal path"");
                }
                File taskLogFile = new File(taskLogPath);
                Boolean status = true;
                try {
                    if (taskLogFile.exists()) {
                        status = taskLogFile.delete();
                    }
                }
                catch (Exception e) {
                    status = false;
                }

                RemoveTaskLogResponseCommand removeTaskLogResponse = new RemoveTaskLogResponseCommand(status);
                channel.writeAndFlush(removeTaskLogResponse.convert2Command(command.getOpaque()));
                break;
            default:
                throw new IllegalArgumentException(""unknown commandType"");
        }
    }
",1
dolphinscheduler-2.0.9,NULL_DEREFERENCE,dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/log/LoggerRequestProcessor.java,"org.apache.dolphinscheduler.server.log.LoggerRequestProcessor.process(io.netty.channel.Channel,org.apache.dolphinscheduler.remote.command.Command):void",120,object `removeTaskLogRequest` last assigned on line 117 could be null and is dereferenced at line 120.,https://github.com/apache/dolphinscheduler/blob/2.0.9-release/dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/log/LoggerRequestProcessor.java,"public void process(Channel channel, Command command) {
        logger.info(""received command : {}"", command);

        /**
         * reuqest task log command type
         */
        final CommandType commandType = command.getType();
        switch (commandType) {
            case GET_LOG_BYTES_REQUEST:
                GetLogBytesRequestCommand getLogRequest = JSONUtils.parseObject(
                        command.getBody(), GetLogBytesRequestCommand.class);
                String path = getLogRequest.getPath();
                if (!checkPathSecurity(path)) {
                    throw new IllegalArgumentException(""Illegal path"");
                }
                byte[] bytes = getFileContentBytes(path);
                GetLogBytesResponseCommand getLogResponse = new GetLogBytesResponseCommand(bytes);
                channel.writeAndFlush(getLogResponse.convert2Command(command.getOpaque()));
                break;
            case VIEW_WHOLE_LOG_REQUEST:
                ViewLogRequestCommand viewLogRequest = JSONUtils.parseObject(
                        command.getBody(), ViewLogRequestCommand.class);
                String viewLogPath = viewLogRequest.getPath();
                if (!checkPathSecurity(viewLogPath)) {
                    throw new IllegalArgumentException(""Illegal path"");
                }
                String msg = LoggerUtils.readWholeFileContent(viewLogPath);
                ViewLogResponseCommand viewLogResponse = new ViewLogResponseCommand(msg);
                channel.writeAndFlush(viewLogResponse.convert2Command(command.getOpaque()));
                break;
            case ROLL_VIEW_LOG_REQUEST:
                RollViewLogRequestCommand rollViewLogRequest = JSONUtils.parseObject(
                        command.getBody(), RollViewLogRequestCommand.class);

                String rollViewLogPath = rollViewLogRequest.getPath();
                if (!checkPathSecurity(rollViewLogPath)) {
                    throw new IllegalArgumentException(""Illegal path"");
                }

                List<String> lines = readPartFileContent(rollViewLogPath,
                        rollViewLogRequest.getSkipLineNum(), rollViewLogRequest.getLimit());
                StringBuilder builder = new StringBuilder();
                for (String line : lines) {
                    builder.append(line + ""\r\n"");
                }
                RollViewLogResponseCommand rollViewLogRequestResponse = new RollViewLogResponseCommand(builder.toString());
                channel.writeAndFlush(rollViewLogRequestResponse.convert2Command(command.getOpaque()));
                break;
            case REMOVE_TAK_LOG_REQUEST:
                RemoveTaskLogRequestCommand removeTaskLogRequest = JSONUtils.parseObject(
                        command.getBody(), RemoveTaskLogRequestCommand.class);

                String taskLogPath = removeTaskLogRequest.getPath();
                if (!checkPathSecurity(taskLogPath)) {
                    throw new IllegalArgumentException(""Illegal path"");
                }
                File taskLogFile = new File(taskLogPath);
                Boolean status = true;
                try {
                    if (taskLogFile.exists()) {
                        status = taskLogFile.delete();
                    }
                }
                catch (Exception e) {
                    status = false;
                }

                RemoveTaskLogResponseCommand removeTaskLogResponse = new RemoveTaskLogResponseCommand(status);
                channel.writeAndFlush(removeTaskLogResponse.convert2Command(command.getOpaque()));
                break;
            default:
                throw new IllegalArgumentException(""unknown commandType"");
        }
    }
",1
dolphinscheduler-2.0.9,NULL_DEREFERENCE,dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/log/LoggerRequestProcessor.java,"org.apache.dolphinscheduler.server.log.LoggerRequestProcessor.process(io.netty.channel.Channel,org.apache.dolphinscheduler.remote.command.Command):void",102,object `rollViewLogRequest` last assigned on line 99 could be null and is dereferenced at line 102.,https://github.com/apache/dolphinscheduler/blob/2.0.9-release/dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/log/LoggerRequestProcessor.java,"public void process(Channel channel, Command command) {
        logger.info(""received command : {}"", command);

        /**
         * reuqest task log command type
         */
        final CommandType commandType = command.getType();
        switch (commandType) {
            case GET_LOG_BYTES_REQUEST:
                GetLogBytesRequestCommand getLogRequest = JSONUtils.parseObject(
                        command.getBody(), GetLogBytesRequestCommand.class);
                String path = getLogRequest.getPath();
                if (!checkPathSecurity(path)) {
                    throw new IllegalArgumentException(""Illegal path"");
                }
                byte[] bytes = getFileContentBytes(path);
                GetLogBytesResponseCommand getLogResponse = new GetLogBytesResponseCommand(bytes);
                channel.writeAndFlush(getLogResponse.convert2Command(command.getOpaque()));
                break;
            case VIEW_WHOLE_LOG_REQUEST:
                ViewLogRequestCommand viewLogRequest = JSONUtils.parseObject(
                        command.getBody(), ViewLogRequestCommand.class);
                String viewLogPath = viewLogRequest.getPath();
                if (!checkPathSecurity(viewLogPath)) {
                    throw new IllegalArgumentException(""Illegal path"");
                }
                String msg = LoggerUtils.readWholeFileContent(viewLogPath);
                ViewLogResponseCommand viewLogResponse = new ViewLogResponseCommand(msg);
                channel.writeAndFlush(viewLogResponse.convert2Command(command.getOpaque()));
                break;
            case ROLL_VIEW_LOG_REQUEST:
                RollViewLogRequestCommand rollViewLogRequest = JSONUtils.parseObject(
                        command.getBody(), RollViewLogRequestCommand.class);

                String rollViewLogPath = rollViewLogRequest.getPath();
                if (!checkPathSecurity(rollViewLogPath)) {
                    throw new IllegalArgumentException(""Illegal path"");
                }

                List<String> lines = readPartFileContent(rollViewLogPath,
                        rollViewLogRequest.getSkipLineNum(), rollViewLogRequest.getLimit());
                StringBuilder builder = new StringBuilder();
                for (String line : lines) {
                    builder.append(line + ""\r\n"");
                }
                RollViewLogResponseCommand rollViewLogRequestResponse = new RollViewLogResponseCommand(builder.toString());
                channel.writeAndFlush(rollViewLogRequestResponse.convert2Command(command.getOpaque()));
                break;
            case REMOVE_TAK_LOG_REQUEST:
                RemoveTaskLogRequestCommand removeTaskLogRequest = JSONUtils.parseObject(
                        command.getBody(), RemoveTaskLogRequestCommand.class);

                String taskLogPath = removeTaskLogRequest.getPath();
                if (!checkPathSecurity(taskLogPath)) {
                    throw new IllegalArgumentException(""Illegal path"");
                }
                File taskLogFile = new File(taskLogPath);
                Boolean status = true;
                try {
                    if (taskLogFile.exists()) {
                        status = taskLogFile.delete();
                    }
                }
                catch (Exception e) {
                    status = false;
                }

                RemoveTaskLogResponseCommand removeTaskLogResponse = new RemoveTaskLogResponseCommand(status);
                channel.writeAndFlush(removeTaskLogResponse.convert2Command(command.getOpaque()));
                break;
            default:
                throw new IllegalArgumentException(""unknown commandType"");
        }
    }
",1
dolphinscheduler-2.0.9,NULL_DEREFERENCE,dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/log/LoggerRequestProcessor.java,"org.apache.dolphinscheduler.server.log.LoggerRequestProcessor.process(io.netty.channel.Channel,org.apache.dolphinscheduler.remote.command.Command):void",90,object `viewLogRequest` last assigned on line 88 could be null and is dereferenced at line 90.,https://github.com/apache/dolphinscheduler/blob/2.0.9-release/dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/log/LoggerRequestProcessor.java,"public void process(Channel channel, Command command) {
        logger.info(""received command : {}"", command);

        /**
         * reuqest task log command type
         */
        final CommandType commandType = command.getType();
        switch (commandType) {
            case GET_LOG_BYTES_REQUEST:
                GetLogBytesRequestCommand getLogRequest = JSONUtils.parseObject(
                        command.getBody(), GetLogBytesRequestCommand.class);
                String path = getLogRequest.getPath();
                if (!checkPathSecurity(path)) {
                    throw new IllegalArgumentException(""Illegal path"");
                }
                byte[] bytes = getFileContentBytes(path);
                GetLogBytesResponseCommand getLogResponse = new GetLogBytesResponseCommand(bytes);
                channel.writeAndFlush(getLogResponse.convert2Command(command.getOpaque()));
                break;
            case VIEW_WHOLE_LOG_REQUEST:
                ViewLogRequestCommand viewLogRequest = JSONUtils.parseObject(
                        command.getBody(), ViewLogRequestCommand.class);
                String viewLogPath = viewLogRequest.getPath();
                if (!checkPathSecurity(viewLogPath)) {
                    throw new IllegalArgumentException(""Illegal path"");
                }
                String msg = LoggerUtils.readWholeFileContent(viewLogPath);
                ViewLogResponseCommand viewLogResponse = new ViewLogResponseCommand(msg);
                channel.writeAndFlush(viewLogResponse.convert2Command(command.getOpaque()));
                break;
            case ROLL_VIEW_LOG_REQUEST:
                RollViewLogRequestCommand rollViewLogRequest = JSONUtils.parseObject(
                        command.getBody(), RollViewLogRequestCommand.class);

                String rollViewLogPath = rollViewLogRequest.getPath();
                if (!checkPathSecurity(rollViewLogPath)) {
                    throw new IllegalArgumentException(""Illegal path"");
                }

                List<String> lines = readPartFileContent(rollViewLogPath,
                        rollViewLogRequest.getSkipLineNum(), rollViewLogRequest.getLimit());
                StringBuilder builder = new StringBuilder();
                for (String line : lines) {
                    builder.append(line + ""\r\n"");
                }
                RollViewLogResponseCommand rollViewLogRequestResponse = new RollViewLogResponseCommand(builder.toString());
                channel.writeAndFlush(rollViewLogRequestResponse.convert2Command(command.getOpaque()));
                break;
            case REMOVE_TAK_LOG_REQUEST:
                RemoveTaskLogRequestCommand removeTaskLogRequest = JSONUtils.parseObject(
                        command.getBody(), RemoveTaskLogRequestCommand.class);

                String taskLogPath = removeTaskLogRequest.getPath();
                if (!checkPathSecurity(taskLogPath)) {
                    throw new IllegalArgumentException(""Illegal path"");
                }
                File taskLogFile = new File(taskLogPath);
                Boolean status = true;
                try {
                    if (taskLogFile.exists()) {
                        status = taskLogFile.delete();
                    }
                }
                catch (Exception e) {
                    status = false;
                }

                RemoveTaskLogResponseCommand removeTaskLogResponse = new RemoveTaskLogResponseCommand(status);
                channel.writeAndFlush(removeTaskLogResponse.convert2Command(command.getOpaque()));
                break;
            default:
                throw new IllegalArgumentException(""unknown commandType"");
        }
    }
",1
dolphinscheduler-2.0.9,NULL_DEREFERENCE,dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/master/processor/TaskAckProcessor.java,"org.apache.dolphinscheduler.server.master.processor.TaskAckProcessor.process(io.netty.channel.Channel,org.apache.dolphinscheduler.remote.command.Command):void",75,object `taskAckCommand` last assigned on line 70 could be null and is dereferenced at line 75.,"68: public void process(Channel channel, Command command) {
 69: Preconditions.checkArgument(CommandType.TASK_EXECUTE_ACK == command.getType(), String.format(""invalid command type : %s"", command.getType()));
 70: TaskExecuteAckCommand taskAckCommand = JSONUtils.parseObject(command.getBody(), TaskExecuteAckCommand.class);
 71: logger.info(""taskAckCommand : {}"", taskAckCommand);
 72: 
 73: String workerAddress = ChannelUtils.toAddress(channel).getAddress();
 74: 
 75: ExecutionStatus ackStatus = ExecutionStatus.of(taskAckCommand.getStatus());
 76: 
 77: // TaskResponseEvent
 78: TaskResponseEvent taskResponseEvent = TaskResponseEvent.newAck(ackStatus,
 79: taskAckCommand.getStartTime(),
 80: workerAddress,
 81: taskAckCommand.getExecutePath(),
 82: taskAckCommand.getLogPath(),
 83: taskAckCommand.getTaskInstanceId(),
 84: channel,
 85: taskAckCommand.getProcessInstanceId());
 86: 
 87: taskResponseService.addResponse(taskResponseEvent);","public void process(Channel channel, Command command) {
        Preconditions.checkArgument(CommandType.TASK_EXECUTE_ACK == command.getType(), String.format(""invalid command type : %s"", command.getType()));
        TaskExecuteAckCommand taskAckCommand = JSONUtils.parseObject(command.getBody(), TaskExecuteAckCommand.class);
        logger.info(""taskAckCommand : {}"", taskAckCommand);

        String workerAddress = ChannelUtils.toAddress(channel).getAddress();

        ExecutionStatus ackStatus = ExecutionStatus.of(taskAckCommand.getStatus());

        // TaskResponseEvent
        TaskResponseEvent taskResponseEvent = TaskResponseEvent.newAck(ackStatus,
                taskAckCommand.getStartTime(),
                workerAddress,
                taskAckCommand.getExecutePath(),
                taskAckCommand.getLogPath(),
                taskAckCommand.getTaskInstanceId(),
                channel,
                taskAckCommand.getProcessInstanceId());

        taskResponseService.addResponse(taskResponseEvent);
    }
",1
dolphinscheduler-2.0.9,NULL_DEREFERENCE,dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/master/processor/TaskKillResponseProcessor.java,"org.apache.dolphinscheduler.server.master.processor.TaskKillResponseProcessor.process(io.netty.channel.Channel,org.apache.dolphinscheduler.remote.command.Command):void",74,object `responseCommand` last assigned on line 71 could be null and is dereferenced at line 74.,"68: public void process(Channel channel, Command command) {
 69: Preconditions.checkArgument(CommandType.TASK_KILL_RESPONSE == command.getType(), String.format(""invalid command type : %s"", command.getType()));
 70: 
 71: TaskKillResponseCommand responseCommand = JSONUtils.parseObject(command.getBody(), TaskKillResponseCommand.class);
 72: logger.info(""received task kill response command : {}"", responseCommand);
 73: // TaskResponseEvent
 74: TaskResponseEvent taskResponseEvent = TaskResponseEvent.newKillResponse(ExecutionStatus.of(responseCommand.getStatus()),
 75: responseCommand.getTaskInstanceId(), channel, responseCommand.getProcessInstanceId());
 76: taskResponseService.addResponse(taskResponseEvent);","public void process(Channel channel, Command command) {
        Preconditions.checkArgument(CommandType.TASK_KILL_RESPONSE == command.getType(), String.format(""invalid command type : %s"", command.getType()));

        TaskKillResponseCommand responseCommand = JSONUtils.parseObject(command.getBody(), TaskKillResponseCommand.class);
        logger.info(""received task kill response command : {}"", responseCommand);
        // TaskResponseEvent
        TaskResponseEvent taskResponseEvent = TaskResponseEvent.newKillResponse(ExecutionStatus.of(responseCommand.getStatus()),
            responseCommand.getTaskInstanceId(), channel, responseCommand.getProcessInstanceId());
        taskResponseService.addResponse(taskResponseEvent);
    }",1
dolphinscheduler-2.0.9,NULL_DEREFERENCE,dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/master/processor/TaskResponseProcessor.java,"org.apache.dolphinscheduler.server.master.processor.TaskResponseProcessor.process(io.netty.channel.Channel,org.apache.dolphinscheduler.remote.command.Command):void",75,object `responseCommand` last assigned on line 71 could be null and is dereferenced at line 75.,"68: public void process(Channel channel, Command command) {
 69: Preconditions.checkArgument(CommandType.TASK_EXECUTE_RESPONSE == command.getType(), String.format(""invalid command type : %s"", command.getType()));
 70: 
 71: TaskExecuteResponseCommand responseCommand = JSONUtils.parseObject(command.getBody(), TaskExecuteResponseCommand.class);
 72: logger.info(""received command : {}"", responseCommand);
 73: 
 74: // TaskResponseEvent
 75: TaskResponseEvent taskResponseEvent = TaskResponseEvent.newResult(ExecutionStatus.of(responseCommand.getStatus()),
 76: responseCommand.getEndTime(),
 77: responseCommand.getProcessId(),
 78: responseCommand.getAppIds(),
 79: responseCommand.getTaskInstanceId(),
 80: responseCommand.getVarPool(),
 81: channel,
 82: responseCommand.getProcessInstanceId()
 83: );
 84: taskResponseService.addResponse(taskResponseEvent);","public void process(Channel channel, Command command) {
        Preconditions.checkArgument(CommandType.TASK_EXECUTE_RESPONSE == command.getType(), String.format(""invalid command type : %s"", command.getType()));

        TaskExecuteResponseCommand responseCommand = JSONUtils.parseObject(command.getBody(), TaskExecuteResponseCommand.class);
        logger.info(""received command : {}"", responseCommand);

        // TaskResponseEvent
        TaskResponseEvent taskResponseEvent = TaskResponseEvent.newResult(ExecutionStatus.of(responseCommand.getStatus()),
                responseCommand.getEndTime(),
                responseCommand.getProcessId(),
                responseCommand.getAppIds(),
                responseCommand.getTaskInstanceId(),
                responseCommand.getVarPool(),
                channel,
                responseCommand.getProcessInstanceId()
        );
        taskResponseService.addResponse(taskResponseEvent);
    }",1
dolphinscheduler-2.0.9,NULL_DEREFERENCE,dolphinscheduler-task-plugin/dolphinscheduler-task-procedure/src/main/java/org/apache/dolphinscheduler/plugin/task/procedure/ProcedureTask.java,org.apache.dolphinscheduler.plugin.task.procedure.ProcedureTask.<init>(org.apache.dolphinscheduler.spi.task.request.TaskRequest),78,object `ProcedureTask.procedureParameters` last assigned on line 75 could be null and is dereferenced at line 78.,https://github.com/apache/dolphinscheduler/blob/2.0.9-release/dolphinscheduler-task-plugin/dolphinscheduler-task-procedure/src/main/java/org/apache/dolphinscheduler/plugin/task/procedure/ProcedureTask.java,"public ProcedureTask(TaskRequest taskExecutionContext) {
        super(taskExecutionContext);

        this.taskExecutionContext = taskExecutionContext;

        logger.info(""procedure task params {}"", taskExecutionContext.getTaskParams());

        this.procedureParameters = JSONUtils.parseObject(taskExecutionContext.getTaskParams(), ProcedureParameters.class);

        // check parameters
        if (!procedureParameters.checkParameters()) {
            throw new RuntimeException(""procedure task params is not valid"");
        }
    }",1
dolphinscheduler-2.0.9,NULL_DEREFERENCE,dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/controller/BaseController.java,org.apache.dolphinscheduler.api.controller.BaseController.getClientIpAddress(org.springframework.mock.web.MockHttpServletRequest):java.lang.String,74,object `clientIp` last assigned on line 72 could be null and is dereferenced at line 74.,"71: public static String getClientIpAddress(HttpServletRequest request) {
 72: String clientIp = request.getHeader(HTTP_X_FORWARDED_FOR);
 73: 
 74: if (StringUtils.isNotEmpty(clientIp) && !clientIp.equalsIgnoreCase(HTTP_HEADER_UNKNOWN)) {
 75: int index = clientIp.indexOf(COMMA);
 76: if (index != -1) {
 77: return clientIp.substring(0, index);
 78: } else {
 79: return clientIp;
 80: }
 81: }
 82: 
 83: clientIp = request.getHeader(HTTP_X_REAL_IP);
 84: if (StringUtils.isNotEmpty(clientIp) && !clientIp.equalsIgnoreCase(HTTP_HEADER_UNKNOWN)) {
 85: return clientIp;
 86: }
 87: 
 88: return request.getRemoteAddr();","public static String getClientIpAddress(HttpServletRequest request) {
        String clientIp = request.getHeader(HTTP_X_FORWARDED_FOR);

        if (StringUtils.isNotEmpty(clientIp) && !clientIp.equalsIgnoreCase(HTTP_HEADER_UNKNOWN)) {
            int index = clientIp.indexOf(COMMA);
            if (index != -1) {
                return clientIp.substring(0, index);
            } else {
                return clientIp;
            }
        }",0
dolphinscheduler-2.0.9,NULL_DEREFERENCE,dolphinscheduler-task-plugin/dolphinscheduler-task-python/src/main/java/org/apache/dolphinscheduler/plugin/task/python/PythonTask.java,org.apache.dolphinscheduler.plugin.task.python.PythonTask.init():void,80,object `PythonTask.pythonParameters` last assigned on line 78 could be null and is dereferenced at line 80.,"75: public void init() {
 76: logger.info(""python task params {}"", taskRequest.getTaskParams());
 77: 
 78: pythonParameters = JSONUtils.parseObject(taskRequest.getTaskParams(), PythonParameters.class);
 79: 
 80: if (!pythonParameters.checkParameters()) {","public void init() {
        logger.info(""python task params {}"", taskRequest.getTaskParams());

        pythonParameters = JSONUtils.parseObject(taskRequest.getTaskParams(), PythonParameters.class);

        if (!pythonParameters.checkParameters()) {
            throw new TaskException(""python task params is not valid"");
        }
    }
",1
dolphinscheduler-2.0.9,NULL_DEREFERENCE,dolphinscheduler-spi/src/main/java/org/apache/dolphinscheduler/spi/params/PluginParamsTransfer.java,"org.apache.dolphinscheduler.spi.params.PluginParamsTransfer.generatePluginParams(java.util.Map,java.lang.String):java.util.List",81,object `pluginParamsList` last assigned on line 80 could be null and is dereferenced at line 81.,"76: public static List<Map<String, Object>> generatePluginParams(Map<String, Object> paramsMap, String pluginParamsTemplate) {
 77: if (paramsMap == null || paramsMap.isEmpty()) {
 78: return null;
 79: }
 80: List<Map<String, Object>> pluginParamsList = JSONUtils.parseObject(pluginParamsTemplate, new TypeReference<List<Map<String, Object>>>() {});
 81: pluginParamsList.forEach(pluginParams -> pluginParams.put(STRING_PLUGIN_PARAM_VALUE, paramsMap.get(pluginParams.get(STRING_PLUGIN_PARAM_FIELD))));
 82: return pluginParamsList;","public static List<Map<String, Object>> generatePluginParams(Map<String, Object> paramsMap, String pluginParamsTemplate) {
        if (paramsMap == null || paramsMap.isEmpty()) {
            return null;
        }
        List<Map<String, Object>> pluginParamsList = JSONUtils.parseObject(pluginParamsTemplate, new TypeReference<List<Map<String, Object>>>() {});
        pluginParamsList.forEach(pluginParams -> pluginParams.put(STRING_PLUGIN_PARAM_VALUE, paramsMap.get(pluginParams.get(STRING_PLUGIN_PARAM_FIELD))));
        return pluginParamsList;
    }",1
dolphinscheduler-2.0.9,NULL_DEREFERENCE,dolphinscheduler-task-plugin/dolphinscheduler-task-http/src/main/java/org/apache/dolphinscheduler/plugin/task/http/HttpTask.java,org.apache.dolphinscheduler.plugin.task.http.HttpTask.init():void,86,object `HttpTask.httpParameters` last assigned on line 84 could be null and is dereferenced at line 86.,"82: public void init() {
 83: logger.info(""http task params {}"", taskExecutionContext.getTaskParams());
 84: this.httpParameters = JSONUtils.parseObject(taskExecutionContext.getTaskParams(), HttpParameters.class);
 85: 
 86: if (!httpParameters.checkParameters()) {","public void init() {
        logger.info(""http task params {}"", taskExecutionContext.getTaskParams());
        this.httpParameters = JSONUtils.parseObject(taskExecutionContext.getTaskParams(), HttpParameters.class);

        if (!httpParameters.checkParameters()) {
            throw new RuntimeException(""http task params is not valid"");
        }
    }",1
dolphinscheduler-2.0.9,NULL_DEREFERENCE,dolphinscheduler-task-plugin/dolphinscheduler-task-shell/src/main/java/org/apache/dolphinscheduler/plugin/task/shell/ShellTask.java,org.apache.dolphinscheduler.plugin.task.shell.ShellTask.init():void,87,object `ShellTask.shellParameters` last assigned on line 85 could be null and is dereferenced at line 87.,"82: public void init() {
 83: logger.info(""shell task params {}"", taskExecutionContext.getTaskParams());
 84: 
 85: shellParameters = JSONUtils.parseObject(taskExecutionContext.getTaskParams(), ShellParameters.class);
 86: 
 87: if (!shellParameters.checkParameters()) {","public void init() {
        logger.info(""shell task params {}"", taskExecutionContext.getTaskParams());

        shellParameters = JSONUtils.parseObject(taskExecutionContext.getTaskParams(), ShellParameters.class);

        if (!shellParameters.checkParameters()) {
            throw new RuntimeException(""shell task params is not valid"");
        }
    }",1
dolphinscheduler-2.0.9,NULL_DEREFERENCE,dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/worker/processor/TaskExecuteProcessor.java,org.apache.dolphinscheduler.server.worker.processor.TaskExecuteProcessor.setTaskCache(org.apache.dolphinscheduler.service.queue.entity.TaskExecutionContext):void,92,object `taskRequest` last assigned on line 91 could be null and is dereferenced by call to `cacheTaskExecutionContext(...)` at line 92.,"90: private void setTaskCache(TaskExecutionContext taskExecutionContext) {
 91: TaskRequest taskRequest = JSONUtils.parseObject(JSONUtils.toJsonString(taskExecutionContext), TaskRequest.class);
 92: TaskExecutionContextCacheManager.cacheTaskExecutionContext(taskRequest);","private void setTaskCache(TaskExecutionContext taskExecutionContext) {
        TaskRequest taskRequest = JSONUtils.parseObject(JSONUtils.toJsonString(taskExecutionContext), TaskRequest.class);
        TaskExecutionContextCacheManager.cacheTaskExecutionContext(taskRequest);
    }
",1
dolphinscheduler-2.0.9,NULL_DEREFERENCE,dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/worker/processor/TaskKillProcessor.java,"org.apache.dolphinscheduler.server.worker.processor.TaskKillProcessor.process(io.netty.channel.Channel,org.apache.dolphinscheduler.remote.command.Command):void",98,object `killCommand` last assigned on line 95 could be null and is dereferenced at line 98.,"93: public void process(Channel channel, Command command) {
 94: Preconditions.checkArgument(CommandType.TASK_KILL_REQUEST == command.getType(), String.format(""invalid command type : %s"", command.getType()));
 95: TaskKillRequestCommand killCommand = JSONUtils.parseObject(command.getBody(), TaskKillRequestCommand.class);
 96: logger.info(""received kill command : {}"", killCommand);
 97: 
 98: TaskRequest taskRequest = TaskExecutionContextCacheManager.getByTaskInstanceId(killCommand.getTaskInstanceId());
 99: if (taskRequest == null) {
 100: logger.warn(""Cannot find taskInstanceId {} in taskContextCacheManager"", killCommand.getTaskInstanceId());
 101: return;
 102: }
 103: taskRequest.setCurrentExecutionStatus(org.apache.dolphinscheduler.spi.task.ExecutionStatus.STOP);
 104: TaskExecutionContextCacheManager.updateTaskExecutionContext(taskRequest);
 105: 
 106: taskCallbackService.addRemoteChannel(killCommand.getTaskInstanceId(), new NettyRemoteChannel(channel, command.getOpaque()));
 107: 
 108: Pair<Boolean, List<String>> result = doKill(killCommand);
 109: 
 110: TaskKillResponseCommand taskKillResponseCommand = buildKillTaskResponseCommand(taskRequest, result);
 111: ResponceCache.get().cache(taskKillResponseCommand.getTaskInstanceId(), taskKillResponseCommand.convert2Command(), Event.ACTION_STOP);
 112: taskCallbackService.sendResult(taskKillResponseCommand.getTaskInstanceId(), taskKillResponseCommand.convert2Command());","public void process(Channel channel, Command command) {
        Preconditions.checkArgument(CommandType.TASK_KILL_REQUEST == command.getType(), String.format(""invalid command type : %s"", command.getType()));
        TaskKillRequestCommand killCommand = JSONUtils.parseObject(command.getBody(), TaskKillRequestCommand.class);
        logger.info(""received kill command : {}"", killCommand);

        TaskRequest taskRequest = TaskExecutionContextCacheManager.getByTaskInstanceId(killCommand.getTaskInstanceId());
        if (taskRequest == null) {
            logger.warn(""Cannot find taskInstanceId {} in taskContextCacheManager"", killCommand.getTaskInstanceId());
            return;
        }
        taskRequest.setCurrentExecutionStatus(org.apache.dolphinscheduler.spi.task.ExecutionStatus.STOP);
        TaskExecutionContextCacheManager.updateTaskExecutionContext(taskRequest);

        taskCallbackService.addRemoteChannel(killCommand.getTaskInstanceId(), new NettyRemoteChannel(channel, command.getOpaque()));

        Pair<Boolean, List<String>> result = doKill(killCommand);

        TaskKillResponseCommand taskKillResponseCommand = buildKillTaskResponseCommand(taskRequest, result);
        ResponceCache.get().cache(taskKillResponseCommand.getTaskInstanceId(), taskKillResponseCommand.convert2Command(), Event.ACTION_STOP);
        taskCallbackService.sendResult(taskKillResponseCommand.getTaskInstanceId(), taskKillResponseCommand.convert2Command());
    }",1
dolphinscheduler-2.0.9,NULL_DEREFERENCE,dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/controller/BaseController.java,org.apache.dolphinscheduler.api.controller.BaseController.returnDataList(java.util.HashMap):org.apache.dolphinscheduler.api.utils.Result,104,object `status` last assigned on line 98 could be null and is dereferenced at line 104.,https://github.com/apache/dolphinscheduler/blob/2.0.9-release/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/controller/BaseController.java,"public Result returnDataList(Map<String, Object> result) {
        Status status = (Status) result.get(Constants.STATUS);
        if (status == Status.SUCCESS) {
            String msg = Status.SUCCESS.getMsg();
            Object datalist = result.get(Constants.DATA_LIST);
            return success(msg, datalist);
        } else {
            Integer code = status.getCode();
            String msg = (String) result.get(Constants.MSG);
            return error(code, msg);
        }
    }",0
dolphinscheduler-2.0.9,NULL_DEREFERENCE,dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/worker/processor/TaskKillProcessor.java,org.apache.dolphinscheduler.server.worker.processor.TaskKillProcessor.doKill(org.apache.dolphinscheduler.remote.command.TaskKillRequestCommand):org.apache.dolphinscheduler.remote.utils.Pair,127,object `taskExecutionContext` last assigned on line 125 could be null and is dereferenced at line 127.,"120: private Pair<Boolean, List<String>> doKill(TaskKillRequestCommand killCommand) {
 121: boolean processFlag = true;
 122: List<String> appIds = Collections.emptyList();
 123: int taskInstanceId = killCommand.getTaskInstanceId();
 124: TaskRequest taskRequest = TaskExecutionContextCacheManager.getByTaskInstanceId(taskInstanceId);
 125: TaskExecutionContext taskExecutionContext = JSONUtils.parseObject(JSONUtils.toJsonString(taskRequest), TaskExecutionContext.class);
 126: try {
 127: Integer processId = taskExecutionContext.getProcessId();
 128: if (processId.equals(0)) {
 129: TaskExecuteThread taskExecuteThread = workerManager.getTaskExecuteThread(taskInstanceId);
 130: if (null != taskExecuteThread) {
 131: AbstractTask task = taskExecuteThread.getTask();
 132: if (task != null) {
 133: task.cancelApplication(true);
 134: logger.info(""kill task by cancelApplication, task id:{}"", taskInstanceId);
 135: }
 136: }
 137: workerManager.killTaskBeforeExecuteByInstanceId(taskInstanceId);
 138: TaskExecutionContextCacheManager.removeByTaskInstanceId(taskInstanceId);
 139: logger.info(""the task has not been executed and has been cancelled, task id:{}"", taskInstanceId);
 140: return Pair.of(true, appIds);
 141: }
 142: 
 143: String pidsStr = ProcessUtils.getPidsStr(taskExecutionContext.getProcessId());
 144: if (!StringUtils.isEmpty(pidsStr)) {
 145: String cmd = String.format(""kill -9 %s"", pidsStr);
 146: cmd = OSUtils.getSudoCmd(taskExecutionContext.getTenantCode(), cmd);
 147: logger.info(""process id:{}, cmd:{}"", taskExecutionContext.getProcessId(), cmd);
 148: OSUtils.exeCmd(cmd);
 149: }
 150: 
 151: } catch (Exception e) {
 152: processFlag = false;
 153: logger.error(""kill task error"", e);
 154: }
 155: // find log and kill yarn job
 156: Pair<Boolean, List<String>> yarnResult = killYarnJob(Host.of(taskExecutionContext.getHost()).getIp(),
 157: taskExecutionContext.getLogPath(),
 158: taskExecutionContext.getExecutePath(),
 159: taskExecutionContext.getTenantCode());
 160: return Pair.of(processFlag && yarnResult.getLeft(), yarnResult.getRight());","private Pair<Boolean, List<String>> doKill(TaskKillRequestCommand killCommand) {
        boolean processFlag = true;
        List<String> appIds = Collections.emptyList();
        int taskInstanceId = killCommand.getTaskInstanceId();
        TaskRequest taskRequest = TaskExecutionContextCacheManager.getByTaskInstanceId(taskInstanceId);
        TaskExecutionContext taskExecutionContext = JSONUtils.parseObject(JSONUtils.toJsonString(taskRequest), TaskExecutionContext.class);
        try {
            Integer processId = taskExecutionContext.getProcessId();
            if (processId.equals(0)) {
                TaskExecuteThread taskExecuteThread = workerManager.getTaskExecuteThread(taskInstanceId);
                if (null != taskExecuteThread) {
                    AbstractTask task = taskExecuteThread.getTask();
                    if (task != null) {
                        task.cancelApplication(true);
                        logger.info(""kill task by cancelApplication, task id:{}"", taskInstanceId);
                    }
                }
                workerManager.killTaskBeforeExecuteByInstanceId(taskInstanceId);
                TaskExecutionContextCacheManager.removeByTaskInstanceId(taskInstanceId);
                logger.info(""the task has not been executed and has been cancelled, task id:{}"", taskInstanceId);
                return Pair.of(true, appIds);
            }

            String pidsStr = ProcessUtils.getPidsStr(taskExecutionContext.getProcessId());
            if (!StringUtils.isEmpty(pidsStr)) {
                String cmd = String.format(""kill -9 %s"", pidsStr);
                cmd = OSUtils.getSudoCmd(taskExecutionContext.getTenantCode(), cmd);
                logger.info(""process id:{}, cmd:{}"", taskExecutionContext.getProcessId(), cmd);
                OSUtils.exeCmd(cmd);
            }

        } catch (Exception e) {
            processFlag = false;
            logger.error(""kill task error"", e);
        }
        // find log and kill yarn job
        Pair<Boolean, List<String>> yarnResult = killYarnJob(Host.of(taskExecutionContext.getHost()).getIp(),
                taskExecutionContext.getLogPath(),
                taskExecutionContext.getExecutePath(),
                taskExecutionContext.getTenantCode());
        return Pair.of(processFlag && yarnResult.getLeft(), yarnResult.getRight());
    }",1
dolphinscheduler-2.0.9,NULL_DEREFERENCE,dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/impl/DataAnalysisServiceImpl.java,"org.apache.dolphinscheduler.api.service.impl.DataAnalysisServiceImpl.countProcessInstanceStateByProject(org.apache.dolphinscheduler.dao.entity.User,long,java.lang.String,java.lang.String):java.util.Map",130,"object returned by `result.get(""data"")` could be null and is dereferenced at line 130.","121: public Map<String, Object> countProcessInstanceStateByProject(User loginUser, long projectCode, String startDate, String endDate) {
 122: Map<String, Object> result = this.countStateByProject(
 123: loginUser,
 124: projectCode,
 125: startDate,
 126: endDate,
 127: (start, end, projectCodes) -> this.processInstanceMapper.countInstanceStateByUser(start, end, projectCodes));
 128: // process state count needs to remove state of forced success
 129: if (result.containsKey(Constants.STATUS) && result.get(Constants.STATUS).equals(Status.SUCCESS)) {
 130: ((TaskCountDto)result.get(Constants.DATA_LIST)).removeStateFromCountList(ExecutionStatus.FORCED_SUCCESS);
 131: }
 132: return result;","public Map<String, Object> countProcessInstanceStateByProject(User loginUser, long projectCode, String startDate, String endDate) {
        Map<String, Object> result =  this.countStateByProject(
                loginUser,
                projectCode,
                startDate,
                endDate,
            (start, end, projectCodes) -> this.processInstanceMapper.countInstanceStateByUser(start, end, projectCodes));
        // process state count needs to remove state of forced success
        if (result.containsKey(Constants.STATUS) && result.get(Constants.STATUS).equals(Status.SUCCESS)) {
            ((TaskCountDto)result.get(Constants.DATA_LIST)).removeStateFromCountList(ExecutionStatus.FORCED_SUCCESS);
        }
        return result;
    }",0
dolphinscheduler-2.0.9,NULL_DEREFERENCE,dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/master/runner/task/SubTaskProcessor.java,org.apache.dolphinscheduler.server.master.runner.task.SubTaskProcessor.updateTaskState():void,124,object `SubTaskProcessor.subProcessInstance` last assigned on line 122 could be null and is dereferenced at line 124.,"121: private void updateTaskState() {
 122: subProcessInstance = processService.findSubProcessInstance(processInstance.getId(), taskInstance.getId());
 123: logger.info(""work flow {} task {}, sub work flow: {} state: {}"", this.processInstance.getId(), this.taskInstance.getId(),
 124: subProcessInstance.getId(), subProcessInstance.getState().getDescp());
 125: if (subProcessInstance != null && subProcessInstance.getState().typeIsFinished()) {","private void updateTaskState() {
        subProcessInstance = processService.findSubProcessInstance(processInstance.getId(), taskInstance.getId());
        logger.info(""work flow {} task {}, sub work flow: {} state: {}"", this.processInstance.getId(), this.taskInstance.getId(),
                subProcessInstance.getId(), subProcessInstance.getState().getDescp());
        if (subProcessInstance != null && subProcessInstance.getState().typeIsFinished()) {
            taskInstance.setState(subProcessInstance.getState());
            taskInstance.setEndTime(new Date());
            processService.saveTaskInstance(taskInstance);
        }
    }",1
dolphinscheduler-2.0.9,NULL_DEREFERENCE,dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/worker/runner/WorkerManagerThread.java,org.apache.dolphinscheduler.server.worker.runner.WorkerManagerThread.sendTaskKillResponse(java.lang.Integer):void,128,object `taskExecutionContext` last assigned on line 127 could be null and is dereferenced at line 128.,"122: private void sendTaskKillResponse(Integer taskInstanceId) {
 123: TaskRequest taskRequest = TaskExecutionContextCacheManager.getByTaskInstanceId(taskInstanceId);
 124: if (taskRequest == null) {
 125: return;
 126: }
 127: TaskExecutionContext taskExecutionContext = JSONUtils.parseObject(JSONUtils.toJsonString(taskRequest), TaskExecutionContext.class);
 128: TaskExecuteResponseCommand responseCommand = new TaskExecuteResponseCommand(taskExecutionContext.getTaskInstanceId(), taskExecutionContext.getProcessInstanceId());
 129: responseCommand.setStatus(ExecutionStatus.KILL.getCode());
 130: ResponceCache.get().cache(taskExecutionContext.getTaskInstanceId(), responseCommand.convert2Command(), Event.RESULT);
 131: taskCallbackService.sendResult(taskExecutionContext.getTaskInstanceId(), responseCommand.convert2Command());","private void sendTaskKillResponse(Integer taskInstanceId) {
        TaskRequest taskRequest = TaskExecutionContextCacheManager.getByTaskInstanceId(taskInstanceId);
        if (taskRequest == null) {
            return;
        }
        TaskExecutionContext taskExecutionContext = JSONUtils.parseObject(JSONUtils.toJsonString(taskRequest), TaskExecutionContext.class);
        TaskExecuteResponseCommand responseCommand = new TaskExecuteResponseCommand(taskExecutionContext.getTaskInstanceId(), taskExecutionContext.getProcessInstanceId());
        responseCommand.setStatus(ExecutionStatus.KILL.getCode());
        ResponceCache.get().cache(taskExecutionContext.getTaskInstanceId(), responseCommand.convert2Command(), Event.RESULT);
        taskCallbackService.sendResult(taskExecutionContext.getTaskInstanceId(), responseCommand.convert2Command());
    }",1
dolphinscheduler-2.0.9,NULL_DEREFERENCE,dolphinscheduler-task-plugin/dolphinscheduler-task-http/src/main/java/org/apache/dolphinscheduler/plugin/task/http/HttpTask.java,org.apache.dolphinscheduler.plugin.task.http.HttpTask.sendRequest(org.apache.http.impl.client.CloseableHttpClient):org.apache.http.client.methods.CloseableHttpResponse,145,object `builder` last assigned on line 125 could be null and is dereferenced by call to `addRequestParams(...)` at line 145.,"124: protected CloseableHttpResponse sendRequest(CloseableHttpClient client) throws IOException {
 125: RequestBuilder builder = createRequestBuilder();
 126: 
 127: // replace placeholder,and combine local and global parameters
 128: Map<String, Property> paramsMap = ParamUtils.convert(taskExecutionContext,getParameters());
 129: if (MapUtils.isEmpty(paramsMap)) {
 130: paramsMap = new HashMap<>();
 131: }
 132: if (MapUtils.isNotEmpty(taskExecutionContext.getParamsMap())) {
 133: paramsMap.putAll(taskExecutionContext.getParamsMap());
 134: }
 135: 
 136: List<HttpProperty> httpPropertyList = new ArrayList<>();
 137: if (CollectionUtils.isNotEmpty(httpParameters.getHttpParams())) {
 138: for (HttpProperty httpProperty : httpParameters.getHttpParams()) {
 139: String jsonObject = JSONUtils.toJsonString(httpProperty);
 140: String params = ParameterUtils.convertParameterPlaceholders(jsonObject, ParamUtils.convert(paramsMap));
 141: logger.info(""http request params：{}"", params);
 142: httpPropertyList.add(JSONUtils.parseObject(params, HttpProperty.class));
 143: }
 144: }
 145: addRequestParams(builder, httpPropertyList);
 146: String requestUrl = ParameterUtils.convertParameterPlaceholders(httpParameters.getUrl(), ParamUtils.convert(paramsMap));
 147: HttpUriRequest request = builder.setUri(requestUrl).build();
 148: setHeaders(request, httpPropertyList);
 149: return client.execute(request);","protected CloseableHttpResponse sendRequest(CloseableHttpClient client) throws IOException {
        RequestBuilder builder = createRequestBuilder();

        // replace placeholder,and combine local and global parameters
        Map<String, Property> paramsMap = ParamUtils.convert(taskExecutionContext,getParameters());
        if (MapUtils.isEmpty(paramsMap)) {
            paramsMap = new HashMap<>();
        }
        if (MapUtils.isNotEmpty(taskExecutionContext.getParamsMap())) {
            paramsMap.putAll(taskExecutionContext.getParamsMap());
        }

        List<HttpProperty> httpPropertyList = new ArrayList<>();
        if (CollectionUtils.isNotEmpty(httpParameters.getHttpParams())) {
            for (HttpProperty httpProperty : httpParameters.getHttpParams()) {
                String jsonObject = JSONUtils.toJsonString(httpProperty);
                String params = ParameterUtils.convertParameterPlaceholders(jsonObject, ParamUtils.convert(paramsMap));
                logger.info(""http request params：{}"", params);
                httpPropertyList.add(JSONUtils.parseObject(params, HttpProperty.class));
            }
        }
        addRequestParams(builder, httpPropertyList);
        String requestUrl = ParameterUtils.convertParameterPlaceholders(httpParameters.getUrl(), ParamUtils.convert(paramsMap));
        HttpUriRequest request = builder.setUri(requestUrl).build();
        setHeaders(request, httpPropertyList);
        return client.execute(request);
    }",0
dolphinscheduler-2.0.9,NULL_DEREFERENCE,dolphinscheduler-alert/dolphinscheduler-alert-plugins/dolphinscheduler-alert-http/src/main/java/org/apache/dolphinscheduler/plugin/alert/http/HttpSender.java,org.apache.dolphinscheduler.plugin.alert.http.HttpSender.setHeader():void,133,object `map` last assigned on line 132 could be null and is dereferenced at line 133.,"126: private void setHeader() {
 127: 
 128: if (httpRequest == null) {
 129: return;
 130: }
 131: 
 132: HashMap<String, Object> map = JSONUtils.parseObject(headerParams, HashMap.class);
 133: for (Map.Entry<String, Object> entry : map.entrySet()) {","private void setHeader() {

        if (httpRequest == null) {
            return;
        }

        HashMap<String, Object> map = JSONUtils.parseObject(headerParams, HashMap.class);
        for (Map.Entry<String, Object> entry : map.entrySet()) {
            httpRequest.setHeader(entry.getKey(), String.valueOf(entry.getValue()));
        }
    }",1
dolphinscheduler-2.0.9,NULL_DEREFERENCE,dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/impl/DataSourceServiceImpl.java,"org.apache.dolphinscheduler.api.service.impl.DataSourceServiceImpl.updateDataSource(int,org.apache.dolphinscheduler.dao.entity.User,org.apache.dolphinscheduler.plugin.datasource.api.datasource.BaseDataSourceParamDTO):org.apache.dolphinscheduler.api.utils.Result",154,object `oldParams` last assigned on line 153 could be null and is dereferenced at line 154.,"128: public Result<Object> updateDataSource(int id, User loginUser, BaseDataSourceParamDTO dataSourceParam) {
 129: DatasourceUtil.checkDatasourceParam(dataSourceParam);
 130: Result<Object> result = new Result<>();
 131: // determine whether the data source exists
 132: DataSource dataSource = dataSourceMapper.selectById(id);
 133: if (dataSource == null) {
 134: putMsg(result, Status.RESOURCE_NOT_EXIST);
 135: return result;
 136: }
 137: 
 138: if (!hasPerm(loginUser, dataSource.getUserId())) {
 139: putMsg(result, Status.USER_NO_OPERATION_PERM);
 140: return result;
 141: }
 142: 
 143: //check name can use or not
 144: if (!dataSource.getName().trim().equals(dataSource.getName()) && checkName(dataSource.getName())) {
 145: putMsg(result, Status.DATASOURCE_EXIST);
 146: return result;
 147: }
 148: //check password，if the password is not updated, set to the old password.
 149: BaseConnectionParam connectionParam = (BaseConnectionParam) DatasourceUtil.buildConnectionParams(dataSourceParam);
 150: String password = connectionParam.getPassword();
 151: if (StringUtils.isBlank(password)) {
 152: String oldConnectionParams = dataSource.getConnectionParams();
 153: ObjectNode oldParams = JSONUtils.parseObject(oldConnectionParams);
 154: connectionParam.setPassword(oldParams.path(Constants.PASSWORD).asText());
 155: }
 156: 
 157: Result<Object> isConnection = checkConnection(dataSource.getType(), connectionParam);
 158: if (isConnection.isFailed()) {
 159: return isConnection;
 160: }
 161: 
 162: Date now = new Date();
 163: 
 164: dataSource.setName(dataSourceParam.getName().trim());
 165: dataSource.setNote(dataSourceParam.getNote());
 166: dataSource.setUserName(loginUser.getUserName());
 167: dataSource.setType(dataSource.getType());
 168: dataSource.setConnectionParams(JSONUtils.toJsonString(connectionParam));
 169: dataSource.setUpdateTime(now);
 170: try {
 171: dataSourceMapper.updateById(dataSource);
 172: putMsg(result, Status.SUCCESS);
 173: } catch (DuplicateKeyException ex) {
 174: logger.error(""Update datasource error."", ex);
 175: putMsg(result, Status.DATASOURCE_EXIST);
 176: }
 177: return result;","public Result<Object> updateDataSource(int id, User loginUser, BaseDataSourceParamDTO dataSourceParam) {
        DatasourceUtil.checkDatasourceParam(dataSourceParam);
        Result<Object> result = new Result<>();
        // determine whether the data source exists
        DataSource dataSource = dataSourceMapper.selectById(id);
        if (dataSource == null) {
            putMsg(result, Status.RESOURCE_NOT_EXIST);
            return result;
        }

        if (!hasPerm(loginUser, dataSource.getUserId())) {
            putMsg(result, Status.USER_NO_OPERATION_PERM);
            return result;
        }

        //check name can use or not
        if (!dataSource.getName().trim().equals(dataSource.getName()) && checkName(dataSource.getName())) {
            putMsg(result, Status.DATASOURCE_EXIST);
            return result;
        }
        //check password，if the password is not updated, set to the old password.
        BaseConnectionParam connectionParam = (BaseConnectionParam) DatasourceUtil.buildConnectionParams(dataSourceParam);
        String password = connectionParam.getPassword();
        if (StringUtils.isBlank(password)) {
            String oldConnectionParams = dataSource.getConnectionParams();
            ObjectNode oldParams = JSONUtils.parseObject(oldConnectionParams);
            connectionParam.setPassword(oldParams.path(Constants.PASSWORD).asText());
        }

        Result<Object> isConnection = checkConnection(dataSource.getType(), connectionParam);
        if (isConnection.isFailed()) {
            return isConnection;
        }

        Date now = new Date();

        dataSource.setName(dataSourceParam.getName().trim());
        dataSource.setNote(dataSourceParam.getNote());
        dataSource.setUserName(loginUser.getUserName());
        dataSource.setType(dataSource.getType());
        dataSource.setConnectionParams(JSONUtils.toJsonString(connectionParam));
        dataSource.setUpdateTime(now);
        try {
            dataSourceMapper.updateById(dataSource);
            putMsg(result, Status.SUCCESS);
        } catch (DuplicateKeyException ex) {
            logger.error(""Update datasource error."", ex);
            putMsg(result, Status.DATASOURCE_EXIST);
        }
        return result;
    }",1
dolphinscheduler-2.0.9,NULL_DEREFERENCE,dolphinscheduler-task-plugin/dolphinscheduler-task-datax/src/main/java/org/apache/dolphinscheduler/plugin/task/datax/DataxTask.java,org.apache.dolphinscheduler.plugin.task.datax.DataxTask.init():void,135,object `DataxTask.dataXParameters` last assigned on line 133 could be null and is dereferenced at line 135.,"131: public void init() {
 132: logger.info(""datax task params {}"", taskExecutionContext.getTaskParams());
 133: dataXParameters = JSONUtils.parseObject(taskExecutionContext.getTaskParams(), DataxParameters.class);
 134: 
 135: if (!dataXParameters.checkParameters()) {","public void init() {
        logger.info(""datax task params {}"", taskExecutionContext.getTaskParams());
        dataXParameters = JSONUtils.parseObject(taskExecutionContext.getTaskParams(), DataxParameters.class);

        if (!dataXParameters.checkParameters()) {
            throw new RuntimeException(""datax task params is not valid"");
        }
    }",1
dolphinscheduler-2.0.9,NULL_DEREFERENCE,dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/impl/SchedulerServiceImpl.java,"org.apache.dolphinscheduler.api.service.impl.SchedulerServiceImpl.insertSchedule(org.apache.dolphinscheduler.dao.entity.User,long,long,java.lang.String,org.apache.dolphinscheduler.common.enums.WarningType,int,org.apache.dolphinscheduler.common.enums.FailureStrategy,org.apache.dolphinscheduler.common.enums.Priority,java.lang.String,java.lang.Long):java.util.Map",162,object `scheduleParam` last assigned on line 161 could be null and is dereferenced at line 162.,"126: public Map<String, Object> insertSchedule(User loginUser,
 127: long projectCode,
 128: long processDefineCode,
 129: String schedule,
 130: WarningType warningType,
 131: int warningGroupId,
 132: FailureStrategy failureStrategy,
 133: Priority processInstancePriority,
 134: String workerGroup,
 135: Long environmentCode) {
 136: 
 137: Map<String, Object> result = new HashMap<>();
 138: 
 139: Project project = projectMapper.queryByCode(projectCode);
 140: 
 141: // check project auth
 142: boolean hasProjectAndPerm = projectService.hasProjectAndPerm(loginUser, project, result);
 143: if (!hasProjectAndPerm) {
 144: return result;
 145: }
 146: 
 147: // check work flow define release state
 148: ProcessDefinition processDefinition = processDefinitionMapper.queryByCode(processDefineCode);
 149: result = executorService.checkProcessDefinitionValid(projectCode,processDefinition, processDefineCode);
 150: if (result.get(Constants.STATUS) != Status.SUCCESS) {
 151: return result;
 152: }
 153: 
 154: Schedule scheduleObj = new Schedule();
 155: Date now = new Date();
 156: 
 157: scheduleObj.setProjectName(project.getName());
 158: scheduleObj.setProcessDefinitionCode(processDefineCode);
 159: scheduleObj.setProcessDefinitionName(processDefinition.getName());
 160: 
 161: ScheduleParam scheduleParam = JSONUtils.parseObject(schedule, ScheduleParam.class);
 162: if (DateUtils.differSec(scheduleParam.getStartTime(), scheduleParam.getEndTime()) == 0) {
 163: logger.warn(""The start time must not be the same as the end"");
 164: putMsg(result, Status.SCHEDULE_START_TIME_END_TIME_SAME);
 165: return result;
 166: }
 167: scheduleObj.setStartTime(scheduleParam.getStartTime());
 168: scheduleObj.setEndTime(scheduleParam.getEndTime());
 169: if (!org.quartz.CronExpression.isValidExpression(scheduleParam.getCrontab())) {
 170: logger.error(""{} verify failure"", scheduleParam.getCrontab());
 171: 
 172: putMsg(result, Status.REQUEST_PARAMS_NOT_VALID_ERROR, scheduleParam.getCrontab());
 173: return result;
 174: }
 175: scheduleObj.setCrontab(scheduleParam.getCrontab());
 176: scheduleObj.setTimezoneId(scheduleParam.getTimezoneId());
 177: scheduleObj.setWarningType(warningType);
 178: scheduleObj.setWarningGroupId(warningGroupId);
 179: scheduleObj.setFailureStrategy(failureStrategy);
 180: scheduleObj.setCreateTime(now);
 181: scheduleObj.setUpdateTime(now);
 182: scheduleObj.setUserId(loginUser.getId());
 183: scheduleObj.setUserName(loginUser.getUserName());
 184: scheduleObj.setReleaseState(ReleaseState.OFFLINE);
 185: scheduleObj.setProcessInstancePriority(processInstancePriority);
 186: scheduleObj.setWorkerGroup(workerGroup);
 187: scheduleObj.setEnvironmentCode(environmentCode);
 188: scheduleMapper.insert(scheduleObj);
 189: 
 190: /**
 191: * updateProcessInstance receivers and cc by process definition id
 192: */
 193: processDefinition.setWarningGroupId(warningGroupId);
 194: processDefinitionMapper.updateById(processDefinition);
 195: 
 196: // return scheduler object with ID
 197: result.put(Constants.DATA_LIST, scheduleMapper.selectById(scheduleObj.getId()));
 198: putMsg(result, Status.SUCCESS);
 199: 
 200: result.put(""scheduleId"", scheduleObj.getId());
 201: return result;","public Map<String, Object> insertSchedule(User loginUser,
                                              long projectCode,
                                              long processDefineCode,
                                              String schedule,
                                              WarningType warningType,
                                              int warningGroupId,
                                              FailureStrategy failureStrategy,
                                              Priority processInstancePriority,
                                              String workerGroup,
                                              Long environmentCode) {

        Map<String, Object> result = new HashMap<>();

        Project project = projectMapper.queryByCode(projectCode);

        // check project auth
        boolean hasProjectAndPerm = projectService.hasProjectAndPerm(loginUser, project, result);
        if (!hasProjectAndPerm) {
            return result;
        }

        // check work flow define release state
        ProcessDefinition processDefinition = processDefinitionMapper.queryByCode(processDefineCode);
        result = executorService.checkProcessDefinitionValid(projectCode,processDefinition, processDefineCode);
        if (result.get(Constants.STATUS) != Status.SUCCESS) {
            return result;
        }

        Schedule scheduleObj = new Schedule();
        Date now = new Date();

        scheduleObj.setProjectName(project.getName());
        scheduleObj.setProcessDefinitionCode(processDefineCode);
        scheduleObj.setProcessDefinitionName(processDefinition.getName());

        ScheduleParam scheduleParam = JSONUtils.parseObject(schedule, ScheduleParam.class);
        if (DateUtils.differSec(scheduleParam.getStartTime(), scheduleParam.getEndTime()) == 0) {
            logger.warn(""The start time must not be the same as the end"");
            putMsg(result, Status.SCHEDULE_START_TIME_END_TIME_SAME);
            return result;
        }
        scheduleObj.setStartTime(scheduleParam.getStartTime());
        scheduleObj.setEndTime(scheduleParam.getEndTime());
        if (!org.quartz.CronExpression.isValidExpression(scheduleParam.getCrontab())) {
            logger.error(""{} verify failure"", scheduleParam.getCrontab());

            putMsg(result, Status.REQUEST_PARAMS_NOT_VALID_ERROR, scheduleParam.getCrontab());
            return result;
        }
        scheduleObj.setCrontab(scheduleParam.getCrontab());
        scheduleObj.setTimezoneId(scheduleParam.getTimezoneId());
        scheduleObj.setWarningType(warningType);
        scheduleObj.setWarningGroupId(warningGroupId);
        scheduleObj.setFailureStrategy(failureStrategy);
        scheduleObj.setCreateTime(now);
        scheduleObj.setUpdateTime(now);
        scheduleObj.setUserId(loginUser.getId());
        scheduleObj.setUserName(loginUser.getUserName());
        scheduleObj.setReleaseState(ReleaseState.OFFLINE);
        scheduleObj.setProcessInstancePriority(processInstancePriority);
        scheduleObj.setWorkerGroup(workerGroup);
        scheduleObj.setEnvironmentCode(environmentCode);
        scheduleMapper.insert(scheduleObj);

        /**
         * updateProcessInstance receivers and cc by process definition id
         */
        processDefinition.setWarningGroupId(warningGroupId);
        processDefinitionMapper.updateById(processDefinition);

        // return scheduler object with ID
        result.put(Constants.DATA_LIST, scheduleMapper.selectById(scheduleObj.getId()));
        putMsg(result, Status.SUCCESS);

        result.put(""scheduleId"", scheduleObj.getId());
        return result;
    }",1
dolphinscheduler-2.0.9,NULL_DEREFERENCE,dolphinscheduler-alert/dolphinscheduler-alert-plugins/dolphinscheduler-alert-http/src/main/java/org/apache/dolphinscheduler/plugin/alert/http/HttpSender.java,org.apache.dolphinscheduler.plugin.alert.http.HttpSender.setMsgInRequestBody(java.lang.String):void,144,object `objectNode` last assigned on line 142 could be null and is dereferenced at line 144.,"141: private void setMsgInRequestBody(String msg) {
 142: ObjectNode objectNode = JSONUtils.parseObject(bodyParams);
 143: //set msg content field
 144: objectNode.put(contentField, msg);
 145: try {","private void setMsgInRequestBody(String msg) {
        ObjectNode objectNode = JSONUtils.parseObject(bodyParams);
        //set msg content field
        objectNode.put(contentField, msg);
        try {
            StringEntity entity = new StringEntity(JSONUtils.toJsonString(objectNode), DEFAULT_CHARSET);
            ((HttpPost) httpRequest).setEntity(entity);
        } catch (Exception e) {
            log.error(""send http alert msg  exception : {}"", e.getMessage());
        }
    }",1
dolphinscheduler-2.0.9,NULL_DEREFERENCE,dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/master/runner/task/SubTaskProcessor.java,org.apache.dolphinscheduler.server.master.runner.task.SubTaskProcessor.dealFinish1():void,181,object `taskParams` last assigned on line 179 could be null and is dereferenced at line 181.,"153: private void dealFinish1() {
 154: // build dag
 155: ProcessDefinition processDefinition = processService.findProcessDefinition(subProcessInstance.getProcessDefinitionCode(), subProcessInstance.getProcessDefinitionVersion());
 156: if (null == processDefinition) {
 157: logger.error(""process definition not found in meta data, processDefinitionCode:{}, processDefinitionVersion:{}, processInstanceId:{}"",
 158: subProcessInstance.getProcessDefinitionCode(), subProcessInstance.getProcessDefinitionVersion(), subProcessInstance.getId());
 159: throw new RuntimeException(String.format(""process definition code %s, version %s does not exist"", subProcessInstance.getProcessDefinitionCode(), subProcessInstance.getProcessDefinitionVersion()));
 160: }
 161: subProcessInstance.setProcessDefinition(processDefinition);
 162: DAG<String, TaskNode, TaskNodeRelation> dag = processService.genDagGraph(subProcessInstance.getProcessDefinition());
 163: // get end nodes
 164: Set<String> endTaskCodes = dag.getEndNode().stream().collect(Collectors.toSet());
 165: logger.info(""in dealFinish1, endTaskCodes:{}"", endTaskCodes);
 166: if (endTaskCodes == null || endTaskCodes.isEmpty()) {
 167: return;
 168: }
 169: // get var pool of sub progress instance;
 170: Map<String, Property> varPoolPropertiesMap = mergeEndNodeTaskInstanceVarPool(endTaskCodes);
 171: logger.debug(""in dealFinish1, varPoolPropertiesMap:{}"", varPoolPropertiesMap);
 172: // merge var pool: 1. task instance var pool from pre task ; 2. var pool from sub progress
 173: // filter by localParams
 174: String taskVarPool = taskInstance.getVarPool();
 175: Map<String, Property> taskVarPoolProperties = new HashMap<>();
 176: if (StringUtils.isNotEmpty(taskVarPool)) {
 177: taskVarPoolProperties = JSONUtils.toList(taskVarPool, Property.class).stream().collect(Collectors.toMap(Property::getProp, (p) -> p));
 178: }
 179: Map<String, Object> taskParams = JSONUtils.parseObject(taskInstance.getTaskParams(), new TypeReference<Map<String, Object>>() {
 180: });
 181: Object localParams = taskParams.get(LOCAL_PARAMS);
 182: Map<String, Property> outProperties = new HashMap<>();
 183: if (localParams != null) {
 184: List<Property> properties = JSONUtils.toList(JSONUtils.toJsonString(localParams), Property.class);
 185: outProperties = properties.stream().filter(r -> Direct.OUT == r.getDirect()).collect(Collectors.toMap(Property::getProp, (p) -> p));
 186: // put all task instance var pool from pre task
 187: outProperties.putAll(taskVarPoolProperties);
 188: for (Map.Entry<String, Property> o : outProperties.entrySet()) {
 189: if (varPoolPropertiesMap.containsKey(o.getKey())) {
 190: o.getValue().setValue(varPoolPropertiesMap.get(o.getKey()).getValue());
 191: }
 192: }
 193: } else {
 194: outProperties.putAll(taskVarPoolProperties);
 195: outProperties.putAll(varPoolPropertiesMap);
 196: }
 197: taskInstance.setVarPool(JSONUtils.toJsonString(outProperties.values()));
 198: logger.debug(""in dealFinish1, varPool:{}"", taskInstance.getVarPool());
 199: //deal with localParam for show in the page
 200: processService.changeOutParam(taskInstance);","private void dealFinish1() {
        // build dag
        ProcessDefinition processDefinition = processService.findProcessDefinition(subProcessInstance.getProcessDefinitionCode(), subProcessInstance.getProcessDefinitionVersion());
        if (null == processDefinition) {
            logger.error(""process definition not found in meta data, processDefinitionCode:{}, processDefinitionVersion:{}, processInstanceId:{}"",
                    subProcessInstance.getProcessDefinitionCode(), subProcessInstance.getProcessDefinitionVersion(), subProcessInstance.getId());
            throw new RuntimeException(String.format(""process definition  code %s, version %s does not exist"", subProcessInstance.getProcessDefinitionCode(), subProcessInstance.getProcessDefinitionVersion()));
        }
        subProcessInstance.setProcessDefinition(processDefinition);
        DAG<String, TaskNode, TaskNodeRelation> dag = processService.genDagGraph(subProcessInstance.getProcessDefinition());
        // get end nodes
        Set<String> endTaskCodes = dag.getEndNode().stream().collect(Collectors.toSet());
        logger.info(""in dealFinish1, endTaskCodes:{}"", endTaskCodes);
        if (endTaskCodes == null || endTaskCodes.isEmpty()) {
            return;
        }
        // get var pool of sub progress instance;
        Map<String, Property> varPoolPropertiesMap = mergeEndNodeTaskInstanceVarPool(endTaskCodes);
        logger.debug(""in dealFinish1, varPoolPropertiesMap:{}"", varPoolPropertiesMap);
        // merge var pool: 1. task instance var pool from pre task ; 2. var pool from sub progress
        // filter by localParams
        String taskVarPool = taskInstance.getVarPool();
        Map<String, Property> taskVarPoolProperties = new HashMap<>();
        if (StringUtils.isNotEmpty(taskVarPool)) {
            taskVarPoolProperties = JSONUtils.toList(taskVarPool, Property.class).stream().collect(Collectors.toMap(Property::getProp, (p) -> p));
        }
        Map<String, Object> taskParams = JSONUtils.parseObject(taskInstance.getTaskParams(), new TypeReference<Map<String, Object>>() {
        });
        Object localParams = taskParams.get(LOCAL_PARAMS);
        Map<String, Property> outProperties = new HashMap<>();
        if (localParams != null) {
            List<Property> properties = JSONUtils.toList(JSONUtils.toJsonString(localParams), Property.class);
            outProperties = properties.stream().filter(r -> Direct.OUT == r.getDirect()).collect(Collectors.toMap(Property::getProp, (p) -> p));
            // put all task instance var pool from pre task
            outProperties.putAll(taskVarPoolProperties);
            for (Map.Entry<String, Property> o : outProperties.entrySet()) {
                if (varPoolPropertiesMap.containsKey(o.getKey())) {
                    o.getValue().setValue(varPoolPropertiesMap.get(o.getKey()).getValue());
                }
            }
        } else {
            outProperties.putAll(taskVarPoolProperties);
            outProperties.putAll(varPoolPropertiesMap);
        }
        taskInstance.setVarPool(JSONUtils.toJsonString(outProperties.values()));
        logger.debug(""in dealFinish1, varPool:{}"", taskInstance.getVarPool());
        //deal with localParam for show in the page
        processService.changeOutParam(taskInstance);
    }",1
dolphinscheduler-2.0.9,NULL_DEREFERENCE,dolphinscheduler-task-plugin/dolphinscheduler-task-pigeon/src/main/java/org/apache/dolphinscheduler/plugin/task/pigeon/PigeonTask.java,org.apache.dolphinscheduler.plugin.task.pigeon.PigeonTask.cancelApplication(boolean):void,178,object `cancelResult` last assigned on line 177 could be null and is dereferenced at line 178.,https://github.com/apache/dolphinscheduler/blob/2.0.9-release/dolphinscheduler-task-plugin/dolphinscheduler-task-pigeon/src/main/java/org/apache/dolphinscheduler/plugin/task/pigeon/PigeonTask.java,"public void cancelApplication(boolean status) throws Exception {
        super.cancelApplication(status);
        logger.info(""start to cancelApplication"");
        Objects.requireNonNull(triggerResult, ""triggerResult can not be null"");
        logger.info(""start to cancelApplication taskId:{}"", triggerResult.getTaskId());
        final String triggerUrl = getTriggerUrl();

        StringEntity entity = new StringEntity(config.getJobCancelPostBody(triggerResult.getTaskId()), StandardCharsets.UTF_8);

        CancelResult cancelResult = null;
        HttpPost post = new HttpPost(triggerUrl);
        addFormUrlencoded(post);
        post.setEntity(entity);
        try (CloseableHttpClient client = HttpClients.createDefault();
             // trigger to start TIS dataX task
             CloseableHttpResponse response = client.execute(post)) {
            cancelResult = processResponse(triggerUrl, response, CancelResult.class);
            if (!cancelResult.isSuccess()) {
                List<String> errormsg = triggerResult.getErrormsg();
                StringBuffer errs = new StringBuffer();
                if (CollectionUtils.isNotEmpty(errormsg)) {
                    errs.append("",errs:"").append(errormsg.stream().collect(Collectors.joining("","")));
                }
                throw new Exception(""cancel PIGEON job faild taskId:"" + triggerResult.getTaskId() + errs.toString());
            }
        }
    }",1
dolphinscheduler-2.0.9,NULL_DEREFERENCE,dolphinscheduler-dao/src/main/java/org/apache/dolphinscheduler/dao/upgrade/UpgradeDao.java,org.apache.dolphinscheduler.dao.upgrade.UpgradeDao.updateProcessDefinitionJsonWorkerGroup():void,194,object `jsonObject` last assigned on line 193 could be null and is dereferenced at line 194.,https://github.com/apache/dolphinscheduler/blob/2.0.9-release/dolphinscheduler-dao/src/main/java/org/apache/dolphinscheduler/dao/upgrade/UpgradeDao.java,"protected void updateProcessDefinitionJsonWorkerGroup() {
        WorkerGroupDao workerGroupDao = new WorkerGroupDao();
        ProcessDefinitionDao processDefinitionDao = new ProcessDefinitionDao();
        Map<Integer, String> replaceProcessDefinitionMap = new HashMap<>();
        try {
            Map<Integer, String> oldWorkerGroupMap = workerGroupDao.queryAllOldWorkerGroup(dataSource.getConnection());
            Map<Integer, String> processDefinitionJsonMap = processDefinitionDao.queryAllProcessDefinition(dataSource.getConnection());

            for (Map.Entry<Integer, String> entry : processDefinitionJsonMap.entrySet()) {
                ObjectNode jsonObject = JSONUtils.parseObject(entry.getValue());
                ArrayNode tasks = JSONUtils.parseArray(jsonObject.get(""tasks"").toString());

                for (int i = 0; i < tasks.size(); i++) {
                    ObjectNode task = (ObjectNode) tasks.path(i);
                    ObjectNode workerGroupNode = (ObjectNode) task.path(""workerGroupId"");
                    int workerGroupId = -1;
                    if (workerGroupNode != null && workerGroupNode.canConvertToInt()) {
                        workerGroupId = workerGroupNode.asInt(-1);
                    }
                    if (workerGroupId == -1) {
                        task.put(""workerGroup"", ""default"");
                    } else {
                        task.put(""workerGroup"", oldWorkerGroupMap.get(workerGroupId));
                    }
                }

                jsonObject.remove(""task"");

                jsonObject.put(""tasks"", tasks);

                replaceProcessDefinitionMap.put(entry.getKey(), jsonObject.toString());
            }
            if (replaceProcessDefinitionMap.size() > 0) {
                processDefinitionDao.updateProcessDefinitionJson(dataSource.getConnection(), replaceProcessDefinitionMap);
            }
        } catch (Exception e) {
            logger.error(""update process definition json workergroup error"", e);
        }
    }
",1
dolphinscheduler-2.0.9,NULL_DEREFERENCE,dolphinscheduler-registry/dolphinscheduler-registry-plugins/dolphinscheduler-registry-zookeeper/src/main/java/org/apache/dolphinscheduler/plugin/registry/zookeeper/ZookeeperRegistry.java,org.apache.dolphinscheduler.plugin.registry.zookeeper.ZookeeperRegistry.acquireLock(java.lang.String):boolean,207,object returned by `org.apache.dolphinscheduler.plugin.registry.zookeeper.ZookeeperRegistry.threadLocalLockMap.get()` could be null and is dereferenced at line 207.,https://github.com/apache/dolphinscheduler/blob/2.0.9-release/dolphinscheduler-registry/dolphinscheduler-registry-plugins/dolphinscheduler-registry-zookeeper/src/main/java/org/apache/dolphinscheduler/plugin/registry/zookeeper/ZookeeperRegistry.java,"public boolean acquireLock(String key) {
        InterProcessMutex interProcessMutex = new InterProcessMutex(client, key);
        try {
            interProcessMutex.acquire();
            if (null == threadLocalLockMap.get()) {
                threadLocalLockMap.set(new HashMap<>(3));
            }
            threadLocalLockMap.get().put(key, interProcessMutex);
            return true;
        } catch (Exception e) {
            try {
                interProcessMutex.release();
                throw new RegistryException(""zookeeper get lock error"", e);
            } catch (Exception exception) {
                throw new RegistryException(""zookeeper release lock error"", e);
            }
        }
    }",0
dolphinscheduler-2.0.9,NULL_DEREFERENCE,dolphinscheduler-task-plugin/dolphinscheduler-task-pigeon/src/main/java/org/apache/dolphinscheduler/plugin/task/pigeon/PigeonTask.java,org.apache.dolphinscheduler.plugin.task.pigeon.PigeonTask$1.onMessage(java.lang.String):void,214,object `execLog` last assigned on line 213 could be null and is dereferenced at line 214.,"202: private WebSocketClient receiveRealtimeLog(final String tisHost, String dataXName, int taskId) throws Exception {
 203: final String applyURI = config.getJobLogsFetchUrl(tisHost, dataXName, taskId);
 204: logger.info(""apply ws connection,uri:{}"", applyURI);
 205: WebSocketClient webSocketClient = new WebSocketClient(new URI(applyURI)) {
 206: @Override
 207: public void onOpen(ServerHandshake handshakedata) {
 208: logger.info(""start to receive remote execute log"");
 209: }
 210: 
 211: @Override
 212: public void onMessage(String message) {
 213: ExecLog execLog = JSONUtils.parseObject(message, ExecLog.class);
 214: logger.info(execLog.getMsg());
 215: }
 216: 
 217: @Override
 218: public void onClose(int code, String reason, boolean remote) {
 219: logger.info(""stop to receive remote log,reason:{},taskId:{}"", reason, taskId);
 220: }
 221: 
 222: @Override
 223: public void onError(Exception t) {
 224: logger.error(t.getMessage(), t);
 225: }
 226: };
 227: webSocketClient.connect();
 228: return webSocketClient;","public void onMessage(String message) {
                ExecLog execLog = JSONUtils.parseObject(message, ExecLog.class);
                logger.info(execLog.getMsg());
            }",1
dolphinscheduler-2.0.9,NULL_DEREFERENCE,dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/impl/ExecutorServiceImpl.java,"org.apache.dolphinscheduler.api.service.impl.ExecutorServiceImpl.execute(org.apache.dolphinscheduler.dao.entity.User,long,java.lang.Integer,org.apache.dolphinscheduler.api.enums.ExecuteType):java.util.Map",251,object `processDefinition` last assigned on line 238 could be null and is dereferenced by call to `checkTenantSuitable(...)` at line 251.,"219: public Map<String, Object> execute(User loginUser, long projectCode, Integer processInstanceId, ExecuteType executeType) {
 220: Project project = projectMapper.queryByCode(projectCode);
 221: //check user access for project
 222: Map<String, Object> result = projectService.checkProjectAndAuth(loginUser, project, projectCode);
 223: if (result.get(Constants.STATUS) != Status.SUCCESS) {
 224: return result;
 225: }
 226: 
 227: // check master exists
 228: if (!checkMasterExists(result)) {
 229: return result;
 230: }
 231: 
 232: ProcessInstance processInstance = processService.findProcessInstanceDetailById(processInstanceId);
 233: if (processInstance == null) {
 234: putMsg(result, Status.PROCESS_INSTANCE_NOT_EXIST, processInstanceId);
 235: return result;
 236: }
 237: 
 238: ProcessDefinition processDefinition = processService.findProcessDefinition(processInstance.getProcessDefinitionCode(),
 239: processInstance.getProcessDefinitionVersion());
 240: if (executeType != ExecuteType.STOP && executeType != ExecuteType.PAUSE) {
 241: result = checkProcessDefinitionValid(projectCode, processDefinition, processInstance.getProcessDefinitionCode());
 242: if (result.get(Constants.STATUS) != Status.SUCCESS) {
 243: return result;
 244: }
 245: }
 246: 
 247: result = checkExecuteType(processInstance, executeType);
 248: if (result.get(Constants.STATUS) != Status.SUCCESS) {
 249: return result;
 250: }
 251: if (!checkTenantSuitable(processDefinition)) {
 252: logger.error(""there is not any valid tenant for the process definition: id:{},name:{}, "",
 253: processDefinition.getId(), processDefinition.getName());
 254: putMsg(result, Status.TENANT_NOT_SUITABLE);
 255: }
 256: 
 257: //get the startParams user specified at the first starting while repeat running is needed
 258: Map<String, Object> commandMap = JSONUtils.parseObject(processInstance.getCommandParam(), new TypeReference<Map<String, Object>>() {});
 259: String startParams = null;
 260: if (MapUtils.isNotEmpty(commandMap) && executeType == ExecuteType.REPEAT_RUNNING) {
 261: Object startParamsJson = commandMap.get(Constants.CMD_PARAM_START_PARAMS);
 262: if (startParamsJson != null) {
 263: startParams = startParamsJson.toString();
 264: }
 265: }
 266: 
 267: switch (executeType) {
 268: case REPEAT_RUNNING:
 269: result = insertCommand(loginUser, processInstanceId, processDefinition.getCode(), processDefinition.getVersion(), CommandType.REPEAT_RUNNING, startParams);
 270: break;
 271: case RECOVER_SUSPENDED_PROCESS:
 272: result = insertCommand(loginUser, processInstanceId, processDefinition.getCode(), processDefinition.getVersion(), CommandType.RECOVER_SUSPENDED_PROCESS, startParams);
 273: break;
 274: case START_FAILURE_TASK_PROCESS:
 275: result = insertCommand(loginUser, processInstanceId, processDefinition.getCode(), processDefinition.getVersion(), CommandType.START_FAILURE_TASK_PROCESS, startParams);
 276: break;
 277: case STOP:
 278: if (processInstance.getState() == ExecutionStatus.READY_STOP) {
 279: putMsg(result, Status.PROCESS_INSTANCE_ALREADY_CHANGED, processInstance.getName(), processInstance.getState());
 280: } else {
 281: result = updateProcessInstancePrepare(processInstance, CommandType.STOP, ExecutionStatus.READY_STOP);
 282: }
 283: break;
 284: case PAUSE:
 285: if (processInstance.getState() == ExecutionStatus.READY_PAUSE) {
 286: putMsg(result, Status.PROCESS_INSTANCE_ALREADY_CHANGED, processInstance.getName(), processInstance.getState());
 287: } else {
 288: result = updateProcessInstancePrepare(processInstance, CommandType.PAUSE, ExecutionStatus.READY_PAUSE);
 289: }
 290: break;
 291: default:
 292: logger.error(""unknown execute type : {}"", executeType);
 293: putMsg(result, Status.REQUEST_PARAMS_NOT_VALID_ERROR, ""unknown execute type"");
 294: 
 295: break;
 296: }
 297: return result;","public Map<String, Object> execute(User loginUser, long projectCode, Integer processInstanceId, ExecuteType executeType) {
        Project project = projectMapper.queryByCode(projectCode);
        //check user access for project
        Map<String, Object> result = projectService.checkProjectAndAuth(loginUser, project, projectCode);
        if (result.get(Constants.STATUS) != Status.SUCCESS) {
            return result;
        }

        // check master exists
        if (!checkMasterExists(result)) {
            return result;
        }

        ProcessInstance processInstance = processService.findProcessInstanceDetailById(processInstanceId);
        if (processInstance == null) {
            putMsg(result, Status.PROCESS_INSTANCE_NOT_EXIST, processInstanceId);
            return result;
        }

        ProcessDefinition processDefinition = processService.findProcessDefinition(processInstance.getProcessDefinitionCode(),
                processInstance.getProcessDefinitionVersion());
        if (executeType != ExecuteType.STOP && executeType != ExecuteType.PAUSE) {
            result = checkProcessDefinitionValid(projectCode, processDefinition, processInstance.getProcessDefinitionCode());
            if (result.get(Constants.STATUS) != Status.SUCCESS) {
                return result;
            }
        }

        result = checkExecuteType(processInstance, executeType);
        if (result.get(Constants.STATUS) != Status.SUCCESS) {
            return result;
        }
        if (!checkTenantSuitable(processDefinition)) {
            logger.error(""there is not any valid tenant for the process definition: id:{},name:{}, "",
                    processDefinition.getId(), processDefinition.getName());
            putMsg(result, Status.TENANT_NOT_SUITABLE);
        }

        //get the startParams user specified at the first starting while repeat running is needed
        Map<String, Object> commandMap = JSONUtils.parseObject(processInstance.getCommandParam(), new TypeReference<Map<String, Object>>() {});
        String startParams = null;
        if (MapUtils.isNotEmpty(commandMap) && executeType == ExecuteType.REPEAT_RUNNING) {
            Object startParamsJson = commandMap.get(Constants.CMD_PARAM_START_PARAMS);
            if (startParamsJson != null) {
                startParams = startParamsJson.toString();
            }
        }

        switch (executeType) {
            case REPEAT_RUNNING:
                result = insertCommand(loginUser, processInstanceId, processDefinition.getCode(), processDefinition.getVersion(), CommandType.REPEAT_RUNNING, startParams);
                break;
            case RECOVER_SUSPENDED_PROCESS:
                result = insertCommand(loginUser, processInstanceId, processDefinition.getCode(), processDefinition.getVersion(), CommandType.RECOVER_SUSPENDED_PROCESS, startParams);
                break;
            case START_FAILURE_TASK_PROCESS:
                result = insertCommand(loginUser, processInstanceId, processDefinition.getCode(), processDefinition.getVersion(), CommandType.START_FAILURE_TASK_PROCESS, startParams);
                break;
            case STOP:
                if (processInstance.getState() == ExecutionStatus.READY_STOP) {
                    putMsg(result, Status.PROCESS_INSTANCE_ALREADY_CHANGED, processInstance.getName(), processInstance.getState());
                } else {
                    result = updateProcessInstancePrepare(processInstance, CommandType.STOP, ExecutionStatus.READY_STOP);
                }
                break;
            case PAUSE:
                if (processInstance.getState() == ExecutionStatus.READY_PAUSE) {
                    putMsg(result, Status.PROCESS_INSTANCE_ALREADY_CHANGED, processInstance.getName(), processInstance.getState());
                } else {
                    result = updateProcessInstancePrepare(processInstance, CommandType.PAUSE, ExecutionStatus.READY_PAUSE);
                }
                break;
            default:
                logger.error(""unknown execute type : {}"", executeType);
                putMsg(result, Status.REQUEST_PARAMS_NOT_VALID_ERROR, ""unknown execute type"");

                break;
        }
        return result;
    }
",0
dolphinscheduler-2.0.9,NULL_DEREFERENCE,dolphinscheduler-dao/src/main/java/org/apache/dolphinscheduler/dao/upgrade/UpgradeDao.java,org.apache.dolphinscheduler.dao.upgrade.UpgradeDao.updateProcessDefinitionJsonResourceList():void,234,object `jsonObject` last assigned on line 233 could be null and is dereferenced at line 234.,https://github.com/apache/dolphinscheduler/blob/2.0.9-release/dolphinscheduler-dao/src/main/java/org/apache/dolphinscheduler/dao/upgrade/UpgradeDao.java,"protected void updateProcessDefinitionJsonResourceList() {
        ResourceDao resourceDao = new ResourceDao();
        ProcessDefinitionDao processDefinitionDao = new ProcessDefinitionDao();
        Map<Integer, String> replaceProcessDefinitionMap = new HashMap<>();
        try {
            Map<String, Integer> resourcesMap = resourceDao.listAllResources(dataSource.getConnection());
            Map<Integer, String> processDefinitionJsonMap = processDefinitionDao.queryAllProcessDefinition(dataSource.getConnection());

            for (Map.Entry<Integer, String> entry : processDefinitionJsonMap.entrySet()) {
                ObjectNode jsonObject = JSONUtils.parseObject(entry.getValue());
                ArrayNode tasks = JSONUtils.parseArray(jsonObject.get(""tasks"").toString());

                for (int i = 0; i < tasks.size(); i++) {
                    ObjectNode task = (ObjectNode) tasks.get(i);
                    ObjectNode param = (ObjectNode) task.get(""params"");
                    if (param != null) {

                        List<ResourceInfo> resourceList = JSONUtils.toList(param.get(""resourceList"").toString(), ResourceInfo.class);
                        ResourceInfo mainJar = JSONUtils.parseObject(param.get(""mainJar"").toString(), ResourceInfo.class);
                        if (mainJar != null && mainJar.getId() == 0) {
                            String fullName = mainJar.getRes().startsWith(""/"") ? mainJar.getRes() : String.format(""/%s"", mainJar.getRes());
                            if (resourcesMap.containsKey(fullName)) {
                                mainJar.setId(resourcesMap.get(fullName));
                                param.put(""mainJar"", JSONUtils.parseObject(JSONUtils.toJsonString(mainJar)));
                            }
                        }

                        if (CollectionUtils.isNotEmpty(resourceList)) {
                            List<ResourceInfo> newResourceList = resourceList.stream().map(resInfo -> {
                                String fullName = resInfo.getRes().startsWith(""/"") ? resInfo.getRes() : String.format(""/%s"", resInfo.getRes());
                                if (resInfo.getId() == 0 && resourcesMap.containsKey(fullName)) {
                                    resInfo.setId(resourcesMap.get(fullName));
                                }
                                return resInfo;
                            }).collect(Collectors.toList());
                            param.put(""resourceList"", JSONUtils.parseObject(JSONUtils.toJsonString(newResourceList)));
                        }
                    }
                    task.put(""params"", param);

                }

                jsonObject.remove(""tasks"");

                jsonObject.put(""tasks"", tasks);

                replaceProcessDefinitionMap.put(entry.getKey(), jsonObject.toString());
            }
            if (replaceProcessDefinitionMap.size() > 0) {
                processDefinitionDao.updateProcessDefinitionJson(dataSource.getConnection(), replaceProcessDefinitionMap);
            }
        } catch (Exception e) {
            logger.error(""update process definition json resource list error"", e);
        }

    }",1
dolphinscheduler-2.0.9,NULL_DEREFERENCE,dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/impl/DataSourceServiceImpl.java,org.apache.dolphinscheduler.api.service.impl.DataSourceServiceImpl.handlePasswd(java.util.ArrayList):void,251,object `object` last assigned on line 250 could be null and is dereferenced at line 251.,https://github.com/apache/dolphinscheduler/blob/2.0.9-release/dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/impl/DataSourceServiceImpl.java,"private void handlePasswd(List<DataSource> dataSourceList) {
        for (DataSource dataSource : dataSourceList) {
            String connectionParams = dataSource.getConnectionParams();
            ObjectNode object = JSONUtils.parseObject(connectionParams);
            object.put(Constants.PASSWORD, getHiddenPassword());
            dataSource.setConnectionParams(object.toString());
        }
    }",1
dolphinscheduler-2.0.9,NULL_DEREFERENCE,dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/impl/WorkerGroupServiceImpl.java,org.apache.dolphinscheduler.api.service.impl.WorkerGroupServiceImpl.getWorkerGroups(boolean):java.util.List,291,object `heartBeat` last assigned on line 290 could be null and is dereferenced at line 291.,"253: private List<WorkerGroup> getWorkerGroups(boolean isPaging) {
 254: // worker groups from database
 255: List<WorkerGroup> workerGroups = workerGroupMapper.queryAllWorkerGroup();
 256: // worker groups from zookeeper
 257: String workerPath = Constants.REGISTRY_DOLPHINSCHEDULER_WORKERS;
 258: Collection<String> workerGroupList = null;
 259: try {
 260: workerGroupList = registryClient.getChildrenKeys(workerPath);
 261: } catch (Exception e) {
 262: logger.error(""getWorkerGroups exception, workerPath: {}, isPaging: {}"", workerPath, isPaging, e);
 263: }
 264: 
 265: if (CollectionUtils.isEmpty(workerGroupList)) {
 266: if (CollectionUtils.isEmpty(workerGroups) && !isPaging) {
 267: WorkerGroup wg = new WorkerGroup();
 268: wg.setName(Constants.DEFAULT_WORKER_GROUP);
 269: workerGroups.add(wg);
 270: }
 271: return workerGroups;
 272: }
 273: 
 274: for (String workerGroup : workerGroupList) {
 275: String workerGroupPath = workerPath + Constants.SINGLE_SLASH + workerGroup;
 276: Collection<String> childrenNodes = null;
 277: try {
 278: childrenNodes = registryClient.getChildrenKeys(workerGroupPath);
 279: } catch (Exception e) {
 280: logger.error(""getChildrenNodes exception: {}, workerGroupPath: {}"", e.getMessage(), workerGroupPath);
 281: }
 282: if (childrenNodes == null || childrenNodes.isEmpty()) {
 283: continue;
 284: }
 285: WorkerGroup wg = new WorkerGroup();
 286: wg.setName(workerGroup);
 287: if (isPaging) {
 288: wg.setAddrList(String.join(Constants.COMMA, childrenNodes));
 289: String registeredValue = registryClient.get(workerGroupPath + Constants.SINGLE_SLASH + childrenNodes.iterator().next());
 290: HeartBeat heartBeat = HeartBeat.decodeHeartBeat(registeredValue);
 291: wg.setCreateTime(new Date(heartBeat.getStartupTime()));
 292: wg.setUpdateTime(new Date(heartBeat.getReportTime()));
 293: wg.setSystemDefault(true);
 294: }
 295: workerGroups.add(wg);
 296: }
 297: return workerGroups;","private List<WorkerGroup> getWorkerGroups(boolean isPaging) {
        // worker groups from database
        List<WorkerGroup> workerGroups = workerGroupMapper.queryAllWorkerGroup();
        // worker groups from zookeeper
        String workerPath = Constants.REGISTRY_DOLPHINSCHEDULER_WORKERS;
        Collection<String> workerGroupList = null;
        try {
            workerGroupList = registryClient.getChildrenKeys(workerPath);
        } catch (Exception e) {
            logger.error(""getWorkerGroups exception, workerPath: {}, isPaging: {}"", workerPath, isPaging, e);
        }

        if (CollectionUtils.isEmpty(workerGroupList)) {
            if (CollectionUtils.isEmpty(workerGroups) && !isPaging) {
                WorkerGroup wg = new WorkerGroup();
                wg.setName(Constants.DEFAULT_WORKER_GROUP);
                workerGroups.add(wg);
            }
            return workerGroups;
        }

        for (String workerGroup : workerGroupList) {
            String workerGroupPath = workerPath + Constants.SINGLE_SLASH + workerGroup;
            Collection<String> childrenNodes = null;
            try {
                childrenNodes = registryClient.getChildrenKeys(workerGroupPath);
            } catch (Exception e) {
                logger.error(""getChildrenNodes exception: {}, workerGroupPath: {}"", e.getMessage(), workerGroupPath);
            }
            if (childrenNodes == null || childrenNodes.isEmpty()) {
                continue;
            }
            WorkerGroup wg = new WorkerGroup();
            wg.setName(workerGroup);
            if (isPaging) {
                wg.setAddrList(String.join(Constants.COMMA, childrenNodes));
                String registeredValue = registryClient.get(workerGroupPath + Constants.SINGLE_SLASH + childrenNodes.iterator().next());
                HeartBeat heartBeat = HeartBeat.decodeHeartBeat(registeredValue);
                wg.setCreateTime(new Date(heartBeat.getStartupTime()));
                wg.setUpdateTime(new Date(heartBeat.getReportTime()));
                wg.setSystemDefault(true);
            }
            workerGroups.add(wg);
        }
        return workerGroups;
    }",0
dolphinscheduler-2.0.9,NULL_DEREFERENCE,dolphinscheduler-dao/src/main/java/org/apache/dolphinscheduler/dao/entity/TaskDefinition.java,org.apache.dolphinscheduler.dao.entity.TaskDefinition.getTaskParamList():java.util.List,278,object returned by `parseObject(TaskDefinition.taskParams)` could be null and is dereferenced at line 278.,"277: public List<Property> getTaskParamList() {
 278: JsonNode localParams = JSONUtils.parseObject(taskParams).findValue(""localParams"");
 279: if (localParams != null) {
 280: taskParamList = JSONUtils.toList(localParams.toString(), Property.class);
 281: }
 282: 
 283: return taskParamList;","public List<Property> getTaskParamList() {
        JsonNode localParams = JSONUtils.parseObject(taskParams).findValue(""localParams"");
        if (localParams != null) {
            taskParamList = JSONUtils.toList(localParams.toString(), Property.class);
        }

        return taskParamList;
    }",1
dolphinscheduler-2.0.9,NULL_DEREFERENCE,dolphinscheduler-dao/src/main/java/org/apache/dolphinscheduler/dao/entity/TaskDefinition.java,org.apache.dolphinscheduler.dao.entity.TaskDefinition.getTaskParamMap():java.util.Map,296,object returned by `parseObject(TaskDefinition.taskParams)` could be null and is dereferenced at line 296.,"294: public Map<String, String> getTaskParamMap() {
 295: if (taskParamMap == null && StringUtils.isNotEmpty(taskParams)) {
 296: JsonNode localParams = JSONUtils.parseObject(taskParams).findValue(""localParams"");
 297: if (localParams != null && localParams.size() > 0) {
 298: List<Property> propList = JSONUtils.toList(localParams.toString(), Property.class);
 299: taskParamMap = propList.stream().collect(Collectors.toMap(Property::getProp, Property::getValue));
 300: }
 301: }
 302: return taskParamMap;","public Map<String, String> getTaskParamMap() {
        if (taskParamMap == null && StringUtils.isNotEmpty(taskParams)) {
            JsonNode localParams = JSONUtils.parseObject(taskParams).findValue(""localParams"");
            if (localParams != null && localParams.size() > 0) {
                List<Property> propList = JSONUtils.toList(localParams.toString(), Property.class);
                taskParamMap = propList.stream().collect(Collectors.toMap(Property::getProp, Property::getValue));
            }
        }
        return taskParamMap;
    }",1
dolphinscheduler-2.0.9,NULL_DEREFERENCE,dolphinscheduler-service/src/main/java/org/apache/dolphinscheduler/service/process/ProcessService.java,org.apache.dolphinscheduler.service.process.ProcessService.verifyIsNeedCreateCommand(org.apache.dolphinscheduler.dao.entity.Command):boolean,304,object `cmdParamObj` last assigned on line 303 could be null and is dereferenced at line 304.,"294: public boolean verifyIsNeedCreateCommand(Command command) {
 295: boolean isNeedCreate = true;
 296: EnumMap<CommandType, Integer> cmdTypeMap = new EnumMap<>(CommandType.class);
 297: cmdTypeMap.put(CommandType.REPEAT_RUNNING, 1);
 298: cmdTypeMap.put(CommandType.RECOVER_SUSPENDED_PROCESS, 1);
 299: cmdTypeMap.put(CommandType.START_FAILURE_TASK_PROCESS, 1);
 300: CommandType commandType = command.getCommandType();
 301: 
 302: if (cmdTypeMap.containsKey(commandType)) {
 303: ObjectNode cmdParamObj = JSONUtils.parseObject(command.getCommandParam());
 304: int processInstanceId = cmdParamObj.path(CMD_PARAM_RECOVER_PROCESS_ID_STRING).asInt();
 305: 
 306: List<Command> commands = commandMapper.selectList(null);
 307: // for all commands
 308: for (Command tmpCommand : commands) {
 309: if (cmdTypeMap.containsKey(tmpCommand.getCommandType())) {
 310: ObjectNode tempObj = JSONUtils.parseObject(tmpCommand.getCommandParam());
 311: if (tempObj != null && processInstanceId == tempObj.path(CMD_PARAM_RECOVER_PROCESS_ID_STRING).asInt()) {
 312: isNeedCreate = false;
 313: break;
 314: }
 315: }
 316: }
 317: }
 318: return isNeedCreate;","public boolean verifyIsNeedCreateCommand(Command command) {
        boolean isNeedCreate = true;
        EnumMap<CommandType, Integer> cmdTypeMap = new EnumMap<>(CommandType.class);
        cmdTypeMap.put(CommandType.REPEAT_RUNNING, 1);
        cmdTypeMap.put(CommandType.RECOVER_SUSPENDED_PROCESS, 1);
        cmdTypeMap.put(CommandType.START_FAILURE_TASK_PROCESS, 1);
        CommandType commandType = command.getCommandType();

        if (cmdTypeMap.containsKey(commandType)) {
            ObjectNode cmdParamObj = JSONUtils.parseObject(command.getCommandParam());
            int processInstanceId = cmdParamObj.path(CMD_PARAM_RECOVER_PROCESS_ID_STRING).asInt();

            List<Command> commands = commandMapper.selectList(null);
            // for all commands
            for (Command tmpCommand : commands) {
                if (cmdTypeMap.containsKey(tmpCommand.getCommandType())) {
                    ObjectNode tempObj = JSONUtils.parseObject(tmpCommand.getCommandParam());
                    if (tempObj != null && processInstanceId == tempObj.path(CMD_PARAM_RECOVER_PROCESS_ID_STRING).asInt()) {
                        isNeedCreate = false;
                        break;
                    }
                }
            }
        }
        return isNeedCreate;
    }",1
dolphinscheduler-2.0.9,NULL_DEREFERENCE,dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/master/runner/task/BaseTaskProcessor.java,"org.apache.dolphinscheduler.server.master.runner.task.BaseTaskProcessor.setProcedureTaskRelation(org.apache.dolphinscheduler.spi.task.request.ProcedureTaskExecutionContext,org.apache.dolphinscheduler.dao.entity.TaskInstance):void",310,object `procedureParameters` last assigned on line 309 could be null and is dereferenced at line 310.,https://github.com/apache/dolphinscheduler/blob/2.0.9-release/dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/master/runner/task/BaseTaskProcessor.java,"private void setProcedureTaskRelation(ProcedureTaskExecutionContext procedureTaskExecutionContext, TaskInstance taskInstance) {
        ProcedureParameters procedureParameters = JSONUtils.parseObject(taskInstance.getTaskParams(), ProcedureParameters.class);
        int datasourceId = procedureParameters.getDatasource();
        DataSource datasource = processService.findDataSourceById(datasourceId);
        procedureTaskExecutionContext.setConnectionParams(datasource.getConnectionParams());
    }",1
dolphinscheduler-2.0.9,NULL_DEREFERENCE,dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/master/runner/task/BaseTaskProcessor.java,"org.apache.dolphinscheduler.server.master.runner.task.BaseTaskProcessor.setDataxTaskRelation(org.apache.dolphinscheduler.spi.task.request.DataxTaskExecutionContext,org.apache.dolphinscheduler.dao.entity.TaskInstance):void",324,object `dataxParameters` last assigned on line 322 could be null and is dereferenced at line 324.,https://github.com/apache/dolphinscheduler/blob/2.0.9-release/dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/master/runner/task/BaseTaskProcessor.java,"protected void setDataxTaskRelation(DataxTaskExecutionContext dataxTaskExecutionContext, TaskInstance taskInstance) {
        DataxParameters dataxParameters = JSONUtils.parseObject(taskInstance.getTaskParams(), DataxParameters.class);

        DataSource dbSource = processService.findDataSourceById(dataxParameters.getDataSource());
        DataSource dbTarget = processService.findDataSourceById(dataxParameters.getDataTarget());

        if (dbSource != null) {
            dataxTaskExecutionContext.setDataSourceId(dataxParameters.getDataSource());
            dataxTaskExecutionContext.setSourcetype(dbSource.getType().getCode());
            dataxTaskExecutionContext.setSourceConnectionParams(dbSource.getConnectionParams());
        }

        if (dbTarget != null) {
            dataxTaskExecutionContext.setDataTargetId(dataxParameters.getDataTarget());
            dataxTaskExecutionContext.setTargetType(dbTarget.getType().getCode());
            dataxTaskExecutionContext.setTargetConnectionParams(dbTarget.getConnectionParams());
        }
    }",1
dolphinscheduler-2.0.9,NULL_DEREFERENCE,dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/master/runner/task/BaseTaskProcessor.java,"org.apache.dolphinscheduler.server.master.runner.task.BaseTaskProcessor.setSqoopTaskRelation(org.apache.dolphinscheduler.spi.task.request.SqoopTaskExecutionContext,org.apache.dolphinscheduler.dao.entity.TaskInstance):void",354,object `sourceMysqlParameter` last assigned on line 351 could be null and is dereferenced at line 354.,https://github.com/apache/dolphinscheduler/blob/2.0.9-release/dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/master/runner/task/BaseTaskProcessor.java,"private void setSqoopTaskRelation(SqoopTaskExecutionContext sqoopTaskExecutionContext, TaskInstance taskInstance) {
        SqoopParameters sqoopParameters = JSONUtils.parseObject(taskInstance.getTaskParams(), SqoopParameters.class);

        // sqoop job type is template set task relation
        if (sqoopParameters.getJobType().equals(SqoopJobType.TEMPLATE.getDescp())) {
            SourceMysqlParameter sourceMysqlParameter = JSONUtils.parseObject(sqoopParameters.getSourceParams(), SourceMysqlParameter.class);
            TargetMysqlParameter targetMysqlParameter = JSONUtils.parseObject(sqoopParameters.getTargetParams(), TargetMysqlParameter.class);

            DataSource dataSource = processService.findDataSourceById(sourceMysqlParameter.getSrcDatasource());
            DataSource dataTarget = processService.findDataSourceById(targetMysqlParameter.getTargetDatasource());

            if (dataSource != null) {
                sqoopTaskExecutionContext.setDataSourceId(dataSource.getId());
                sqoopTaskExecutionContext.setSourcetype(dataSource.getType().getCode());
                sqoopTaskExecutionContext.setSourceConnectionParams(dataSource.getConnectionParams());
            }

            if (dataTarget != null) {
                sqoopTaskExecutionContext.setDataTargetId(dataTarget.getId());
                sqoopTaskExecutionContext.setTargetType(dataTarget.getType().getCode());
                sqoopTaskExecutionContext.setTargetConnectionParams(dataTarget.getConnectionParams());
            }
        }
    }",1
dolphinscheduler-2.0.9,NULL_DEREFERENCE,dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/master/runner/task/BaseTaskProcessor.java,"org.apache.dolphinscheduler.server.master.runner.task.BaseTaskProcessor.setSqoopTaskRelation(org.apache.dolphinscheduler.spi.task.request.SqoopTaskExecutionContext,org.apache.dolphinscheduler.dao.entity.TaskInstance):void",350,object `sqoopParameters` last assigned on line 347 could be null and is dereferenced at line 350.,https://github.com/apache/dolphinscheduler/blob/2.0.9-release/dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/master/runner/task/BaseTaskProcessor.java,"private void setSqoopTaskRelation(SqoopTaskExecutionContext sqoopTaskExecutionContext, TaskInstance taskInstance) {
        SqoopParameters sqoopParameters = JSONUtils.parseObject(taskInstance.getTaskParams(), SqoopParameters.class);

        // sqoop job type is template set task relation
        if (sqoopParameters.getJobType().equals(SqoopJobType.TEMPLATE.getDescp())) {
            SourceMysqlParameter sourceMysqlParameter = JSONUtils.parseObject(sqoopParameters.getSourceParams(), SourceMysqlParameter.class);
            TargetMysqlParameter targetMysqlParameter = JSONUtils.parseObject(sqoopParameters.getTargetParams(), TargetMysqlParameter.class);

            DataSource dataSource = processService.findDataSourceById(sourceMysqlParameter.getSrcDatasource());
            DataSource dataTarget = processService.findDataSourceById(targetMysqlParameter.getTargetDatasource());

            if (dataSource != null) {
                sqoopTaskExecutionContext.setDataSourceId(dataSource.getId());
                sqoopTaskExecutionContext.setSourcetype(dataSource.getType().getCode());
                sqoopTaskExecutionContext.setSourceConnectionParams(dataSource.getConnectionParams());
            }

            if (dataTarget != null) {
                sqoopTaskExecutionContext.setDataTargetId(dataTarget.getId());
                sqoopTaskExecutionContext.setTargetType(dataTarget.getType().getCode());
                sqoopTaskExecutionContext.setTargetConnectionParams(dataTarget.getConnectionParams());
            }
        }
    }",1
dolphinscheduler-2.0.9,NULL_DEREFERENCE,dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/master/runner/task/BaseTaskProcessor.java,"org.apache.dolphinscheduler.server.master.runner.task.BaseTaskProcessor.setSqoopTaskRelation(org.apache.dolphinscheduler.spi.task.request.SqoopTaskExecutionContext,org.apache.dolphinscheduler.dao.entity.TaskInstance):void",355,object `targetMysqlParameter` last assigned on line 352 could be null and is dereferenced at line 355.,https://github.com/apache/dolphinscheduler/blob/2.0.9-release/dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/master/runner/task/BaseTaskProcessor.java,"private void setSqoopTaskRelation(SqoopTaskExecutionContext sqoopTaskExecutionContext, TaskInstance taskInstance) {
        SqoopParameters sqoopParameters = JSONUtils.parseObject(taskInstance.getTaskParams(), SqoopParameters.class);

        // sqoop job type is template set task relation
        if (sqoopParameters.getJobType().equals(SqoopJobType.TEMPLATE.getDescp())) {
            SourceMysqlParameter sourceMysqlParameter = JSONUtils.parseObject(sqoopParameters.getSourceParams(), SourceMysqlParameter.class);
            TargetMysqlParameter targetMysqlParameter = JSONUtils.parseObject(sqoopParameters.getTargetParams(), TargetMysqlParameter.class);

            DataSource dataSource = processService.findDataSourceById(sourceMysqlParameter.getSrcDatasource());
            DataSource dataTarget = processService.findDataSourceById(targetMysqlParameter.getTargetDatasource());

            if (dataSource != null) {
                sqoopTaskExecutionContext.setDataSourceId(dataSource.getId());
                sqoopTaskExecutionContext.setSourcetype(dataSource.getType().getCode());
                sqoopTaskExecutionContext.setSourceConnectionParams(dataSource.getConnectionParams());
            }

            if (dataTarget != null) {
                sqoopTaskExecutionContext.setDataTargetId(dataTarget.getId());
                sqoopTaskExecutionContext.setTargetType(dataTarget.getType().getCode());
                sqoopTaskExecutionContext.setTargetConnectionParams(dataTarget.getConnectionParams());
            }
        }
    }",1
dolphinscheduler-2.0.9,NULL_DEREFERENCE,dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/master/runner/task/BaseTaskProcessor.java,"org.apache.dolphinscheduler.server.master.runner.task.BaseTaskProcessor.setSQLTaskRelation(org.apache.dolphinscheduler.spi.task.request.SQLTaskExecutionContext,org.apache.dolphinscheduler.dao.entity.TaskInstance):void",379,object `sqlParameters` last assigned on line 378 could be null and is dereferenced at line 379.,https://github.com/apache/dolphinscheduler/blob/2.0.9-release/dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/master/runner/task/BaseTaskProcessor.java,"private void setSQLTaskRelation(SQLTaskExecutionContext sqlTaskExecutionContext, TaskInstance taskInstance) {
        SqlParameters sqlParameters = JSONUtils.parseObject(taskInstance.getTaskParams(), SqlParameters.class);
        int datasourceId = sqlParameters.getDatasource();
        DataSource datasource = processService.findDataSourceById(datasourceId);
        sqlTaskExecutionContext.setConnectionParams(datasource.getConnectionParams());

        sqlTaskExecutionContext.setDefaultFS(HadoopUtils.getInstance().getDefaultFS());

        // whether udf type
        boolean udfTypeFlag = Enums.getIfPresent(UdfType.class, Strings.nullToEmpty(sqlParameters.getType())).isPresent()
                && !StringUtils.isEmpty(sqlParameters.getUdfs());

        if (udfTypeFlag) {
            String[] udfFunIds = sqlParameters.getUdfs().split("","");
            int[] udfFunIdsArray = new int[udfFunIds.length];
            for (int i = 0; i < udfFunIds.length; i++) {
                udfFunIdsArray[i] = Integer.parseInt(udfFunIds[i]);
            }

            List<UdfFunc> udfFuncList = processService.queryUdfFunListByIds(udfFunIdsArray);
            UdfFuncRequest udfFuncRequest;
            Map<UdfFuncRequest, String> udfFuncRequestMap = new HashMap<>();
            for (UdfFunc udfFunc : udfFuncList) {
                udfFuncRequest = JSONUtils.parseObject(JSONUtils.toJsonString(udfFunc), UdfFuncRequest.class);
                String tenantCode = processService.queryTenantCodeByResName(udfFunc.getResourceName(), ResourceType.UDF);
                udfFuncRequestMap.put(udfFuncRequest, tenantCode);
            }
            sqlTaskExecutionContext.setUdfFuncTenantCodeMap(udfFuncRequestMap);
        }
    }",1
dolphinscheduler-2.0.9,NULL_DEREFERENCE,dolphinscheduler-common/src/main/java/org/apache/dolphinscheduler/common/utils/HadoopUtils.java,org.apache.dolphinscheduler.common.utils.HadoopUtils.getApplicationStatus(java.lang.String):org.apache.dolphinscheduler.common.enums.ExecutionStatus,446,object `jsonObject` last assigned on line 445 could be null and is dereferenced at line 446.,"417: public ExecutionStatus getApplicationStatus(String applicationId) throws Exception {
 418: if (StringUtils.isEmpty(applicationId)) {
 419: return null;
 420: }
 421: 
 422: String result = Constants.FAILED;
 423: String applicationUrl = getApplicationUrl(applicationId);
 424: if (logger.isDebugEnabled()) {
 425: logger.debug(""generate yarn application url, applicationUrl={}"", applicationUrl);
 426: }
 427: 
 428: String responseContent = PropertyUtils.getBoolean(Constants.HADOOP_SECURITY_AUTHENTICATION_STARTUP_STATE, false) ? KerberosHttpClient.get(applicationUrl) : HttpUtils.get(applicationUrl);
 429: if (responseContent != null) {
 430: ObjectNode jsonObject = JSONUtils.parseObject(responseContent);
 431: if (!jsonObject.has(""app"")) {
 432: return ExecutionStatus.FAILURE;
 433: }
 434: result = jsonObject.path(""app"").path(""finalStatus"").asText();
 435: 
 436: } else {
 437: //may be in job history
 438: String jobHistoryUrl = getJobHistoryUrl(applicationId);
 439: if (logger.isDebugEnabled()) {
 440: logger.debug(""generate yarn job history application url, jobHistoryUrl={}"", jobHistoryUrl);
 441: }
 442: responseContent = PropertyUtils.getBoolean(Constants.HADOOP_SECURITY_AUTHENTICATION_STARTUP_STATE, false) ? KerberosHttpClient.get(jobHistoryUrl) : HttpUtils.get(jobHistoryUrl);
 443: 
 444: if (null != responseContent) {
 445: ObjectNode jsonObject = JSONUtils.parseObject(responseContent);
 446: if (!jsonObject.has(""job"")) {
 447: return ExecutionStatus.FAILURE;
 448: }
 449: result = jsonObject.path(""job"").path(""state"").asText();
 450: } else {
 451: return ExecutionStatus.FAILURE;
 452: }
 453: }
 454: 
 455: switch (result) {","public ExecutionStatus getApplicationStatus(String applicationId) throws Exception {
        if (StringUtils.isEmpty(applicationId)) {
            return null;
        }

        String result = Constants.FAILED;
        String applicationUrl = getApplicationUrl(applicationId);
        if (logger.isDebugEnabled()) {
            logger.debug(""generate yarn application url, applicationUrl={}"", applicationUrl);
        }

        String responseContent = PropertyUtils.getBoolean(Constants.HADOOP_SECURITY_AUTHENTICATION_STARTUP_STATE, false) ? KerberosHttpClient.get(applicationUrl) : HttpUtils.get(applicationUrl);
        if (responseContent != null) {
            ObjectNode jsonObject = JSONUtils.parseObject(responseContent);
            if (!jsonObject.has(""app"")) {
                return ExecutionStatus.FAILURE;
            }
            result = jsonObject.path(""app"").path(""finalStatus"").asText();

        } else {
            //may be in job history
            String jobHistoryUrl = getJobHistoryUrl(applicationId);
            if (logger.isDebugEnabled()) {
                logger.debug(""generate yarn job history application url, jobHistoryUrl={}"", jobHistoryUrl);
            }
            responseContent = PropertyUtils.getBoolean(Constants.HADOOP_SECURITY_AUTHENTICATION_STARTUP_STATE, false) ? KerberosHttpClient.get(jobHistoryUrl) : HttpUtils.get(jobHistoryUrl);

            if (null != responseContent) {
                ObjectNode jsonObject = JSONUtils.parseObject(responseContent);
                if (!jsonObject.has(""job"")) {
                    return ExecutionStatus.FAILURE;
                }
                result = jsonObject.path(""job"").path(""state"").asText();
            } else {
                return ExecutionStatus.FAILURE;
            }
        }

        switch (result) {
            case Constants.ACCEPTED:
                return ExecutionStatus.SUBMITTED_SUCCESS;
            case Constants.SUCCEEDED:
            case Constants.ENDED:
                return ExecutionStatus.SUCCESS;
            case Constants.NEW:
            case Constants.NEW_SAVING:
            case Constants.SUBMITTED:
            case Constants.FAILED:
                return ExecutionStatus.FAILURE;
            case Constants.KILLED:
                return ExecutionStatus.KILL;

            case Constants.RUNNING:
            default:
                return ExecutionStatus.RUNNING_EXECUTION;
        }
    }
",0
dolphinscheduler-2.0.9,NULL_DEREFERENCE,dolphinscheduler-dao/src/main/java/org/apache/dolphinscheduler/dao/upgrade/UpgradeDao.java,"org.apache.dolphinscheduler.dao.upgrade.UpgradeDao.splitProcessDefinitionJson(java.util.List,java.util.HashMap,java.util.ArrayList,java.util.ArrayList,java.util.ArrayList,java.util.HashMap):void",460,object `jsonObject` last assigned on line 457 could be null and is dereferenced at line 460.,https://github.com/apache/dolphinscheduler/blob/2.0.9-release/dolphinscheduler-dao/src/main/java/org/apache/dolphinscheduler/dao/upgrade/UpgradeDao.java,"private void splitProcessDefinitionJson(List<ProcessDefinition> processDefinitions,
                                            Map<Integer, String> processDefinitionJsonMap,
                                            List<ProcessDefinitionLog> processDefinitionLogs,
                                            List<ProcessTaskRelationLog> processTaskRelationLogs,
                                            List<TaskDefinitionLog> taskDefinitionLogs,
                                            Map<Integer, Map<Long, Map<String, Long>>> processTaskMap) throws Exception {
        Map<Integer, ProcessDefinition> processDefinitionMap = processDefinitions.stream()
                                                                                 .collect(Collectors.toMap(ProcessDefinition::getId, processDefinition -> processDefinition));
        Date now = new Date();
        for (Map.Entry<Integer, String> entry : processDefinitionJsonMap.entrySet()) {
            if (entry.getValue() == null) {
                throw new Exception(""processDefinitionJson is null"");
            }
            ObjectNode jsonObject = JSONUtils.parseObject(entry.getValue());
            ProcessDefinition processDefinition = processDefinitionMap.get(entry.getKey());
            if (processDefinition != null) {
                processDefinition.setTenantId(jsonObject.get(""tenantId"") == null ? -1 : jsonObject.get(""tenantId"").asInt());
                processDefinition.setTimeout(jsonObject.get(""timeout"").asInt());
                processDefinition.setGlobalParams(jsonObject.get(""globalParams"").toString());
            } else {
                throw new Exception(""It can't find processDefinition, please check !"");
            }
            Map<String, Long> taskIdCodeMap = new HashMap<>();
            Map<String, List<String>> taskNamePreMap = new HashMap<>();
            Map<String, Long> taskNameCodeMap = new HashMap<>();
            Map<Long, Map<String, Long>> processCodeTaskNameCodeMap = new HashMap<>();
            List<TaskDefinitionLog> taskDefinitionLogList = new ArrayList<>();
            ArrayNode tasks = JSONUtils.parseArray(jsonObject.get(""tasks"").toString());
            for (int i = 0; i < tasks.size(); i++) {
                ObjectNode task = (ObjectNode) tasks.path(i);
                ObjectNode param = (ObjectNode) task.get(""params"");
                TaskDefinitionLog taskDefinitionLog = new TaskDefinitionLog();
                String taskType = task.get(""type"").asText();
                if (param != null) {
                    JsonNode resourceJsonNode = param.get(""resourceList"");
                    if (resourceJsonNode != null && !resourceJsonNode.isEmpty()) {
                        List<ResourceInfo> resourceList = JSONUtils.toList(param.get(""resourceList"").toString(), ResourceInfo.class);
                        List<Integer> resourceIds = resourceList.stream().map(ResourceInfo::getId).collect(Collectors.toList());
                        taskDefinitionLog.setResourceIds(StringUtils.join(resourceIds, Constants.COMMA));
                    } else {
                        taskDefinitionLog.setResourceIds(StringUtils.EMPTY);
                    }
                    if (TaskType.SUB_PROCESS.getDesc().equals(taskType)) {
                        JsonNode jsonNodeDefinitionId = param.get(""processDefinitionId"");
                        if (jsonNodeDefinitionId != null) {
                            param.put(""processDefinitionCode"", processDefinitionMap.get(jsonNodeDefinitionId.asInt()).getCode());
                            param.remove(""processDefinitionId"");
                        }
                    }
                    param.put(""conditionResult"", task.get(""conditionResult""));
                    param.put(""dependence"", task.get(""dependence""));
                    taskDefinitionLog.setTaskParams(JSONUtils.toJsonString(param));
                }
                TaskTimeoutParameter timeout = JSONUtils.parseObject(JSONUtils.toJsonString(task.get(""timeout"")), TaskTimeoutParameter.class);
                if (timeout != null) {
                    taskDefinitionLog.setTimeout(timeout.getInterval());
                    taskDefinitionLog.setTimeoutFlag(timeout.getEnable() ? TimeoutFlag.OPEN : TimeoutFlag.CLOSE);
                    taskDefinitionLog.setTimeoutNotifyStrategy(timeout.getStrategy());
                }
                String desc = task.get(""description"") != null ? task.get(""description"").asText() :
                    task.get(""desc"") != null ? task.get(""desc"").asText() : """";
                taskDefinitionLog.setDescription(desc);
                taskDefinitionLog.setFlag(Constants.FLOWNODE_RUN_FLAG_NORMAL.equals(task.get(""runFlag"").asText()) ? Flag.YES : Flag.NO);
                taskDefinitionLog.setTaskType(taskType);
                taskDefinitionLog.setFailRetryInterval(TaskType.SUB_PROCESS.getDesc().equals(taskType) ? 1 : task.get(""retryInterval"").asInt());
                taskDefinitionLog.setFailRetryTimes(TaskType.SUB_PROCESS.getDesc().equals(taskType) ? 0 : task.get(""maxRetryTimes"").asInt());
                taskDefinitionLog.setTaskPriority(JSONUtils.parseObject(JSONUtils.toJsonString(task.get(""taskInstancePriority"")), Priority.class));
                String name = task.get(""name"").asText();
                taskDefinitionLog.setName(name);
                taskDefinitionLog.setWorkerGroup(task.get(""workerGroup"") == null ? ""default"" : task.get(""workerGroup"").asText());
                long taskCode = CodeGenerateUtils.getInstance().genCode();
                taskDefinitionLog.setCode(taskCode);
                taskDefinitionLog.setVersion(Constants.VERSION_FIRST);
                taskDefinitionLog.setProjectCode(processDefinition.getProjectCode());
                taskDefinitionLog.setUserId(processDefinition.getUserId());
                taskDefinitionLog.setEnvironmentCode(-1);
                taskDefinitionLog.setDelayTime(0);
                taskDefinitionLog.setOperator(1);
                taskDefinitionLog.setOperateTime(now);
                taskDefinitionLog.setCreateTime(now);
                taskDefinitionLog.setUpdateTime(now);
                taskDefinitionLogList.add(taskDefinitionLog);
                taskIdCodeMap.put(task.get(""id"").asText(), taskCode);
                List<String> preTasks = JSONUtils.toList(task.get(""preTasks"").toString(), String.class);
                taskNamePreMap.put(name, preTasks);
                taskNameCodeMap.put(name, taskCode);
            }
            convertConditions(taskDefinitionLogList, taskNameCodeMap);
            taskDefinitionLogs.addAll(taskDefinitionLogList);
            processDefinition.setLocations(convertLocations(processDefinition.getLocations(), taskIdCodeMap));
            ProcessDefinitionLog processDefinitionLog = new ProcessDefinitionLog(processDefinition);
            processDefinitionLog.setOperator(1);
            processDefinitionLog.setOperateTime(now);
            processDefinitionLog.setUpdateTime(now);
            processDefinitionLogs.add(processDefinitionLog);
            handleProcessTaskRelation(taskNamePreMap, taskNameCodeMap, processDefinition, processTaskRelationLogs);
            processCodeTaskNameCodeMap.put(processDefinition.getCode(), taskNameCodeMap);
            processTaskMap.put(entry.getKey(), processCodeTaskNameCodeMap);
        }
    }
",1
dolphinscheduler-2.0.9,NULL_DEREFERENCE,dolphinscheduler-dao/src/main/java/org/apache/dolphinscheduler/dao/entity/TaskInstance.java,org.apache.dolphinscheduler.dao.entity.TaskInstance.getDependency():org.apache.dolphinscheduler.common.task.dependent.DependentParameters,461,object `taskParamsMap` last assigned on line 460 could be null and is dereferenced at line 461.,"458: public DependentParameters getDependency() {
 459: if (this.dependency == null) {
 460: Map<String, Object> taskParamsMap = JSONUtils.parseObject(this.getTaskParams(), new TypeReference<Map<String, Object>>() {});
 461: this.dependency = JSONUtils.parseObject((String) taskParamsMap.get(Constants.DEPENDENCE), DependentParameters.class);
 462: }
 463: return this.dependency;","public DependentParameters getDependency() {
        if (this.dependency == null) {
            Map<String, Object> taskParamsMap = JSONUtils.parseObject(this.getTaskParams(), new TypeReference<Map<String, Object>>() {});
            this.dependency = JSONUtils.parseObject((String) taskParamsMap.get(Constants.DEPENDENCE), DependentParameters.class);
        }
        return this.dependency;
    }",1
dolphinscheduler-2.0.9,NULL_DEREFERENCE,dolphinscheduler-dao/src/main/java/org/apache/dolphinscheduler/dao/entity/TaskInstance.java,org.apache.dolphinscheduler.dao.entity.TaskInstance.getSwitchDependency():org.apache.dolphinscheduler.common.task.switchtask.SwitchParameters,473,object `taskParamsMap` last assigned on line 472 could be null and is dereferenced at line 473.,"470: public SwitchParameters getSwitchDependency() {
 471: if (this.switchDependency == null) {
 472: Map<String, Object> taskParamsMap = JSONUtils.parseObject(this.getTaskParams(), new TypeReference<Map<String, Object>>() {});
 473: this.switchDependency = JSONUtils.parseObject((String) taskParamsMap.get(Constants.SWITCH_RESULT), SwitchParameters.class);
 474: }
 475: return this.switchDependency;","public SwitchParameters getSwitchDependency() {
        if (this.switchDependency == null) {
            Map<String, Object> taskParamsMap = JSONUtils.parseObject(this.getTaskParams(), new TypeReference<Map<String, Object>>() {});
            this.switchDependency = JSONUtils.parseObject((String) taskParamsMap.get(Constants.SWITCH_RESULT), SwitchParameters.class);
        }
        return this.switchDependency;
    }",1
dolphinscheduler-2.0.9,NULL_DEREFERENCE,dolphinscheduler-dao/src/main/java/org/apache/dolphinscheduler/dao/entity/TaskInstance.java,org.apache.dolphinscheduler.dao.entity.TaskInstance.setSwitchDependency(org.apache.dolphinscheduler.common.task.switchtask.SwitchParameters):void,480,object `taskParamsMap` last assigned on line 479 could be null and is dereferenced at line 480.,"478: public void setSwitchDependency(SwitchParameters switchDependency) {
 479: Map<String, Object> taskParamsMap = JSONUtils.parseObject(this.getTaskParams(), new TypeReference<Map<String, Object>>() {});
 480: taskParamsMap.put(Constants.SWITCH_RESULT,JSONUtils.toJsonString(switchDependency));
 481: this.setTaskParams(JSONUtils.toJsonString(taskParamsMap));","public void setSwitchDependency(SwitchParameters switchDependency) {
        Map<String, Object> taskParamsMap = JSONUtils.parseObject(this.getTaskParams(), new TypeReference<Map<String, Object>>() {});
        taskParamsMap.put(Constants.SWITCH_RESULT,JSONUtils.toJsonString(switchDependency));
        this.setTaskParams(JSONUtils.toJsonString(taskParamsMap));
    }
",1
dolphinscheduler-2.0.9,NULL_DEREFERENCE,dolphinscheduler-service/src/main/java/org/apache/dolphinscheduler/service/process/ProcessService.java,"org.apache.dolphinscheduler.service.process.ProcessService.recurseFindSubProcess(long,java.util.ArrayList):void",494,object `parameterJson` last assigned on line 493 could be null and is dereferenced at line 494.,https://github.com/apache/dolphinscheduler/blob/2.0.9-release/dolphinscheduler-service/src/main/java/org/apache/dolphinscheduler/service/process/ProcessService.java,"public void recurseFindSubProcess(long parentCode, List<Long> ids) {
        List<TaskDefinition> taskNodeList = this.getTaskNodeListByDefinition(parentCode);

        if (taskNodeList != null && !taskNodeList.isEmpty()) {

            for (TaskDefinition taskNode : taskNodeList) {
                String parameter = taskNode.getTaskParams();
                ObjectNode parameterJson = JSONUtils.parseObject(parameter);
                if (parameterJson.get(CMD_PARAM_SUB_PROCESS_DEFINE_CODE) != null) {
                    SubProcessParameters subProcessParam = JSONUtils.parseObject(parameter, SubProcessParameters.class);
                    ids.add(subProcessParam.getProcessDefinitionCode());
                    recurseFindSubProcess(subProcessParam.getProcessDefinitionCode(), ids);
                }
            }
        }
    }",0
dolphinscheduler-2.0.9,NULL_DEREFERENCE,dolphinscheduler-service/src/main/java/org/apache/dolphinscheduler/service/process/ProcessService.java,"org.apache.dolphinscheduler.service.process.ProcessService.recurseFindSubProcess(long,java.util.ArrayList):void",496,object `subProcessParam` last assigned on line 495 could be null and is dereferenced at line 496.,https://github.com/apache/dolphinscheduler/blob/2.0.9-release/dolphinscheduler-service/src/main/java/org/apache/dolphinscheduler/service/process/ProcessService.java,"public void recurseFindSubProcess(long parentCode, List<Long> ids) {
        List<TaskDefinition> taskNodeList = this.getTaskNodeListByDefinition(parentCode);

        if (taskNodeList != null && !taskNodeList.isEmpty()) {

            for (TaskDefinition taskNode : taskNodeList) {
                String parameter = taskNode.getTaskParams();
                ObjectNode parameterJson = JSONUtils.parseObject(parameter);
                if (parameterJson.get(CMD_PARAM_SUB_PROCESS_DEFINE_CODE) != null) {
                    SubProcessParameters subProcessParam = JSONUtils.parseObject(parameter, SubProcessParameters.class);
                    ids.add(subProcessParam.getProcessDefinitionCode());
                    recurseFindSubProcess(subProcessParam.getProcessDefinitionCode(), ids);
                }
            }
        }
    }",1
dolphinscheduler-2.0.9,NULL_DEREFERENCE,dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/impl/SchedulerServiceImpl.java,"org.apache.dolphinscheduler.api.service.impl.SchedulerServiceImpl.previewSchedule(org.apache.dolphinscheduler.dao.entity.User,java.lang.String):java.util.Map",550,object `scheduleParam` last assigned on line 547 could be null and is dereferenced at line 550.,"544: public Map<String, Object> previewSchedule(User loginUser, String schedule) {
 545: Map<String, Object> result = new HashMap<>();
 546: CronExpression cronExpression;
 547: ScheduleParam scheduleParam = JSONUtils.parseObject(schedule, ScheduleParam.class);
 548: Date now = new Date();
 549: 
 550: Date startTime = now.after(scheduleParam.getStartTime()) ? now : scheduleParam.getStartTime();
 551: Date endTime = scheduleParam.getEndTime();
 552: try {
 553: cronExpression = CronUtils.parse2CronExpression(scheduleParam.getCrontab());
 554: } catch (ParseException e) {
 555: logger.error(e.getMessage(), e);
 556: putMsg(result, Status.PARSE_TO_CRON_EXPRESSION_ERROR);
 557: return result;
 558: }
 559: List<Date> selfFireDateList = CronUtils.getSelfFireDateList(startTime, endTime, cronExpression, Constants.PREVIEW_SCHEDULE_EXECUTE_COUNT);
 560: result.put(Constants.DATA_LIST, selfFireDateList.stream().map(DateUtils::dateToString));
 561: putMsg(result, Status.SUCCESS);
 562: return result;","public Map<String, Object> previewSchedule(User loginUser, String schedule) {
        Map<String, Object> result = new HashMap<>();
        CronExpression cronExpression;
        ScheduleParam scheduleParam = JSONUtils.parseObject(schedule, ScheduleParam.class);
        Date now = new Date();

        Date startTime = now.after(scheduleParam.getStartTime()) ? now : scheduleParam.getStartTime();
        Date endTime = scheduleParam.getEndTime();
        try {
            cronExpression = CronUtils.parse2CronExpression(scheduleParam.getCrontab());
        } catch (ParseException e) {
            logger.error(e.getMessage(), e);
            putMsg(result, Status.PARSE_TO_CRON_EXPRESSION_ERROR);
            return result;
        }
        List<Date> selfFireDateList = CronUtils.getSelfFireDateList(startTime, endTime, cronExpression, Constants.PREVIEW_SCHEDULE_EXECUTE_COUNT);
        result.put(Constants.DATA_LIST, selfFireDateList.stream().map(DateUtils::dateToString));
        putMsg(result, Status.SUCCESS);
        return result;
    }",1
dolphinscheduler-2.0.9,NULL_DEREFERENCE,dolphinscheduler-dao/src/main/java/org/apache/dolphinscheduler/dao/upgrade/UpgradeDao.java,"org.apache.dolphinscheduler.dao.upgrade.UpgradeDao.convertConditions(java.util.ArrayList,java.util.HashMap):void",551,object `taskParams` last assigned on line 549 could be null and is dereferenced at line 551.,https://github.com/apache/dolphinscheduler/blob/2.0.9-release/dolphinscheduler-dao/src/main/java/org/apache/dolphinscheduler/dao/upgrade/UpgradeDao.java,"public void convertConditions(List<TaskDefinitionLog> taskDefinitionLogList, Map<String, Long> taskNameCodeMap) throws Exception {
        for (TaskDefinitionLog taskDefinitionLog : taskDefinitionLogList) {
            if (TaskType.CONDITIONS.getDesc().equals(taskDefinitionLog.getTaskType())) {
                ObjectMapper objectMapper = new ObjectMapper();
                ObjectNode taskParams = JSONUtils.parseObject(taskDefinitionLog.getTaskParams());
                // reset conditionResult
                ObjectNode conditionResult = (ObjectNode) taskParams.get(""conditionResult"");
                List<String> successNode = JSONUtils.toList(conditionResult.get(""successNode"").toString(), String.class);
                List<Long> nodeCode = new ArrayList<>();
                successNode.forEach(node -> nodeCode.add(taskNameCodeMap.get(node)));
                conditionResult.set(""successNode"", objectMapper.readTree(objectMapper.writeValueAsString(nodeCode)));
                List<String> failedNode = JSONUtils.toList(conditionResult.get(""failedNode"").toString(), String.class);
                nodeCode.clear();
                failedNode.forEach(node -> nodeCode.add(taskNameCodeMap.get(node)));
                conditionResult.set(""failedNode"", objectMapper.readTree(objectMapper.writeValueAsString(nodeCode)));
                // reset dependItemList
                ObjectNode dependence = (ObjectNode) taskParams.get(""dependence"");
                ArrayNode dependTaskList = JSONUtils.parseArray(JSONUtils.toJsonString(dependence.get(""dependTaskList"")));
                for (int i = 0; i < dependTaskList.size(); i++) {
                    ObjectNode dependTask = (ObjectNode) dependTaskList.path(i);
                    ArrayNode dependItemList = JSONUtils.parseArray(JSONUtils.toJsonString(dependTask.get(""dependItemList"")));
                    for (int j = 0; j < dependItemList.size(); j++) {
                        ObjectNode dependItem = (ObjectNode) dependItemList.path(j);
                        JsonNode depTasks = dependItem.get(""depTasks"");
                        dependItem.put(""depTaskCode"", taskNameCodeMap.get(depTasks.asText()));
                        dependItem.remove(""depTasks"");
                        dependItemList.set(j, dependItem);
                    }
                    dependTask.put(""dependItemList"", dependItemList);
                    dependTaskList.set(i, dependTask);
                }
                dependence.put(""dependTaskList"", dependTaskList);
                taskDefinitionLog.setTaskParams(JSONUtils.toJsonString(taskParams));
            }
        }
    }",1
dolphinscheduler-2.0.9,NULL_DEREFERENCE,dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/impl/ExecutorServiceImpl.java,"org.apache.dolphinscheduler.api.service.impl.ExecutorServiceImpl.createComplementCommandList(java.util.Date,java.util.Date,org.apache.dolphinscheduler.common.enums.RunMode,org.apache.dolphinscheduler.dao.entity.Command,java.lang.Integer):int",593,object `cmdParam` last assigned on line 578 could be null and is dereferenced at line 593.,"575: private int createComplementCommandList(Date start, Date end, RunMode runMode, Command command, Integer expectedParallelismNumber) {
 576: int createCount = 0;
 577: runMode = (runMode == null) ? RunMode.RUN_MODE_SERIAL : runMode;
 578: Map<String, String> cmdParam = JSONUtils.toMap(command.getCommandParam());
 579: List<Schedule> schedules = processService.queryReleaseSchedulerListByProcessDefinitionCode(command.getProcessDefinitionCode());
 580: LinkedList<Date> listDate = new LinkedList<>(CronUtils.getSelfFireDateList(start, end, schedules));
 581: final int listDateSize = listDate.size();
 582: if (listDateSize == 0) {
 583: logger.warn(""can't create complement command, because the fire date cannot be created, scope: {} ~ {}"",
 584: DateUtils.dateToString(start), DateUtils.dateToString(end));
 585: throw new ServiceException(Status.COMPLEMENT_PROCESS_INSTANCE_DATE_RANGE_ERROR);
 586: }
 587: switch (runMode) {
 588: case RUN_MODE_SERIAL: {
 589: if (start.after(end)) {
 590: logger.warn(""The startDate {} is later than the endDate {}"", start, end);
 591: break;
 592: }
 593: cmdParam.put(CMDPARAM_COMPLEMENT_DATA_START_DATE, DateUtils.dateToString(start));
 594: cmdParam.put(CMDPARAM_COMPLEMENT_DATA_END_DATE, DateUtils.dateToString(end));
 595: command.setCommandParam(JSONUtils.toJsonString(cmdParam));
 596: createCount = processService.createCommand(command);
 597: break;
 598: }
 599: case RUN_MODE_PARALLEL: {
 600: if (start.after(end)) {
 601: logger.warn(""The startDate {} is later than the endDate {}"", start, end);
 602: break;
 603: }
 604: 
 605: createCount = listDate.size();
 606: if (!CollectionUtils.isEmpty(listDate)) {
 607: if (expectedParallelismNumber != null && expectedParallelismNumber != 0) {
 608: createCount = Math.min(listDate.size(), expectedParallelismNumber);
 609: if (listDateSize < createCount) {
 610: createCount = listDateSize;
 611: }
 612: }
 613: logger.info(""In parallel mode, current expectedParallelismNumber:{}"", createCount);
 614: 
 615: // Distribute the number of tasks equally to each command.
 616: // The last command with insufficient quantity will be assigned to the remaining tasks.
 617: int itemsPerCommand = (listDateSize / createCount);
 618: int remainingItems = (listDateSize % createCount);
 619: int startDateIndex = 0;
 620: int endDateIndex = 0;
 621: 
 622: for (int i = 1; i <= createCount; i++) {
 623: int extra = (i <= remainingItems) ? 1 : 0;
 624: int singleCommandItems = (itemsPerCommand + extra);
 625: 
 626: if (i == 1) {
 627: endDateIndex += singleCommandItems - 1;
 628: } else {
 629: startDateIndex = endDateIndex + 1;
 630: endDateIndex += singleCommandItems;
 631: }
 632: 
 633: cmdParam.put(CMDPARAM_COMPLEMENT_DATA_START_DATE, DateUtils.dateToString(listDate.get(startDateIndex)));
 634: cmdParam.put(CMDPARAM_COMPLEMENT_DATA_END_DATE, DateUtils.dateToString(listDate.get(endDateIndex)));
 635: command.setCommandParam(JSONUtils.toJsonString(cmdParam));
 636: processService.createCommand(command);
 637: }
 638: }
 639: break;
 640: }
 641: default:
 642: break;
 643: }
 644: logger.info(""create complement command count: {}"", createCount);
 645: return createCount;","private int createComplementCommandList(Date start, Date end, RunMode runMode, Command command, Integer expectedParallelismNumber) {
        int createCount = 0;
        runMode = (runMode == null) ? RunMode.RUN_MODE_SERIAL : runMode;
        Map<String, String> cmdParam = JSONUtils.toMap(command.getCommandParam());
        List<Schedule> schedules = processService.queryReleaseSchedulerListByProcessDefinitionCode(command.getProcessDefinitionCode());
        LinkedList<Date> listDate = new LinkedList<>(CronUtils.getSelfFireDateList(start, end, schedules));
        final int listDateSize = listDate.size();
        if (listDateSize == 0) {
            logger.warn(""can't create complement command, because the fire date cannot be created, scope: {} ~ {}"",
                    DateUtils.dateToString(start), DateUtils.dateToString(end));
            throw new ServiceException(Status.COMPLEMENT_PROCESS_INSTANCE_DATE_RANGE_ERROR);
        }
        switch (runMode) {
            case RUN_MODE_SERIAL: {
                if (start.after(end)) {
                    logger.warn(""The startDate {} is later than the endDate {}"", start, end);
                    break;
                }
                cmdParam.put(CMDPARAM_COMPLEMENT_DATA_START_DATE, DateUtils.dateToString(start));
                cmdParam.put(CMDPARAM_COMPLEMENT_DATA_END_DATE, DateUtils.dateToString(end));
                command.setCommandParam(JSONUtils.toJsonString(cmdParam));
                createCount = processService.createCommand(command);
                break;
            }
            case RUN_MODE_PARALLEL: {
                if (start.after(end)) {
                    logger.warn(""The startDate {} is later than the endDate {}"", start, end);
                    break;
                }

                createCount = listDate.size();
                if (!CollectionUtils.isEmpty(listDate)) {
                    if (expectedParallelismNumber != null && expectedParallelismNumber != 0) {
                        createCount = Math.min(listDate.size(), expectedParallelismNumber);
                        if (listDateSize < createCount) {
                            createCount = listDateSize;
                        }
                    }
                    logger.info(""In parallel mode, current expectedParallelismNumber:{}"", createCount);

                    // Distribute the number of tasks equally to each command.
                    // The last command with insufficient quantity will be assigned to the remaining tasks.
                    int itemsPerCommand = (listDateSize / createCount);
                    int remainingItems = (listDateSize % createCount);
                    int startDateIndex = 0;
                    int endDateIndex = 0;

                    for (int i = 1; i <= createCount; i++) {
                        int extra = (i <= remainingItems) ? 1 : 0;
                        int singleCommandItems = (itemsPerCommand + extra);

                        if (i == 1) {
                            endDateIndex += singleCommandItems - 1;
                        } else {
                            startDateIndex = endDateIndex + 1;
                            endDateIndex += singleCommandItems;
                        }

                        cmdParam.put(CMDPARAM_COMPLEMENT_DATA_START_DATE, DateUtils.dateToString(listDate.get(startDateIndex)));
                        cmdParam.put(CMDPARAM_COMPLEMENT_DATA_END_DATE, DateUtils.dateToString(listDate.get(endDateIndex)));
                        command.setCommandParam(JSONUtils.toJsonString(cmdParam));
                        processService.createCommand(command);
                    }
                }
                break;
            }
            default:
                break;
        }
        logger.info(""create complement command count: {}"", createCount);
        return createCount;
    }",1
dolphinscheduler-2.0.9,NULL_DEREFERENCE,dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/impl/ExecutorServiceImpl.java,"org.apache.dolphinscheduler.api.service.impl.ExecutorServiceImpl.createComplementCommandList(java.util.Date,java.util.Date,org.apache.dolphinscheduler.common.enums.RunMode,org.apache.dolphinscheduler.dao.entity.Command,java.lang.Integer):int",633,object `cmdParam` last assigned on line 578 could be null and is dereferenced at line 633.,"575: private int createComplementCommandList(Date start, Date end, RunMode runMode, Command command, Integer expectedParallelismNumber) {
 576: int createCount = 0;
 577: runMode = (runMode == null) ? RunMode.RUN_MODE_SERIAL : runMode;
 578: Map<String, String> cmdParam = JSONUtils.toMap(command.getCommandParam());
 579: List<Schedule> schedules = processService.queryReleaseSchedulerListByProcessDefinitionCode(command.getProcessDefinitionCode());
 580: LinkedList<Date> listDate = new LinkedList<>(CronUtils.getSelfFireDateList(start, end, schedules));
 581: final int listDateSize = listDate.size();
 582: if (listDateSize == 0) {
 583: logger.warn(""can't create complement command, because the fire date cannot be created, scope: {} ~ {}"",
 584: DateUtils.dateToString(start), DateUtils.dateToString(end));
 585: throw new ServiceException(Status.COMPLEMENT_PROCESS_INSTANCE_DATE_RANGE_ERROR);
 586: }
 587: switch (runMode) {
 588: case RUN_MODE_SERIAL: {
 589: if (start.after(end)) {
 590: logger.warn(""The startDate {} is later than the endDate {}"", start, end);
 591: break;
 592: }
 593: cmdParam.put(CMDPARAM_COMPLEMENT_DATA_START_DATE, DateUtils.dateToString(start));
 594: cmdParam.put(CMDPARAM_COMPLEMENT_DATA_END_DATE, DateUtils.dateToString(end));
 595: command.setCommandParam(JSONUtils.toJsonString(cmdParam));
 596: createCount = processService.createCommand(command);
 597: break;
 598: }
 599: case RUN_MODE_PARALLEL: {
 600: if (start.after(end)) {
 601: logger.warn(""The startDate {} is later than the endDate {}"", start, end);
 602: break;
 603: }
 604: 
 605: createCount = listDate.size();
 606: if (!CollectionUtils.isEmpty(listDate)) {
 607: if (expectedParallelismNumber != null && expectedParallelismNumber != 0) {
 608: createCount = Math.min(listDate.size(), expectedParallelismNumber);
 609: if (listDateSize < createCount) {
 610: createCount = listDateSize;
 611: }
 612: }
 613: logger.info(""In parallel mode, current expectedParallelismNumber:{}"", createCount);
 614: 
 615: // Distribute the number of tasks equally to each command.
 616: // The last command with insufficient quantity will be assigned to the remaining tasks.
 617: int itemsPerCommand = (listDateSize / createCount);
 618: int remainingItems = (listDateSize % createCount);
 619: int startDateIndex = 0;
 620: int endDateIndex = 0;
 621: 
 622: for (int i = 1; i <= createCount; i++) {
 623: int extra = (i <= remainingItems) ? 1 : 0;
 624: int singleCommandItems = (itemsPerCommand + extra);
 625: 
 626: if (i == 1) {
 627: endDateIndex += singleCommandItems - 1;
 628: } else {
 629: startDateIndex = endDateIndex + 1;
 630: endDateIndex += singleCommandItems;
 631: }
 632: 
 633: cmdParam.put(CMDPARAM_COMPLEMENT_DATA_START_DATE, DateUtils.dateToString(listDate.get(startDateIndex)));
 634: cmdParam.put(CMDPARAM_COMPLEMENT_DATA_END_DATE, DateUtils.dateToString(listDate.get(endDateIndex)));
 635: command.setCommandParam(JSONUtils.toJsonString(cmdParam));
 636: processService.createCommand(command);
 637: }
 638: }
 639: break;
 640: }
 641: default:
 642: break;
 643: }
 644: logger.info(""create complement command count: {}"", createCount);
 645: return createCount;","private int createComplementCommandList(Date start, Date end, RunMode runMode, Command command, Integer expectedParallelismNumber) {
        int createCount = 0;
        runMode = (runMode == null) ? RunMode.RUN_MODE_SERIAL : runMode;
        Map<String, String> cmdParam = JSONUtils.toMap(command.getCommandParam());
        List<Schedule> schedules = processService.queryReleaseSchedulerListByProcessDefinitionCode(command.getProcessDefinitionCode());
        LinkedList<Date> listDate = new LinkedList<>(CronUtils.getSelfFireDateList(start, end, schedules));
        final int listDateSize = listDate.size();
        if (listDateSize == 0) {
            logger.warn(""can't create complement command, because the fire date cannot be created, scope: {} ~ {}"",
                    DateUtils.dateToString(start), DateUtils.dateToString(end));
            throw new ServiceException(Status.COMPLEMENT_PROCESS_INSTANCE_DATE_RANGE_ERROR);
        }
        switch (runMode) {
            case RUN_MODE_SERIAL: {
                if (start.after(end)) {
                    logger.warn(""The startDate {} is later than the endDate {}"", start, end);
                    break;
                }
                cmdParam.put(CMDPARAM_COMPLEMENT_DATA_START_DATE, DateUtils.dateToString(start));
                cmdParam.put(CMDPARAM_COMPLEMENT_DATA_END_DATE, DateUtils.dateToString(end));
                command.setCommandParam(JSONUtils.toJsonString(cmdParam));
                createCount = processService.createCommand(command);
                break;
            }
            case RUN_MODE_PARALLEL: {
                if (start.after(end)) {
                    logger.warn(""The startDate {} is later than the endDate {}"", start, end);
                    break;
                }

                createCount = listDate.size();
                if (!CollectionUtils.isEmpty(listDate)) {
                    if (expectedParallelismNumber != null && expectedParallelismNumber != 0) {
                        createCount = Math.min(listDate.size(), expectedParallelismNumber);
                        if (listDateSize < createCount) {
                            createCount = listDateSize;
                        }
                    }
                    logger.info(""In parallel mode, current expectedParallelismNumber:{}"", createCount);

                    // Distribute the number of tasks equally to each command.
                    // The last command with insufficient quantity will be assigned to the remaining tasks.
                    int itemsPerCommand = (listDateSize / createCount);
                    int remainingItems = (listDateSize % createCount);
                    int startDateIndex = 0;
                    int endDateIndex = 0;

                    for (int i = 1; i <= createCount; i++) {
                        int extra = (i <= remainingItems) ? 1 : 0;
                        int singleCommandItems = (itemsPerCommand + extra);

                        if (i == 1) {
                            endDateIndex += singleCommandItems - 1;
                        } else {
                            startDateIndex = endDateIndex + 1;
                            endDateIndex += singleCommandItems;
                        }

                        cmdParam.put(CMDPARAM_COMPLEMENT_DATA_START_DATE, DateUtils.dateToString(listDate.get(startDateIndex)));
                        cmdParam.put(CMDPARAM_COMPLEMENT_DATA_END_DATE, DateUtils.dateToString(listDate.get(endDateIndex)));
                        command.setCommandParam(JSONUtils.toJsonString(cmdParam));
                        processService.createCommand(command);
                    }
                }
                break;
            }
            default:
                break;
        }
        logger.info(""create complement command count: {}"", createCount);
        return createCount;
    }",1
dolphinscheduler-2.0.9,NULL_DEREFERENCE,dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/master/runner/WorkflowExecuteThread.java,org.apache.dolphinscheduler.server.master.runner.WorkflowExecuteThread.createComplementDataCommand(java.util.Date):int,586,object `cmdParam` last assigned on line 585 could be null and is dereferenced at line 586.,"580: private int createComplementDataCommand(Date scheduleDate) {
 581: Command command = new Command();
 582: command.setScheduleTime(scheduleDate);
 583: command.setCommandType(CommandType.COMPLEMENT_DATA);
 584: command.setProcessDefinitionCode(processInstance.getProcessDefinitionCode());
 585: Map<String, String> cmdParam = JSONUtils.toMap(processInstance.getCommandParam());
 586: if (cmdParam.containsKey(Constants.CMD_PARAM_RECOVERY_START_NODE_STRING)) {
 587: cmdParam.remove(Constants.CMD_PARAM_RECOVERY_START_NODE_STRING);
 588: }
 589: cmdParam.replace(CMDPARAM_COMPLEMENT_DATA_START_DATE, DateUtils.format(scheduleDate, ""yyyy-MM-dd HH:mm:ss""));
 590: command.setCommandParam(JSONUtils.toJsonString(cmdParam));
 591: command.setTaskDependType(processInstance.getTaskDependType());
 592: command.setFailureStrategy(processInstance.getFailureStrategy());
 593: command.setWarningType(processInstance.getWarningType());
 594: command.setWarningGroupId(processInstance.getWarningGroupId());
 595: command.setStartTime(new Date());
 596: command.setExecutorId(processInstance.getExecutorId());
 597: command.setUpdateTime(new Date());
 598: command.setProcessInstancePriority(processInstance.getProcessInstancePriority());
 599: command.setWorkerGroup(processInstance.getWorkerGroup());
 600: command.setEnvironmentCode(processInstance.getEnvironmentCode());
 601: command.setDryRun(processInstance.getDryRun());
 602: command.setProcessInstanceId(0);
 603: command.setProcessDefinitionVersion(processInstance.getProcessDefinitionVersion());
 604: return processService.createCommand(command);","private int createComplementDataCommand(Date scheduleDate) {
        Command command = new Command();
        command.setScheduleTime(scheduleDate);
        command.setCommandType(CommandType.COMPLEMENT_DATA);
        command.setProcessDefinitionCode(processInstance.getProcessDefinitionCode());
        Map<String, String> cmdParam = JSONUtils.toMap(processInstance.getCommandParam());
        if (cmdParam.containsKey(Constants.CMD_PARAM_RECOVERY_START_NODE_STRING)) {
            cmdParam.remove(Constants.CMD_PARAM_RECOVERY_START_NODE_STRING);
        }
        cmdParam.replace(CMDPARAM_COMPLEMENT_DATA_START_DATE, DateUtils.format(scheduleDate, ""yyyy-MM-dd HH:mm:ss""));
        command.setCommandParam(JSONUtils.toJsonString(cmdParam));
        command.setTaskDependType(processInstance.getTaskDependType());
        command.setFailureStrategy(processInstance.getFailureStrategy());
        command.setWarningType(processInstance.getWarningType());
        command.setWarningGroupId(processInstance.getWarningGroupId());
        command.setStartTime(new Date());
        command.setExecutorId(processInstance.getExecutorId());
        command.setUpdateTime(new Date());
        command.setProcessInstancePriority(processInstance.getProcessInstancePriority());
        command.setWorkerGroup(processInstance.getWorkerGroup());
        command.setEnvironmentCode(processInstance.getEnvironmentCode());
        command.setDryRun(processInstance.getDryRun());
        command.setProcessInstanceId(0);
        command.setProcessDefinitionVersion(processInstance.getProcessDefinitionVersion());
        return processService.createCommand(command);
    }",1
dolphinscheduler-2.0.9,NULL_DEREFERENCE,dolphinscheduler-dao/src/main/java/org/apache/dolphinscheduler/dao/upgrade/UpgradeDao.java,"org.apache.dolphinscheduler.dao.upgrade.UpgradeDao.convertDependence(java.util.ArrayList,java.util.Map,java.util.HashMap):void",609,object `taskParams` last assigned on line 608 could be null and is dereferenced at line 609.,https://github.com/apache/dolphinscheduler/blob/2.0.9-release/dolphinscheduler-dao/src/main/java/org/apache/dolphinscheduler/dao/upgrade/UpgradeDao.java,"public void convertDependence(List<TaskDefinitionLog> taskDefinitionLogs,
                                  Map<Integer, Long> projectIdCodeMap,
                                  Map<Integer, Map<Long, Map<String, Long>>> processTaskMap) {
        for (TaskDefinitionLog taskDefinitionLog : taskDefinitionLogs) {
            if (TaskType.DEPENDENT.getDesc().equals(taskDefinitionLog.getTaskType())) {
                ObjectNode taskParams = JSONUtils.parseObject(taskDefinitionLog.getTaskParams());
                ObjectNode dependence = (ObjectNode) taskParams.get(""dependence"");
                ArrayNode dependTaskList = JSONUtils.parseArray(JSONUtils.toJsonString(dependence.get(""dependTaskList"")));
                for (int i = 0; i < dependTaskList.size(); i++) {
                    ObjectNode dependTask = (ObjectNode) dependTaskList.path(i);
                    ArrayNode dependItemList = JSONUtils.parseArray(JSONUtils.toJsonString(dependTask.get(""dependItemList"")));
                    for (int j = 0; j < dependItemList.size(); j++) {
                        ObjectNode dependItem = (ObjectNode) dependItemList.path(j);
                        dependItem.put(""projectCode"", projectIdCodeMap.get(dependItem.get(""projectId"").asInt()));
                        int definitionId = dependItem.get(""definitionId"").asInt();
                        Map<Long, Map<String, Long>> processCodeTaskNameCodeMap = processTaskMap.get(definitionId);
                        if (processCodeTaskNameCodeMap == null) {
                            logger.warn(""We can't find processDefinition [{}], please check it is not exist, remove this dependence"", definitionId);
                            dependItemList.remove(j);
                            continue;
                        }
                        Optional<Map.Entry<Long, Map<String, Long>>> mapEntry = processCodeTaskNameCodeMap.entrySet().stream().findFirst();
                        if (mapEntry.isPresent()) {
                            Map.Entry<Long, Map<String, Long>> processCodeTaskNameCodeEntry = mapEntry.get();
                            dependItem.put(""definitionCode"", processCodeTaskNameCodeEntry.getKey());
                            String depTasks = dependItem.get(""depTasks"").asText();
                            long taskCode = ""ALL"".equals(depTasks) || processCodeTaskNameCodeEntry.getValue() == null ? 0L : processCodeTaskNameCodeEntry.getValue().get(depTasks);
                            dependItem.put(""depTaskCode"", taskCode);
                        }
                        dependItem.remove(""projectId"");
                        dependItem.remove(""definitionId"");
                        dependItem.remove(""depTasks"");
                        dependItemList.set(j, dependItem);
                    }
                    dependTask.put(""dependItemList"", dependItemList);
                    dependTaskList.set(i, dependTask);
                }
                dependence.put(""dependTaskList"", dependTaskList);
                taskDefinitionLog.setTaskParams(JSONUtils.toJsonString(taskParams));
            }
        }
    }",1
dolphinscheduler-2.0.9,NULL_DEREFERENCE,dolphinscheduler-dao/src/main/java/org/apache/dolphinscheduler/dao/upgrade/UpgradeDao.java,"org.apache.dolphinscheduler.dao.upgrade.UpgradeDao.handleProcessTaskRelation(java.util.HashMap,java.util.HashMap,org.apache.dolphinscheduler.dao.entity.ProcessDefinition,java.util.List):void",666,object returned by `taskNameCodeMap.get(entry.getKey())` could be null and is dereferenced at line 666.,https://github.com/apache/dolphinscheduler/blob/2.0.9-release/dolphinscheduler-dao/src/main/java/org/apache/dolphinscheduler/dao/upgrade/UpgradeDao.java,"private void handleProcessTaskRelation(Map<String, List<String>> taskNamePreMap,
                                           Map<String, Long> taskNameCodeMap,
                                           ProcessDefinition processDefinition,
                                           List<ProcessTaskRelationLog> processTaskRelationLogs) {
        Date now = new Date();
        for (Map.Entry<String, List<String>> entry : taskNamePreMap.entrySet()) {
            List<String> entryValue = entry.getValue();
            if (CollectionUtils.isNotEmpty(entryValue)) {
                for (String preTaskName : entryValue) {
                    ProcessTaskRelationLog processTaskRelationLog = setProcessTaskRelationLog(processDefinition, now);
                    processTaskRelationLog.setPreTaskCode(taskNameCodeMap.get(preTaskName));
                    processTaskRelationLog.setPreTaskVersion(Constants.VERSION_FIRST);
                    processTaskRelationLog.setPostTaskCode(taskNameCodeMap.get(entry.getKey()));
                    processTaskRelationLog.setPostTaskVersion(Constants.VERSION_FIRST);
                    processTaskRelationLogs.add(processTaskRelationLog);
                }
            } else {
                ProcessTaskRelationLog processTaskRelationLog = setProcessTaskRelationLog(processDefinition, now);
                processTaskRelationLog.setPreTaskCode(0);
                processTaskRelationLog.setPreTaskVersion(0);
                processTaskRelationLog.setPostTaskCode(taskNameCodeMap.get(entry.getKey()));
                processTaskRelationLog.setPostTaskVersion(Constants.VERSION_FIRST);
                processTaskRelationLogs.add(processTaskRelationLog);
            }
        }
    }",0
dolphinscheduler-2.0.9,NULL_DEREFERENCE,dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/master/runner/WorkflowExecuteThread.java,org.apache.dolphinscheduler.server.master.runner.WorkflowExecuteThread.buildFlowDag():void,653,object `WorkflowExecuteThread.processDefinition` last assigned on line 651 could be null and is dereferenced at line 653.,"647: private void buildFlowDag() throws Exception {
 648: if (this.dag != null) {
 649: return;
 650: }
 651: processDefinition = processService.findProcessDefinition(processInstance.getProcessDefinitionCode(), processInstance.getProcessDefinitionVersion());
 652: recoverNodeIdList = getStartTaskInstanceList(processInstance.getCommandParam());
 653: List<ProcessTaskRelation> processTaskRelationList = processService.findRelationByCode(processDefinition.getCode(), processDefinition.getVersion());
 654: List<TaskDefinitionLog> taskDefinitionLogList = processService.getTaskDefineLogListByRelation(processTaskRelationList);
 655: List<TaskNode> taskNodeList = processService.transformTask(processTaskRelationList, taskDefinitionLogList);
 656: forbiddenTaskList.clear();
 657: 
 658: taskNodeList.forEach(taskNode -> {
 659: if (taskNode.isForbidden()) {
 660: forbiddenTaskList.put(Long.toString(taskNode.getCode()), taskNode);
 661: }
 662: });
 663: 
 664: // generate process to get DAG info
 665: List<String> recoveryNodeCodeList = getRecoveryNodeCodeList();
 666: List<String> startNodeNameList = parseStartNodeName(processInstance.getCommandParam());
 667: ProcessDag processDag = generateFlowDag(taskNodeList,
 668: startNodeNameList, recoveryNodeCodeList, processInstance.getTaskDependType());
 669: if (processDag == null) {
 670: logger.error(""processDag is null"");
 671: return;
 672: }
 673: // generate process dag
 674: dag = DagHelper.buildDagGraph(processDag);","private void buildFlowDag() throws Exception {
        if (this.dag != null) {
            return;
        }
        processDefinition = processService.findProcessDefinition(processInstance.getProcessDefinitionCode(), processInstance.getProcessDefinitionVersion());
        recoverNodeIdList = getStartTaskInstanceList(processInstance.getCommandParam());
        List<ProcessTaskRelation> processTaskRelationList = processService.findRelationByCode(processDefinition.getCode(), processDefinition.getVersion());
        List<TaskDefinitionLog> taskDefinitionLogList = processService.getTaskDefineLogListByRelation(processTaskRelationList);
        List<TaskNode> taskNodeList = processService.transformTask(processTaskRelationList, taskDefinitionLogList);
        forbiddenTaskList.clear();

        taskNodeList.forEach(taskNode -> {
            if (taskNode.isForbidden()) {
                forbiddenTaskList.put(Long.toString(taskNode.getCode()), taskNode);
            }
        });

        // generate process to get DAG info
        List<String> recoveryNodeCodeList = getRecoveryNodeCodeList();
        List<String> startNodeNameList = parseStartNodeName(processInstance.getCommandParam());
        ProcessDag processDag = generateFlowDag(taskNodeList,
                startNodeNameList, recoveryNodeCodeList, processInstance.getTaskDependType());
        if (processDag == null) {
            logger.error(""processDag is null"");
            return;
        }
        // generate process dag
        dag = DagHelper.buildDagGraph(processDag);
    }",1
dolphinscheduler-2.0.9,NULL_DEREFERENCE,dolphinscheduler-common/src/main/java/org/apache/dolphinscheduler/common/utils/HadoopUtils.java,org.apache.dolphinscheduler.common.utils.HadoopUtils$YarnHAAdminUtils.getRMState(java.lang.String):java.lang.String,683,object `jsonObject` last assigned on line 680 could be null and is dereferenced at line 683.,"672: public static String getRMState(String url) {
 673: 
 674: String retStr = PropertyUtils.getBoolean(Constants.HADOOP_SECURITY_AUTHENTICATION_STARTUP_STATE, false) ? KerberosHttpClient.get(url) : HttpUtils.get(url);
 675: 
 676: if (StringUtils.isEmpty(retStr)) {
 677: return null;
 678: }
 679: //to json
 680: ObjectNode jsonObject = JSONUtils.parseObject(retStr);
 681: 
 682: //get ResourceManager state
 683: if (!jsonObject.has(""clusterInfo"")) {
 684: return null;
 685: }
 686: return jsonObject.get(""clusterInfo"").path(""haState"").asText();","public static String getRMState(String url) {

            String retStr = PropertyUtils.getBoolean(Constants.HADOOP_SECURITY_AUTHENTICATION_STARTUP_STATE, false) ? KerberosHttpClient.get(url) : HttpUtils.get(url);

            if (StringUtils.isEmpty(retStr)) {
                return null;
            }
            //to json
            ObjectNode jsonObject = JSONUtils.parseObject(retStr);

            //get ResourceManager state
            if (!jsonObject.has(""clusterInfo"")) {
                return null;
            }
            return jsonObject.get(""clusterInfo"").path(""haState"").asText();
        }

    }",1
dolphinscheduler-2.0.9,NULL_DEREFERENCE,dolphinscheduler-common/src/main/java/org/apache/dolphinscheduler/common/utils/HadoopUtils.java,org.apache.dolphinscheduler.common.utils.HadoopUtils$YarnHAAdminUtils.getRMState(java.lang.String):java.lang.String,680,object `retStr` last assigned on line 674 could be null and is dereferenced by call to `parseObject(...)` at line 680.,"672: public static String getRMState(String url) {
 673: 
 674: String retStr = PropertyUtils.getBoolean(Constants.HADOOP_SECURITY_AUTHENTICATION_STARTUP_STATE, false) ? KerberosHttpClient.get(url) : HttpUtils.get(url);
 675: 
 676: if (StringUtils.isEmpty(retStr)) {
 677: return null;
 678: }
 679: //to json
 680: ObjectNode jsonObject = JSONUtils.parseObject(retStr);
 681: 
 682: //get ResourceManager state
 683: if (!jsonObject.has(""clusterInfo"")) {
 684: return null;
 685: }
 686: return jsonObject.get(""clusterInfo"").path(""haState"").asText();","public static String getRMState(String url) {

            String retStr = PropertyUtils.getBoolean(Constants.HADOOP_SECURITY_AUTHENTICATION_STARTUP_STATE, false) ? KerberosHttpClient.get(url) : HttpUtils.get(url);

            if (StringUtils.isEmpty(retStr)) {
                return null;
            }
            //to json
            ObjectNode jsonObject = JSONUtils.parseObject(retStr);

            //get ResourceManager state
            if (!jsonObject.has(""clusterInfo"")) {
                return null;
            }
            return jsonObject.get(""clusterInfo"").path(""haState"").asText();
        }

    }",0
dolphinscheduler-2.0.9,NULL_DEREFERENCE,dolphinscheduler-service/src/main/java/org/apache/dolphinscheduler/service/process/ProcessService.java,org.apache.dolphinscheduler.service.process.ProcessService.setSubProcessParam(org.apache.dolphinscheduler.dao.entity.ProcessInstance):void,971,object `paramMap` last assigned on line 969 could be null and is dereferenced at line 971.,"964: public void setSubProcessParam(ProcessInstance subProcessInstance) {
 965: String cmdParam = subProcessInstance.getCommandParam();
 966: if (StringUtils.isEmpty(cmdParam)) {
 967: return;
 968: }
 969: Map<String, String> paramMap = JSONUtils.toMap(cmdParam);
 970: // write sub process id into cmd param.
 971: if (paramMap.containsKey(CMD_PARAM_SUB_PROCESS)
 972: && CMD_PARAM_EMPTY_SUB_PROCESS.equals(paramMap.get(CMD_PARAM_SUB_PROCESS))) {
 973: paramMap.remove(CMD_PARAM_SUB_PROCESS);
 974: paramMap.put(CMD_PARAM_SUB_PROCESS, String.valueOf(subProcessInstance.getId()));
 975: subProcessInstance.setCommandParam(JSONUtils.toJsonString(paramMap));
 976: subProcessInstance.setIsSubProcess(Flag.YES);
 977: this.saveProcessInstance(subProcessInstance);
 978: }
 979: // copy parent instance user def params to sub process..
 980: String parentInstanceId = paramMap.get(CMD_PARAM_SUB_PROCESS_PARENT_INSTANCE_ID);
 981: if (StringUtils.isNotEmpty(parentInstanceId)) {
 982: ProcessInstance parentInstance = findProcessInstanceDetailById(Integer.parseInt(parentInstanceId));
 983: if (parentInstance != null) {
 984: subProcessInstance.setGlobalParams(
 985: joinGlobalParams(parentInstance.getGlobalParams(), subProcessInstance.getGlobalParams()));
 986: this.saveProcessInstance(subProcessInstance);
 987: } else {
 988: logger.error(""sub process command params error, cannot find parent instance: {} "", cmdParam);
 989: }
 990: }
 991: ProcessInstanceMap processInstanceMap = JSONUtils.parseObject(cmdParam, ProcessInstanceMap.class);
 992: if (processInstanceMap == null || processInstanceMap.getParentProcessInstanceId() == 0) {
 993: return;
 994: }
 995: // update sub process id to process map table
 996: processInstanceMap.setProcessInstanceId(subProcessInstance.getId());
 997: 
 998: this.updateWorkProcessInstanceMap(processInstanceMap);
 999: 
1000: TaskInstance subTask = this.findTaskInstanceById(processInstanceMap.getParentTaskInstanceId());
1001: if (subTask != null && subTask.isSubProcess() && subTask.getState() == ExecutionStatus.SUBMITTED_SUCCESS) {","public void setSubProcessParam(ProcessInstance subProcessInstance) {
        String cmdParam = subProcessInstance.getCommandParam();
        if (StringUtils.isEmpty(cmdParam)) {
            return;
        }
        Map<String, String> paramMap = JSONUtils.toMap(cmdParam);
        // write sub process id into cmd param.
        if (paramMap.containsKey(CMD_PARAM_SUB_PROCESS)
                && CMD_PARAM_EMPTY_SUB_PROCESS.equals(paramMap.get(CMD_PARAM_SUB_PROCESS))) {
            paramMap.remove(CMD_PARAM_SUB_PROCESS);
            paramMap.put(CMD_PARAM_SUB_PROCESS, String.valueOf(subProcessInstance.getId()));
            subProcessInstance.setCommandParam(JSONUtils.toJsonString(paramMap));
            subProcessInstance.setIsSubProcess(Flag.YES);
            this.saveProcessInstance(subProcessInstance);
        }
        // copy parent instance user def params to sub process..
        String parentInstanceId = paramMap.get(CMD_PARAM_SUB_PROCESS_PARENT_INSTANCE_ID);
        if (StringUtils.isNotEmpty(parentInstanceId)) {
            ProcessInstance parentInstance = findProcessInstanceDetailById(Integer.parseInt(parentInstanceId));
            if (parentInstance != null) {
                subProcessInstance.setGlobalParams(
                        joinGlobalParams(parentInstance.getGlobalParams(), subProcessInstance.getGlobalParams()));
                this.saveProcessInstance(subProcessInstance);
            } else {
                logger.error(""sub process command params error, cannot find parent instance: {} "", cmdParam);
            }
        }
        ProcessInstanceMap processInstanceMap = JSONUtils.parseObject(cmdParam, ProcessInstanceMap.class);
        if (processInstanceMap == null || processInstanceMap.getParentProcessInstanceId() == 0) {
            return;
        }
        // update sub process id to process map table
        processInstanceMap.setProcessInstanceId(subProcessInstance.getId());

        this.updateWorkProcessInstanceMap(processInstanceMap);

        TaskInstance subTask = this.findTaskInstanceById(processInstanceMap.getParentTaskInstanceId());
        if (subTask != null && subTask.isSubProcess() && subTask.getState() == ExecutionStatus.SUBMITTED_SUCCESS) {
            subTask.setState(ExecutionStatus.RUNNING_EXECUTION);
            subTask.setStartTime(new Date());
            this.updateTaskInstance(subTask);
        }
    }",0
dolphinscheduler-2.0.9,NULL_DEREFERENCE,dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/impl/UsersServiceImpl.java,"org.apache.dolphinscheduler.api.service.impl.UsersServiceImpl.batchActivateUser(org.apache.dolphinscheduler.dao.entity.User,java.util.ArrayList):java.util.Map",1195,object `status` last assigned on line 1194 could be null and is dereferenced at line 1195.,"1174: public Map<String, Object> batchActivateUser(User loginUser, List<String> userNames) {
1175: Map<String, Object> result = new HashMap<>();
1176: 
1177: if (!isAdmin(loginUser)) {
1178: putMsg(result, Status.USER_NO_OPERATION_PERM);
1179: return result;
1180: }
1181: 
1182: int totalSuccess = 0;
1183: List<String> successUserNames = new ArrayList<>();
1184: Map<String, Object> successRes = new HashMap<>();
1185: int totalFailed = 0;
1186: List<Map<String, String>> failedInfo = new ArrayList<>();
1187: Map<String, Object> failedRes = new HashMap<>();
1188: for (String userName : userNames) {
1189: Map<String, Object> tmpResult = activateUser(loginUser, userName);
1190: if (tmpResult.get(Constants.STATUS) != Status.SUCCESS) {
1191: totalFailed++;
1192: Map<String, String> failedBody = new HashMap<>();
1193: failedBody.put(""userName"", userName);
1194: Status status = (Status) tmpResult.get(Constants.STATUS);
1195: String errorMessage = MessageFormat.format(status.getMsg(), userName);
1196: failedBody.put(""msg"", errorMessage);
1197: failedInfo.add(failedBody);
1198: } else {
1199: totalSuccess++;
1200: successUserNames.add(userName);
1201: }
1202: }
1203: successRes.put(""sum"", totalSuccess);
1204: successRes.put(""userName"", successUserNames);
1205: failedRes.put(""sum"", totalFailed);
1206: failedRes.put(""info"", failedInfo);
1207: Map<String, Object> res = new HashMap<>();
1208: res.put(""success"", successRes);
1209: res.put(""failed"", failedRes);
1210: putMsg(result, Status.SUCCESS);
1211: result.put(Constants.DATA_LIST, res);
1212: return result;","public Map<String, Object> batchActivateUser(User loginUser, List<String> userNames) {
        Map<String, Object> result = new HashMap<>();

        if (!isAdmin(loginUser)) {
            putMsg(result, Status.USER_NO_OPERATION_PERM);
            return result;
        }

        int totalSuccess = 0;
        List<String> successUserNames = new ArrayList<>();
        Map<String, Object> successRes = new HashMap<>();
        int totalFailed = 0;
        List<Map<String, String>> failedInfo = new ArrayList<>();
        Map<String, Object> failedRes = new HashMap<>();
        for (String userName : userNames) {
            Map<String, Object> tmpResult = activateUser(loginUser, userName);
            if (tmpResult.get(Constants.STATUS) != Status.SUCCESS) {
                totalFailed++;
                Map<String, String> failedBody = new HashMap<>();
                failedBody.put(""userName"", userName);
                Status status = (Status) tmpResult.get(Constants.STATUS);
                String errorMessage = MessageFormat.format(status.getMsg(), userName);
                failedBody.put(""msg"", errorMessage);
                failedInfo.add(failedBody);
            } else {
                totalSuccess++;
                successUserNames.add(userName);
            }
        }
        successRes.put(""sum"", totalSuccess);
        successRes.put(""userName"", successUserNames);
        failedRes.put(""sum"", totalFailed);
        failedRes.put(""info"", failedInfo);
        Map<String, Object> res = new HashMap<>();
        res.put(""success"", successRes);
        res.put(""failed"", failedRes);
        putMsg(result, Status.SUCCESS);
        result.put(Constants.DATA_LIST, res);
        return result;
    }",1
dolphinscheduler-2.0.9,NULL_DEREFERENCE,dolphinscheduler-service/src/main/java/org/apache/dolphinscheduler/service/process/ProcessService.java,"org.apache.dolphinscheduler.service.process.ProcessService.getSubWorkFlowParam(org.apache.dolphinscheduler.dao.entity.ProcessInstanceMap,org.apache.dolphinscheduler.dao.entity.ProcessInstance,java.util.HashMap):java.lang.String",1208,object `cmdParam` last assigned on line 1203 could be null and is dereferenced at line 1208.,"1200: private String getSubWorkFlowParam(ProcessInstanceMap instanceMap, ProcessInstance parentProcessInstance, Map<String, String> fatherParams) {
1201: // set sub work process command
1202: String processMapStr = JSONUtils.toJsonString(instanceMap);
1203: Map<String, String> cmdParam = JSONUtils.toMap(processMapStr);
1204: if (parentProcessInstance.isComplementData()) {
1205: Map<String, String> parentParam = JSONUtils.toMap(parentProcessInstance.getCommandParam());
1206: String endTime = parentParam.get(CMDPARAM_COMPLEMENT_DATA_END_DATE);
1207: String startTime = parentParam.get(CMDPARAM_COMPLEMENT_DATA_START_DATE);
1208: cmdParam.put(CMDPARAM_COMPLEMENT_DATA_END_DATE, endTime);
1209: cmdParam.put(CMDPARAM_COMPLEMENT_DATA_START_DATE, startTime);
1210: processMapStr = JSONUtils.toJsonString(cmdParam);
1211: }
1212: if (fatherParams.size() != 0) {
1213: cmdParam.put(CMD_PARAM_FATHER_PARAMS, JSONUtils.toJsonString(fatherParams));
1214: processMapStr = JSONUtils.toJsonString(cmdParam);
1215: }
1216: return processMapStr;","private String getSubWorkFlowParam(ProcessInstanceMap instanceMap, ProcessInstance parentProcessInstance, Map<String, String> fatherParams) {
        // set sub work process command
        String processMapStr = JSONUtils.toJsonString(instanceMap);
        Map<String, String> cmdParam = JSONUtils.toMap(processMapStr);
        if (parentProcessInstance.isComplementData()) {
            Map<String, String> parentParam = JSONUtils.toMap(parentProcessInstance.getCommandParam());
            String endTime = parentParam.get(CMDPARAM_COMPLEMENT_DATA_END_DATE);
            String startTime = parentParam.get(CMDPARAM_COMPLEMENT_DATA_START_DATE);
            cmdParam.put(CMDPARAM_COMPLEMENT_DATA_END_DATE, endTime);
            cmdParam.put(CMDPARAM_COMPLEMENT_DATA_START_DATE, startTime);
            processMapStr = JSONUtils.toJsonString(cmdParam);
        }
        if (fatherParams.size() != 0) {
            cmdParam.put(CMD_PARAM_FATHER_PARAMS, JSONUtils.toJsonString(fatherParams));
            processMapStr = JSONUtils.toJsonString(cmdParam);
        }
        return processMapStr;
    }",1
dolphinscheduler-2.0.9,NULL_DEREFERENCE,dolphinscheduler-service/src/main/java/org/apache/dolphinscheduler/service/process/ProcessService.java,"org.apache.dolphinscheduler.service.process.ProcessService.getSubWorkFlowParam(org.apache.dolphinscheduler.dao.entity.ProcessInstanceMap,org.apache.dolphinscheduler.dao.entity.ProcessInstance,java.util.HashMap):java.lang.String",1213,object `cmdParam` last assigned on line 1203 could be null and is dereferenced at line 1213.,"1200: private String getSubWorkFlowParam(ProcessInstanceMap instanceMap, ProcessInstance parentProcessInstance, Map<String, String> fatherParams) {
1201: // set sub work process command
1202: String processMapStr = JSONUtils.toJsonString(instanceMap);
1203: Map<String, String> cmdParam = JSONUtils.toMap(processMapStr);
1204: if (parentProcessInstance.isComplementData()) {
1205: Map<String, String> parentParam = JSONUtils.toMap(parentProcessInstance.getCommandParam());
1206: String endTime = parentParam.get(CMDPARAM_COMPLEMENT_DATA_END_DATE);
1207: String startTime = parentParam.get(CMDPARAM_COMPLEMENT_DATA_START_DATE);
1208: cmdParam.put(CMDPARAM_COMPLEMENT_DATA_END_DATE, endTime);
1209: cmdParam.put(CMDPARAM_COMPLEMENT_DATA_START_DATE, startTime);
1210: processMapStr = JSONUtils.toJsonString(cmdParam);
1211: }
1212: if (fatherParams.size() != 0) {
1213: cmdParam.put(CMD_PARAM_FATHER_PARAMS, JSONUtils.toJsonString(fatherParams));
1214: processMapStr = JSONUtils.toJsonString(cmdParam);
1215: }
1216: return processMapStr;","private String getSubWorkFlowParam(ProcessInstanceMap instanceMap, ProcessInstance parentProcessInstance, Map<String, String> fatherParams) {
        // set sub work process command
        String processMapStr = JSONUtils.toJsonString(instanceMap);
        Map<String, String> cmdParam = JSONUtils.toMap(processMapStr);
        if (parentProcessInstance.isComplementData()) {
            Map<String, String> parentParam = JSONUtils.toMap(parentProcessInstance.getCommandParam());
            String endTime = parentParam.get(CMDPARAM_COMPLEMENT_DATA_END_DATE);
            String startTime = parentParam.get(CMDPARAM_COMPLEMENT_DATA_START_DATE);
            cmdParam.put(CMDPARAM_COMPLEMENT_DATA_END_DATE, endTime);
            cmdParam.put(CMDPARAM_COMPLEMENT_DATA_START_DATE, startTime);
            processMapStr = JSONUtils.toJsonString(cmdParam);
        }
        if (fatherParams.size() != 0) {
            cmdParam.put(CMD_PARAM_FATHER_PARAMS, JSONUtils.toJsonString(fatherParams));
            processMapStr = JSONUtils.toJsonString(cmdParam);
        }
        return processMapStr;
    }",1
dolphinscheduler-2.0.9,NULL_DEREFERENCE,dolphinscheduler-service/src/main/java/org/apache/dolphinscheduler/service/process/ProcessService.java,"org.apache.dolphinscheduler.service.process.ProcessService.getSubWorkFlowParam(org.apache.dolphinscheduler.dao.entity.ProcessInstanceMap,org.apache.dolphinscheduler.dao.entity.ProcessInstance,java.util.HashMap):java.lang.String",1206,object `parentParam` last assigned on line 1205 could be null and is dereferenced at line 1206.,"1200: private String getSubWorkFlowParam(ProcessInstanceMap instanceMap, ProcessInstance parentProcessInstance, Map<String, String> fatherParams) {
1201: // set sub work process command
1202: String processMapStr = JSONUtils.toJsonString(instanceMap);
1203: Map<String, String> cmdParam = JSONUtils.toMap(processMapStr);
1204: if (parentProcessInstance.isComplementData()) {
1205: Map<String, String> parentParam = JSONUtils.toMap(parentProcessInstance.getCommandParam());
1206: String endTime = parentParam.get(CMDPARAM_COMPLEMENT_DATA_END_DATE);
1207: String startTime = parentParam.get(CMDPARAM_COMPLEMENT_DATA_START_DATE);
1208: cmdParam.put(CMDPARAM_COMPLEMENT_DATA_END_DATE, endTime);
1209: cmdParam.put(CMDPARAM_COMPLEMENT_DATA_START_DATE, startTime);
1210: processMapStr = JSONUtils.toJsonString(cmdParam);
1211: }
1212: if (fatherParams.size() != 0) {
1213: cmdParam.put(CMD_PARAM_FATHER_PARAMS, JSONUtils.toJsonString(fatherParams));
1214: processMapStr = JSONUtils.toJsonString(cmdParam);
1215: }
1216: return processMapStr;","private String getSubWorkFlowParam(ProcessInstanceMap instanceMap, ProcessInstance parentProcessInstance, Map<String, String> fatherParams) {
        // set sub work process command
        String processMapStr = JSONUtils.toJsonString(instanceMap);
        Map<String, String> cmdParam = JSONUtils.toMap(processMapStr);
        if (parentProcessInstance.isComplementData()) {
            Map<String, String> parentParam = JSONUtils.toMap(parentProcessInstance.getCommandParam());
            String endTime = parentParam.get(CMDPARAM_COMPLEMENT_DATA_END_DATE);
            String startTime = parentParam.get(CMDPARAM_COMPLEMENT_DATA_START_DATE);
            cmdParam.put(CMDPARAM_COMPLEMENT_DATA_END_DATE, endTime);
            cmdParam.put(CMDPARAM_COMPLEMENT_DATA_START_DATE, startTime);
            processMapStr = JSONUtils.toJsonString(cmdParam);
        }
        if (fatherParams.size() != 0) {
            cmdParam.put(CMD_PARAM_FATHER_PARAMS, JSONUtils.toJsonString(fatherParams));
            processMapStr = JSONUtils.toJsonString(cmdParam);
        }
        return processMapStr;
    }",1
dolphinscheduler-2.0.9,NULL_DEREFERENCE,dolphinscheduler-service/src/main/java/org/apache/dolphinscheduler/service/process/ProcessService.java,"org.apache.dolphinscheduler.service.process.ProcessService.createSubProcessCommand(org.apache.dolphinscheduler.dao.entity.ProcessInstance,org.apache.dolphinscheduler.dao.entity.ProcessInstance,org.apache.dolphinscheduler.dao.entity.ProcessInstanceMap,org.apache.dolphinscheduler.dao.entity.TaskInstance):org.apache.dolphinscheduler.dao.entity.Command",1240,object `subProcessParam` last assigned on line 1238 could be null and is dereferenced at line 1240.,"1233: public Command createSubProcessCommand(ProcessInstance parentProcessInstance,
1234: ProcessInstance childInstance,
1235: ProcessInstanceMap instanceMap,
1236: TaskInstance task) {
1237: CommandType commandType = getSubCommandType(parentProcessInstance, childInstance);
1238: Map<String, String> subProcessParam = JSONUtils.toMap(task.getTaskParams());
1239: long childDefineCode = 0L;
1240: if (subProcessParam.containsKey(Constants.CMD_PARAM_SUB_PROCESS_DEFINE_CODE)) {
1241: childDefineCode = Long.parseLong(subProcessParam.get(Constants.CMD_PARAM_SUB_PROCESS_DEFINE_CODE));
1242: }
1243: ProcessDefinition subProcessDefinition = processDefineMapper.queryByCode(childDefineCode);
1244: 
1245: Object localParams = subProcessParam.get(Constants.LOCAL_PARAMS);
1246: List<Property> allParam = JSONUtils.toList(JSONUtils.toJsonString(localParams), Property.class);
1247: Map<String, String> globalMap = this.getGlobalParamMap(parentProcessInstance.getGlobalParams());
1248: Map<String, String> fatherParams = new HashMap<>();
1249: if (CollectionUtils.isNotEmpty(allParam)) {
1250: for (Property info : allParam) {
1251: fatherParams.put(info.getProp(), globalMap.get(info.getProp()));
1252: }
1253: }
1254: String processParam = getSubWorkFlowParam(instanceMap, parentProcessInstance, fatherParams);
1255: int subProcessInstanceId = childInstance == null ? 0 : childInstance.getId();
1256: return new Command(","public Command createSubProcessCommand(ProcessInstance parentProcessInstance,
                                           ProcessInstance childInstance,
                                           ProcessInstanceMap instanceMap,
                                           TaskInstance task) {
        CommandType commandType = getSubCommandType(parentProcessInstance, childInstance);
        Map<String, String> subProcessParam = JSONUtils.toMap(task.getTaskParams());
        long childDefineCode = 0L;
        if (subProcessParam.containsKey(Constants.CMD_PARAM_SUB_PROCESS_DEFINE_CODE)) {
            childDefineCode = Long.parseLong(subProcessParam.get(Constants.CMD_PARAM_SUB_PROCESS_DEFINE_CODE));
        }
        ProcessDefinition subProcessDefinition = processDefineMapper.queryByCode(childDefineCode);

        Object localParams = subProcessParam.get(Constants.LOCAL_PARAMS);
        List<Property> allParam = JSONUtils.toList(JSONUtils.toJsonString(localParams), Property.class);
        Map<String, String> globalMap = this.getGlobalParamMap(parentProcessInstance.getGlobalParams());
        Map<String, String> fatherParams = new HashMap<>();
        if (CollectionUtils.isNotEmpty(allParam)) {
            for (Property info : allParam) {
                fatherParams.put(info.getProp(), globalMap.get(info.getProp()));
            }
        }
        String processParam = getSubWorkFlowParam(instanceMap, parentProcessInstance, fatherParams);
        int subProcessInstanceId = childInstance == null ? 0 : childInstance.getId();
        return new Command(
                commandType,
                TaskDependType.TASK_POST,
                parentProcessInstance.getFailureStrategy(),
                parentProcessInstance.getExecutorId(),
                subProcessDefinition.getCode(),
                processParam,
                parentProcessInstance.getWarningType(),
                parentProcessInstance.getWarningGroupId(),
                parentProcessInstance.getScheduleTime(),
                task.getWorkerGroup(),
                task.getEnvironmentCode(),
                parentProcessInstance.getProcessInstancePriority(),
                parentProcessInstance.getDryRun(),
                subProcessInstanceId,
                subProcessDefinition.getVersion()
        );
    }",1
dolphinscheduler-2.0.9,NULL_DEREFERENCE,dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/master/runner/WorkflowExecuteThread.java,org.apache.dolphinscheduler.server.master.runner.WorkflowExecuteThread.isComplementEnd():boolean,1300,object `cmdParam` last assigned on line 1299 could be null and is dereferenced at line 1300.,https://github.com/apache/dolphinscheduler/blob/2.0.9-release/dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/master/runner/WorkflowExecuteThread.java,"private boolean isComplementEnd() {
        if (!processInstance.isComplementData()) {
            return true;
        }

        try {
            Map<String, String> cmdParam = JSONUtils.toMap(processInstance.getCommandParam());
            Date endTime = DateUtils.getScheduleDate(cmdParam.get(CMDPARAM_COMPLEMENT_DATA_END_DATE));
            return processInstance.getScheduleTime().equals(endTime);
        } catch (Exception e) {
            logger.error(""complement end failed "", e);
            return false;
        }
    }",0
dolphinscheduler-2.0.9,NULL_DEREFERENCE,dolphinscheduler-service/src/main/java/org/apache/dolphinscheduler/service/process/ProcessService.java,org.apache.dolphinscheduler.service.process.ProcessService.changeOutParam(org.apache.dolphinscheduler.dao.entity.TaskInstance):void,1813,object `taskParams` last assigned on line 1811 could be null and is dereferenced at line 1813.,"1802: public void changeOutParam(TaskInstance taskInstance) {
1803: if (StringUtils.isEmpty(taskInstance.getVarPool())) {
1804: return;
1805: }
1806: List<Property> properties = JSONUtils.toList(taskInstance.getVarPool(), Property.class);
1807: if (CollectionUtils.isEmpty(properties)) {
1808: return;
1809: }
1810: //if the result more than one line,just get the first .
1811: Map<String, Object> taskParams = JSONUtils.parseObject(taskInstance.getTaskParams(), new TypeReference<Map<String, Object>>() {
1812: });
1813: Object localParams = taskParams.get(LOCAL_PARAMS);
1814: if (localParams == null) {
1815: return;
1816: }
1817: List<Property> allParam = JSONUtils.toList(JSONUtils.toJsonString(localParams), Property.class);
1818: Map<String, String> outProperty = new HashMap<>();
1819: for (Property info : properties) {
1820: if (info.getDirect() == Direct.OUT) {
1821: outProperty.put(info.getProp(), info.getValue());
1822: }
1823: }
1824: for (Property info : allParam) {
1825: if (info.getDirect() == Direct.OUT) {
1826: String paramName = info.getProp();
1827: info.setValue(outProperty.get(paramName));
1828: }
1829: }
1830: taskParams.put(LOCAL_PARAMS, allParam);
1831: taskInstance.setTaskParams(JSONUtils.toJsonString(taskParams));","public void changeOutParam(TaskInstance taskInstance) {
        if (StringUtils.isEmpty(taskInstance.getVarPool())) {
            return;
        }
        List<Property> properties = JSONUtils.toList(taskInstance.getVarPool(), Property.class);
        if (CollectionUtils.isEmpty(properties)) {
            return;
        }
        //if the result more than one line,just get the first .
        Map<String, Object> taskParams = JSONUtils.parseObject(taskInstance.getTaskParams(), new TypeReference<Map<String, Object>>() {
        });
        Object localParams = taskParams.get(LOCAL_PARAMS);
        if (localParams == null) {
            return;
        }
        List<Property> allParam = JSONUtils.toList(JSONUtils.toJsonString(localParams), Property.class);
        Map<String, String> outProperty = new HashMap<>();
        for (Property info : properties) {
            if (info.getDirect() == Direct.OUT) {
                outProperty.put(info.getProp(), info.getValue());
            }
        }
        for (Property info : allParam) {
            if (info.getDirect() == Direct.OUT) {
                String paramName = info.getProp();
                info.setValue(outProperty.get(paramName));
            }
        }
        taskParams.put(LOCAL_PARAMS, allParam);
        taskInstance.setTaskParams(JSONUtils.toJsonString(taskParams));
    }",0
dolphinscheduler-2.0.9,NULL_DEREFERENCE,dolphinscheduler-service/src/main/java/org/apache/dolphinscheduler/service/process/ProcessService.java,org.apache.dolphinscheduler.service.process.ProcessService.processNeedFailoverProcessInstances(org.apache.dolphinscheduler.dao.entity.ProcessInstance):void,1900,object `processDefinition` last assigned on line 1896 could be null and is dereferenced at line 1900.,"1891: public void processNeedFailoverProcessInstances(ProcessInstance processInstance) {
1892: //1 update processInstance host is null
1893: processInstance.setHost(Constants.NULL);
1894: processInstanceMapper.updateById(processInstance);
1895: 
1896: ProcessDefinition processDefinition = findProcessDefinition(processInstance.getProcessDefinitionCode(), processInstance.getProcessDefinitionVersion());
1897: 
1898: //2 insert into recover command
1899: Command cmd = new Command();
1900: cmd.setProcessDefinitionCode(processDefinition.getCode());
1901: cmd.setProcessDefinitionVersion(processDefinition.getVersion());
1902: cmd.setProcessInstanceId(processInstance.getId());
1903: cmd.setCommandParam(String.format(""{\""%s\"":%d}"", Constants.CMD_PARAM_RECOVER_PROCESS_ID_STRING, processInstance.getId()));
1904: cmd.setExecutorId(processInstance.getExecutorId());
1905: cmd.setCommandType(CommandType.RECOVER_TOLERANCE_FAULT_PROCESS);
1906: createCommand(cmd);","public void processNeedFailoverProcessInstances(ProcessInstance processInstance) {
        //1 update processInstance host is null
        processInstance.setHost(Constants.NULL);
        processInstanceMapper.updateById(processInstance);

        ProcessDefinition processDefinition = findProcessDefinition(processInstance.getProcessDefinitionCode(), processInstance.getProcessDefinitionVersion());

        //2 insert into recover command
        Command cmd = new Command();
        cmd.setProcessDefinitionCode(processDefinition.getCode());
        cmd.setProcessDefinitionVersion(processDefinition.getVersion());
        cmd.setProcessInstanceId(processInstance.getId());
        cmd.setCommandParam(String.format(""{\""%s\"":%d}"", Constants.CMD_PARAM_RECOVER_PROCESS_ID_STRING, processInstance.getId()));
        cmd.setExecutorId(processInstance.getExecutorId());
        cmd.setCommandType(CommandType.RECOVER_TOLERANCE_FAULT_PROCESS);
        createCommand(cmd);
    }
",1
dubbo-3.2,NULL_DEREFERENCE,dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/DefaultServiceDiscoveryFactory.java,org.apache.dubbo.registry.client.DefaultServiceDiscoveryFactory.createDiscovery(org.apache.dubbo.common.URL):org.apache.dubbo.registry.client.ServiceDiscovery,28,object returned by `registryURL.getApplicationModel()` could be null and is dereferenced by call to `NopServiceDiscovery(...)` at line 28.,"27: protected ServiceDiscovery createDiscovery(URL registryURL) {
 28: return new NopServiceDiscovery(registryURL.getApplicationModel(), registryURL);","public class DefaultServiceDiscoveryFactory extends AbstractServiceDiscoveryFactory {
    @Override
    protected ServiceDiscovery createDiscovery(URL registryURL) {
        return new NopServiceDiscovery(registryURL.getApplicationModel(), registryURL);
    }
}",1
dubbo-3.2,NULL_DEREFERENCE,dubbo-common/src/main/java/org/apache/dubbo/rpc/executor/IsolationExecutorSupportFactory.java,org.apache.dubbo.rpc.executor.IsolationExecutorSupportFactory.getIsolationExecutorSupport(org.apache.dubbo.common.URL):org.apache.dubbo.rpc.executor.ExecutorSupport,33,object `factory` last assigned on line 32 could be null and is dereferenced at line 33.,https://github.com/apache/dubbo/blob/3.2/dubbo-common/src/main/java/org/apache/dubbo/rpc/executor/IsolationExecutorSupportFactory.java,"static ExecutorSupport getIsolationExecutorSupport(URL url) {
        ApplicationModel applicationModel = url.getOrDefaultApplicationModel();
        ExtensionLoader<IsolationExecutorSupportFactory> extensionLoader = applicationModel.getExtensionLoader(IsolationExecutorSupportFactory.class);
        IsolationExecutorSupportFactory factory = extensionLoader.getOrDefaultExtension(url.getProtocol());
        return factory.createIsolationExecutorSupport(url);
    }
",1
dubbo-3.2,NULL_DEREFERENCE,dubbo-serialization/dubbo-serialization-hessian2/src/main/java/org/apache/dubbo/common/serialize/hessian2/Hessian2ClassLoaderListener.java,"org.apache.dubbo.common.serialize.hessian2.Hessian2ClassLoaderListener.onRemoveClassLoader(org.apache.dubbo.rpc.model.FrameworkModel,java.lang.ClassLoader):void",31,object `hessian2FactoryManager` last assigned on line 30 could be null and is dereferenced at line 31.,"29: public void onRemoveClassLoader(FrameworkModel scopeModel, ClassLoader classLoader) {
 30: Hessian2FactoryManager hessian2FactoryManager = scopeModel.getBeanFactory().getBean(Hessian2FactoryManager.class);
 31: hessian2FactoryManager.onRemoveClassLoader(classLoader);","public void onRemoveClassLoader(FrameworkModel scopeModel, ClassLoader classLoader) {
        Hessian2FactoryManager hessian2FactoryManager = scopeModel.getBeanFactory().getBean(Hessian2FactoryManager.class);
        hessian2FactoryManager.onRemoveClassLoader(classLoader);
    }",1
dubbo-3.2,NULL_DEREFERENCE,dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/status/ServerStatusChecker.java,org.apache.dubbo.rpc.protocol.dubbo.status.ServerStatusChecker.check():org.apache.dubbo.common.status.Status,44,object `server` last assigned on line 43 could be null and is dereferenced at line 44.,"35: public Status check() {
 36: List<ProtocolServer> servers = DubboProtocol.getDubboProtocol().getServers();
 37: if (servers == null || servers.isEmpty()) {
 38: return new Status(Status.Level.UNKNOWN);
 39: }
 40: Status.Level level = Status.Level.OK;
 41: StringBuilder buf = new StringBuilder();
 42: for (ProtocolServer protocolServer : servers) {
 43: RemotingServer server = protocolServer.getRemotingServer();
 44: if (!server.isBound()) {
 45: level = Status.Level.ERROR;
 46: buf.setLength(0);
 47: buf.append(server.getLocalAddress());
 48: break;
 49: }
 50: if (buf.length() > 0) {
 51: buf.append(',');
 52: }
 53: buf.append(server.getLocalAddress());
 54: buf.append(""(clients:"");
 55: buf.append(server.getChannels().size());
 56: buf.append(')');
 57: }
 58: return new Status(level, buf.toString());","public Status check() {
        List<ProtocolServer> servers = DubboProtocol.getDubboProtocol().getServers();
        if (servers == null || servers.isEmpty()) {
            return new Status(Status.Level.UNKNOWN);
        }
        Status.Level level = Status.Level.OK;
        StringBuilder buf = new StringBuilder();
        for (ProtocolServer protocolServer : servers) {
            RemotingServer server = protocolServer.getRemotingServer();
            if (!server.isBound()) {
                level = Status.Level.ERROR;
                buf.setLength(0);
                buf.append(server.getLocalAddress());
                break;
            }
            if (buf.length() > 0) {
                buf.append(',');
            }
            buf.append(server.getLocalAddress());
            buf.append(""(clients:"");
            buf.append(server.getChannels().size());
            buf.append(')');
        }
        return new Status(level, buf.toString());
    }
",0
dubbo-3.2,NULL_DEREFERENCE,dubbo-metadata/dubbo-metadata-processor/src/main/java/org/apache/dubbo/metadata/annotation/processing/builder/MethodDefinitionBuilder.java,"org.apache.dubbo.metadata.annotation.processing.builder.MethodDefinitionBuilder.build(javax.annotation.processing.ProcessingEnvironment,javax.lang.model.element.ExecutableElement,java.util.HashMap):org.apache.dubbo.metadata.definition.model.MethodDefinition",43,object returned by `getReturnType(method)` could be null and is dereferenced by call to `setReturnType(...)` at line 43.,"40: static MethodDefinition build(ProcessingEnvironment processingEnv, ExecutableElement method, Map<String, TypeDefinition> typeCache) {
 41: MethodDefinition methodDefinition = new MethodDefinition();
 42: methodDefinition.setName(getMethodName(method));
 43: methodDefinition.setReturnType(getReturnType(method));
 44: methodDefinition.setParameterTypes(getMethodParameterTypes(method));
 45: methodDefinition.setParameters(getMethodParameters(processingEnv, method, typeCache));
 46: return methodDefinition;","static MethodDefinition build(ProcessingEnvironment processingEnv, ExecutableElement method, Map<String, TypeDefinition> typeCache) {
        MethodDefinition methodDefinition = new MethodDefinition();
        methodDefinition.setName(getMethodName(method));
        methodDefinition.setReturnType(getReturnType(method));
        methodDefinition.setParameterTypes(getMethodParameterTypes(method));
        methodDefinition.setParameters(getMethodParameters(processingEnv, method, typeCache));
        return methodDefinition;
    }",1
dubbo-3.2,NULL_DEREFERENCE,dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/protocol/PermittedSerializationKeeper.java,org.apache.dubbo.rpc.protocol.PermittedSerializationKeeper.registerService(org.apache.dubbo.common.URL):void,41,object returned by `url.getServiceKey()` could be null and is dereferenced by call to `keyWithoutGroup(...)` at line 41.,"40: public void registerService(URL url) {
 41: Set<Byte> set = ConcurrentHashMapUtils.computeIfAbsent(serviceToSerializationId, keyWithoutGroup(url.getServiceKey()), k -> new ConcurrentHashSet<>());
 42: Collection<String> serializations = UrlUtils.allSerializations(url);
 43: for (String serialization : serializations) {","public void registerService(URL url) {
        Set<Byte> set = ConcurrentHashMapUtils.computeIfAbsent(serviceToSerializationId, keyWithoutGroup(url.getServiceKey()), k -> new ConcurrentHashSet<>());
        Collection<String> serializations = UrlUtils.allSerializations(url);
        for (String serialization : serializations) {
            Byte id = CodecSupport.getIDByName(serialization);
            if (id != null) {
                set.add(id);
                globalPermittedSerializationIds.add(id);
            }
        }
    }",1
dubbo-3.2,NULL_DEREFERENCE,dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/command/impl/PortTelnet.java,"org.apache.dubbo.qos.command.impl.PortTelnet.execute(org.apache.dubbo.qos.api.CommandContext,java.lang.String[]):java.lang.String",73,object returned by `s.getUrl()` could be null and is dereferenced at line 73.,"42: public String execute(CommandContext commandContext, String[] args) {
 43: StringBuilder buf = new StringBuilder();
 44: String port = null;
 45: boolean detail = false;
 46: if (args.length > 0) {
 47: for (String part : args) {
 48: if (""-l"".equals(part)) {
 49: detail = true;
 50: } else {
 51: if (!StringUtils.isNumber(part)) {
 52: return ""Illegal port "" + part + "", must be integer."";
 53: }
 54: port = part;
 55: }
 56: }
 57: }
 58: if (StringUtils.isEmpty(port)) {
 59: for (ProtocolServer server : dubboProtocol.getServers()) {
 60: if (buf.length() > 0) {
 61: buf.append(""\r\n"");
 62: }
 63: if (detail) {
 64: buf.append(server.getUrl().getProtocol()).append(""://"").append(server.getUrl().getAddress());
 65: } else {
 66: buf.append(server.getUrl().getPort());
 67: }
 68: }
 69: } else {
 70: int p = Integer.parseInt(port);
 71: ProtocolServer protocolServer = null;
 72: for (ProtocolServer s : dubboProtocol.getServers()) {
 73: if (p == s.getUrl().getPort()) {
 74: protocolServer = s;
 75: break;
 76: }
 77: }
 78: if (protocolServer != null) {
 79: ExchangeServer server = (ExchangeServer) protocolServer.getRemotingServer();
 80: Collection<ExchangeChannel> channels = server.getExchangeChannels();
 81: for (ExchangeChannel c : channels) {
 82: if (buf.length() > 0) {
 83: buf.append(""\r\n"");
 84: }
 85: if (detail) {
 86: buf.append(c.getRemoteAddress()).append("" -> "").append(c.getLocalAddress());
 87: } else {
 88: buf.append(c.getRemoteAddress());
 89: }
 90: }
 91: } else {
 92: buf.append(""No such port "").append(port);
 93: }
 94: }
 95: return buf.toString();","public String execute(CommandContext commandContext, String[] args) {
        StringBuilder buf = new StringBuilder();
        String port = null;
        boolean detail = false;
        if (args.length > 0) {
            for (String part : args) {
                if (""-l"".equals(part)) {
                    detail = true;
                } else {
                    if (!StringUtils.isNumber(part)) {
                        return ""Illegal port "" + part + "", must be integer."";
                    }
                    port = part;
                }
            }
        }
        if (StringUtils.isEmpty(port)) {
            for (ProtocolServer server : dubboProtocol.getServers()) {
                if (buf.length() > 0) {
                    buf.append(""\r\n"");
                }
                if (detail) {
                    buf.append(server.getUrl().getProtocol()).append(""://"").append(server.getUrl().getAddress());
                } else {
                    buf.append(server.getUrl().getPort());
                }
            }
        } else {
            int p = Integer.parseInt(port);
            ProtocolServer protocolServer = null;
            for (ProtocolServer s : dubboProtocol.getServers()) {
                if (p == s.getUrl().getPort()) {
                    protocolServer = s;
                    break;
                }
            }
            if (protocolServer != null) {
                ExchangeServer server = (ExchangeServer) protocolServer.getRemotingServer();
                Collection<ExchangeChannel> channels = server.getExchangeChannels();
                for (ExchangeChannel c : channels) {
                    if (buf.length() > 0) {
                        buf.append(""\r\n"");
                    }
                    if (detail) {
                        buf.append(c.getRemoteAddress()).append("" -> "").append(c.getLocalAddress());
                    } else {
                        buf.append(c.getRemoteAddress());
                    }
                }
            } else {
                buf.append(""No such port "").append(port);
            }
        }
        return buf.toString();
    }",0
dubbo-3.2,NULL_DEREFERENCE,dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/command/impl/PortTelnet.java,"org.apache.dubbo.qos.command.impl.PortTelnet.execute(org.apache.dubbo.qos.api.CommandContext,java.lang.String[]):java.lang.String",64,object returned by `server.getUrl()` could be null and is dereferenced at line 64.,"42: public String execute(CommandContext commandContext, String[] args) {
 43: StringBuilder buf = new StringBuilder();
 44: String port = null;
 45: boolean detail = false;
 46: if (args.length > 0) {
 47: for (String part : args) {
 48: if (""-l"".equals(part)) {
 49: detail = true;
 50: } else {
 51: if (!StringUtils.isNumber(part)) {
 52: return ""Illegal port "" + part + "", must be integer."";
 53: }
 54: port = part;
 55: }
 56: }
 57: }
 58: if (StringUtils.isEmpty(port)) {
 59: for (ProtocolServer server : dubboProtocol.getServers()) {
 60: if (buf.length() > 0) {
 61: buf.append(""\r\n"");
 62: }
 63: if (detail) {
 64: buf.append(server.getUrl().getProtocol()).append(""://"").append(server.getUrl().getAddress());
 65: } else {
 66: buf.append(server.getUrl().getPort());
 67: }
 68: }
 69: } else {
 70: int p = Integer.parseInt(port);
 71: ProtocolServer protocolServer = null;
 72: for (ProtocolServer s : dubboProtocol.getServers()) {
 73: if (p == s.getUrl().getPort()) {
 74: protocolServer = s;
 75: break;
 76: }
 77: }
 78: if (protocolServer != null) {
 79: ExchangeServer server = (ExchangeServer) protocolServer.getRemotingServer();
 80: Collection<ExchangeChannel> channels = server.getExchangeChannels();
 81: for (ExchangeChannel c : channels) {
 82: if (buf.length() > 0) {
 83: buf.append(""\r\n"");
 84: }
 85: if (detail) {
 86: buf.append(c.getRemoteAddress()).append("" -> "").append(c.getLocalAddress());
 87: } else {
 88: buf.append(c.getRemoteAddress());
 89: }
 90: }
 91: } else {
 92: buf.append(""No such port "").append(port);
 93: }
 94: }
 95: return buf.toString();","public String execute(CommandContext commandContext, String[] args) {
        StringBuilder buf = new StringBuilder();
        String port = null;
        boolean detail = false;
        if (args.length > 0) {
            for (String part : args) {
                if (""-l"".equals(part)) {
                    detail = true;
                } else {
                    if (!StringUtils.isNumber(part)) {
                        return ""Illegal port "" + part + "", must be integer."";
                    }
                    port = part;
                }
            }
        }
        if (StringUtils.isEmpty(port)) {
            for (ProtocolServer server : dubboProtocol.getServers()) {
                if (buf.length() > 0) {
                    buf.append(""\r\n"");
                }
                if (detail) {
                    buf.append(server.getUrl().getProtocol()).append(""://"").append(server.getUrl().getAddress());
                } else {
                    buf.append(server.getUrl().getPort());
                }
            }
        } else {
            int p = Integer.parseInt(port);
            ProtocolServer protocolServer = null;
            for (ProtocolServer s : dubboProtocol.getServers()) {
                if (p == s.getUrl().getPort()) {
                    protocolServer = s;
                    break;
                }
            }
            if (protocolServer != null) {
                ExchangeServer server = (ExchangeServer) protocolServer.getRemotingServer();
                Collection<ExchangeChannel> channels = server.getExchangeChannels();
                for (ExchangeChannel c : channels) {
                    if (buf.length() > 0) {
                        buf.append(""\r\n"");
                    }
                    if (detail) {
                        buf.append(c.getRemoteAddress()).append("" -> "").append(c.getLocalAddress());
                    } else {
                        buf.append(c.getRemoteAddress());
                    }
                }
            } else {
                buf.append(""No such port "").append(port);
            }
        }
        return buf.toString();
    }",0
dubbo-3.2,NULL_DEREFERENCE,dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/command/impl/PortTelnet.java,"org.apache.dubbo.qos.command.impl.PortTelnet.execute(org.apache.dubbo.qos.api.CommandContext,java.lang.String[]):java.lang.String",66,object returned by `server.getUrl()` could be null and is dereferenced at line 66.,"42: public String execute(CommandContext commandContext, String[] args) {
 43: StringBuilder buf = new StringBuilder();
 44: String port = null;
 45: boolean detail = false;
 46: if (args.length > 0) {
 47: for (String part : args) {
 48: if (""-l"".equals(part)) {
 49: detail = true;
 50: } else {
 51: if (!StringUtils.isNumber(part)) {
 52: return ""Illegal port "" + part + "", must be integer."";
 53: }
 54: port = part;
 55: }
 56: }
 57: }
 58: if (StringUtils.isEmpty(port)) {
 59: for (ProtocolServer server : dubboProtocol.getServers()) {
 60: if (buf.length() > 0) {
 61: buf.append(""\r\n"");
 62: }
 63: if (detail) {
 64: buf.append(server.getUrl().getProtocol()).append(""://"").append(server.getUrl().getAddress());
 65: } else {
 66: buf.append(server.getUrl().getPort());
 67: }
 68: }
 69: } else {
 70: int p = Integer.parseInt(port);
 71: ProtocolServer protocolServer = null;
 72: for (ProtocolServer s : dubboProtocol.getServers()) {
 73: if (p == s.getUrl().getPort()) {
 74: protocolServer = s;
 75: break;
 76: }
 77: }
 78: if (protocolServer != null) {
 79: ExchangeServer server = (ExchangeServer) protocolServer.getRemotingServer();
 80: Collection<ExchangeChannel> channels = server.getExchangeChannels();
 81: for (ExchangeChannel c : channels) {
 82: if (buf.length() > 0) {
 83: buf.append(""\r\n"");
 84: }
 85: if (detail) {
 86: buf.append(c.getRemoteAddress()).append("" -> "").append(c.getLocalAddress());
 87: } else {
 88: buf.append(c.getRemoteAddress());
 89: }
 90: }
 91: } else {
 92: buf.append(""No such port "").append(port);
 93: }
 94: }
 95: return buf.toString();","public String execute(CommandContext commandContext, String[] args) {
        StringBuilder buf = new StringBuilder();
        String port = null;
        boolean detail = false;
        if (args.length > 0) {
            for (String part : args) {
                if (""-l"".equals(part)) {
                    detail = true;
                } else {
                    if (!StringUtils.isNumber(part)) {
                        return ""Illegal port "" + part + "", must be integer."";
                    }
                    port = part;
                }
            }
        }
        if (StringUtils.isEmpty(port)) {
            for (ProtocolServer server : dubboProtocol.getServers()) {
                if (buf.length() > 0) {
                    buf.append(""\r\n"");
                }
                if (detail) {
                    buf.append(server.getUrl().getProtocol()).append(""://"").append(server.getUrl().getAddress());
                } else {
                    buf.append(server.getUrl().getPort());
                }
            }
        } else {
            int p = Integer.parseInt(port);
            ProtocolServer protocolServer = null;
            for (ProtocolServer s : dubboProtocol.getServers()) {
                if (p == s.getUrl().getPort()) {
                    protocolServer = s;
                    break;
                }
            }
            if (protocolServer != null) {
                ExchangeServer server = (ExchangeServer) protocolServer.getRemotingServer();
                Collection<ExchangeChannel> channels = server.getExchangeChannels();
                for (ExchangeChannel c : channels) {
                    if (buf.length() > 0) {
                        buf.append(""\r\n"");
                    }
                    if (detail) {
                        buf.append(c.getRemoteAddress()).append("" -> "").append(c.getLocalAddress());
                    } else {
                        buf.append(c.getRemoteAddress());
                    }
                }
            } else {
                buf.append(""No such port "").append(port);
            }
        }
        return buf.toString();
    }",0
dubbo-3.2,NULL_DEREFERENCE,dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/status/RegistryStatusChecker.java,org.apache.dubbo.registry.status.RegistryStatusChecker.check():org.apache.dubbo.common.status.Status,44,object `registryManager` last assigned on line 43 could be null and is dereferenced at line 44.,"42: public Status check() {
 43: RegistryManager registryManager = applicationModel.getBeanFactory().getBean(RegistryManager.class);
 44: Collection<Registry> registries = registryManager.getRegistries();
 45: if (registries.isEmpty()) {
 46: return new Status(Status.Level.UNKNOWN);
 47: }
 48: Status.Level level = Status.Level.OK;
 49: StringBuilder buf = new StringBuilder();
 50: for (Registry registry : registries) {
 51: if (buf.length() > 0) {
 52: buf.append(',');
 53: }
 54: buf.append(registry.getUrl().getAddress());
 55: if (!registry.isAvailable()) {
 56: level = Status.Level.ERROR;
 57: buf.append(""(disconnected)"");
 58: } else {
 59: buf.append(""(connected)"");
 60: }
 61: }
 62: return new Status(level, buf.toString());","public Status check() {
        RegistryManager registryManager = applicationModel.getBeanFactory().getBean(RegistryManager.class);
        Collection<Registry> registries = registryManager.getRegistries();
        if (registries.isEmpty()) {
            return new Status(Status.Level.UNKNOWN);
        }
        Status.Level level = Status.Level.OK;
        StringBuilder buf = new StringBuilder();
        for (Registry registry : registries) {
            if (buf.length() > 0) {
                buf.append(',');
            }
            buf.append(registry.getUrl().getAddress());
            if (!registry.isAvailable()) {
                level = Status.Level.ERROR;
                buf.append(""(disconnected)"");
            } else {
                buf.append(""(connected)"");
            }
        }
        return new Status(level, buf.toString());
    }",1
dubbo-3.2,NULL_DEREFERENCE,dubbo-metadata/dubbo-metadata-processor/src/main/java/org/apache/dubbo/metadata/annotation/processing/builder/GeneralTypeDefinitionBuilder.java,"org.apache.dubbo.metadata.annotation.processing.builder.GeneralTypeDefinitionBuilder.build(javax.annotation.processing.ProcessingEnvironment,javax.lang.model.type.DeclaredType,java.util.Map):org.apache.dubbo.metadata.definition.model.TypeDefinition",49,object `typeElement` last assigned on line 47 could be null and is dereferenced by call to `buildProperties(...)` at line 49.,"43: public TypeDefinition build(ProcessingEnvironment processingEnv, DeclaredType type, Map<String, TypeDefinition> typeCache) {
 44: 
 45: String typeName = type.toString();
 46: 
 47: TypeElement typeElement = getType(processingEnv, typeName);
 48: 
 49: return buildProperties(processingEnv, typeElement, typeCache);","public TypeDefinition build(ProcessingEnvironment processingEnv, DeclaredType type, Map<String, TypeDefinition> typeCache) {

        String typeName = type.toString();

        TypeElement typeElement = getType(processingEnv, typeName);

        return buildProperties(processingEnv, typeElement, typeCache);
    }
",1
dubbo-3.2,NULL_DEREFERENCE,dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/command/impl/GetRouterSnapshot.java,"org.apache.dubbo.qos.command.impl.GetRouterSnapshot.execute(org.apache.dubbo.qos.api.CommandContext,java.lang.String[]):java.lang.String",59,object `directory` last assigned on line 58 could be null and is dereferenced at line 59.,"43: public String execute(CommandContext commandContext, String[] args) {
 44: if (args.length != 1) {
 45: return ""args count should be 1. example getRouterSnapshot xx.xx.xxx.service"";
 46: }
 47: String servicePattern = args[0];
 48: StringBuilder stringBuilder = new StringBuilder();
 49: for (ConsumerModel consumerModel : frameworkModel.getServiceRepository().allConsumerModels()) {
 50: try {
 51: ServiceMetadata metadata = consumerModel.getServiceMetadata();
 52: if (metadata.getServiceKey().matches(servicePattern) || metadata.getDisplayServiceKey().matches(servicePattern)) {
 53: Object object = metadata.getAttribute(CommonConstants.CURRENT_CLUSTER_INVOKER_KEY);
 54: Map<Registry, MigrationInvoker<?>> invokerMap;
 55: if (object instanceof Map) {
 56: invokerMap = (Map<Registry, MigrationInvoker<?>>) object;
 57: for (Map.Entry<Registry, MigrationInvoker<?>> invokerEntry : invokerMap.entrySet()) {
 58: Directory<?> directory = invokerEntry.getValue().getDirectory();
 59: StateRouter<?> headStateRouter = directory.getRouterChain().getHeadStateRouter();
 60: stringBuilder.append(metadata.getServiceKey()).append('@').append(Integer.toHexString(System.identityHashCode(metadata)))
 61: .append(""\n"")
 62: .append(""[ All Invokers:"").append(directory.getAllInvokers().size()).append("" ] "")
 63: .append(""[ Valid Invokers: "").append(((AbstractDirectory<?>)directory).getValidInvokers().size()).append("" ]\n"")
 64: .append(""\n"")
 65: .append(headStateRouter.buildSnapshot())
 66: .append(""\n\n"");
 67: }
 68: }
 69: }
 70: } catch (Throwable ignore) {
 71: 
 72: }
 73: }
 74: return stringBuilder.toString();","public String execute(CommandContext commandContext, String[] args) {
        if (args.length != 1) {
            return ""args count should be 1. example getRouterSnapshot xx.xx.xxx.service"";
        }
        String servicePattern = args[0];
        StringBuilder stringBuilder = new StringBuilder();
        for (ConsumerModel consumerModel : frameworkModel.getServiceRepository().allConsumerModels()) {
            try {
                ServiceMetadata metadata = consumerModel.getServiceMetadata();
                if (metadata.getServiceKey().matches(servicePattern) || metadata.getDisplayServiceKey().matches(servicePattern)) {
                    Object object = metadata.getAttribute(CommonConstants.CURRENT_CLUSTER_INVOKER_KEY);
                    Map<Registry, MigrationInvoker<?>> invokerMap;
                    if (object instanceof Map) {
                        invokerMap = (Map<Registry, MigrationInvoker<?>>) object;
                        for (Map.Entry<Registry, MigrationInvoker<?>> invokerEntry : invokerMap.entrySet()) {
                            Directory<?> directory = invokerEntry.getValue().getDirectory();
                            StateRouter<?> headStateRouter = directory.getRouterChain().getHeadStateRouter();
                            stringBuilder.append(metadata.getServiceKey()).append('@').append(Integer.toHexString(System.identityHashCode(metadata)))
                                .append(""\n"")
                                .append(""[ All Invokers:"").append(directory.getAllInvokers().size()).append("" ] "")
                                .append(""[ Valid Invokers: "").append(((AbstractDirectory<?>)directory).getValidInvokers().size()).append("" ]\n"")
                                .append(""\n"")
                                .append(headStateRouter.buildSnapshot())
                                .append(""\n\n"");
                        }
                    }
                }
            } catch (Throwable ignore) {

            }
        }
        return stringBuilder.toString();
    }",1
dubbo-3.2,NULL_DEREFERENCE,dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/status/ThreadPoolStatusChecker.java,org.apache.dubbo.rpc.protocol.dubbo.status.ThreadPoolStatusChecker.check():org.apache.dubbo.common.status.Status,45,object `dataStore` last assigned on line 44 could be null and is dereferenced at line 45.,"43: public Status check() {
 44: DataStore dataStore = applicationModel.getExtensionLoader(DataStore.class).getDefaultExtension();
 45: Map<String, Object> executors = dataStore.get(CommonConstants.EXECUTOR_SERVICE_COMPONENT_KEY);
 46: 
 47: StringBuilder msg = new StringBuilder();
 48: Status.Level level = Status.Level.OK;
 49: for (Map.Entry<String, Object> entry : executors.entrySet()) {
 50: String port = entry.getKey();
 51: ExecutorService executor = (ExecutorService) entry.getValue();
 52: 
 53: if (executor instanceof ThreadPoolExecutor) {
 54: ThreadPoolExecutor tp = (ThreadPoolExecutor) executor;
 55: boolean ok = tp.getActiveCount() < tp.getMaximumPoolSize() - 1;
 56: Status.Level lvl = Status.Level.OK;
 57: if (!ok) {
 58: level = Status.Level.WARN;
 59: lvl = Status.Level.WARN;
 60: }
 61: 
 62: if (msg.length() > 0) {
 63: msg.append(';');
 64: }
 65: msg.append(""Pool status:"").append(lvl).append("", max:"").append(tp.getMaximumPoolSize()).append("", core:"")
 66: .append(tp.getCorePoolSize()).append("", largest:"").append(tp.getLargestPoolSize()).append("", active:"")
 67: .append(tp.getActiveCount()).append("", task:"").append(tp.getTaskCount()).append("", service port: "").append(port);
 68: }
 69: }
 70: return msg.length() == 0 ? new Status(Status.Level.UNKNOWN) : new Status(level, msg.toString());","public Status check() {
        DataStore dataStore = applicationModel.getExtensionLoader(DataStore.class).getDefaultExtension();
        Map<String, Object> executors = dataStore.get(CommonConstants.EXECUTOR_SERVICE_COMPONENT_KEY);

        StringBuilder msg = new StringBuilder();
        Status.Level level = Status.Level.OK;
        for (Map.Entry<String, Object> entry : executors.entrySet()) {
            String port = entry.getKey();
            ExecutorService executor = (ExecutorService) entry.getValue();

            if (executor instanceof ThreadPoolExecutor) {
                ThreadPoolExecutor tp = (ThreadPoolExecutor) executor;
                boolean ok = tp.getActiveCount() < tp.getMaximumPoolSize() - 1;
                Status.Level lvl = Status.Level.OK;
                if (!ok) {
                    level = Status.Level.WARN;
                    lvl = Status.Level.WARN;
                }

                if (msg.length() > 0) {
                    msg.append(';');
                }
                msg.append(""Pool status:"").append(lvl).append("", max:"").append(tp.getMaximumPoolSize()).append("", core:"")
                    .append(tp.getCorePoolSize()).append("", largest:"").append(tp.getLargestPoolSize()).append("", active:"")
                    .append(tp.getActiveCount()).append("", task:"").append(tp.getTaskCount()).append("", service port: "").append(port);
            }
        }
        return msg.length() == 0 ? new Status(Status.Level.UNKNOWN) : new Status(level, msg.toString());
    }
",1
dubbo-3.2,NULL_DEREFERENCE,dubbo-spring-boot/dubbo-spring-boot-compatible/actuator/src/main/java/org/apache/dubbo/spring/boot/actuate/endpoint/metadata/DubboShutdownMetadata.java,org.apache.dubbo.spring.boot.actuate.endpoint.metadata.DubboShutdownMetadata.shutdown():java.util.Map,50,object `registryManager` last assigned on line 48 could be null and is dereferenced at line 50.,"43: public Map<String, Object> shutdown() throws Exception {
 44: 
 45: Map<String, Object> shutdownCountData = new LinkedHashMap<>();
 46: 
 47: // registries
 48: RegistryManager registryManager = applicationModel.getBeanFactory().getBean(RegistryManager.class);
 49: 
 50: int registriesCount = registryManager.getRegistries().size();
 51: 
 52: // protocols
 53: int protocolsCount = getProtocolConfigsBeanMap().size();
 54: 
 55: shutdownCountData.put(""registries"", registriesCount);
 56: shutdownCountData.put(""protocols"", protocolsCount);
 57: 
 58: // Service Beans
 59: Map<String, ServiceBean> serviceBeansMap = getServiceBeansMap();
 60: if (!serviceBeansMap.isEmpty()) {
 61: for (ServiceBean serviceBean : serviceBeansMap.values()) {
 62: serviceBean.destroy();
 63: }
 64: }
 65: shutdownCountData.put(""services"", serviceBeansMap.size());
 66: 
 67: // Reference Beans
 68: Collection<ReferenceConfigBase<?>> references = applicationModel.getDefaultModule().getConfigManager().getReferences();
 69: for (ReferenceConfigBase<?> reference : references) {
 70: reference.destroy();
 71: }
 72: shutdownCountData.put(""references"", references.size());
 73: 
 74: // Set Result to complete
 75: Map<String, Object> shutdownData = new TreeMap<>();
 76: shutdownData.put(""shutdown.count"", shutdownCountData);
 77: 
 78: 
 79: return shutdownData;","public Map<String, Object> shutdown() throws Exception {

        Map<String, Object> shutdownCountData = new LinkedHashMap<>();

        // registries
        RegistryManager registryManager = applicationModel.getBeanFactory().getBean(RegistryManager.class);

        int registriesCount = registryManager.getRegistries().size();

        // protocols
        int protocolsCount = getProtocolConfigsBeanMap().size();

        shutdownCountData.put(""registries"", registriesCount);
        shutdownCountData.put(""protocols"", protocolsCount);

        // Service Beans
        Map<String, ServiceBean> serviceBeansMap = getServiceBeansMap();
        if (!serviceBeansMap.isEmpty()) {
            for (ServiceBean serviceBean : serviceBeansMap.values()) {
                serviceBean.destroy();
            }
        }
        shutdownCountData.put(""services"", serviceBeansMap.size());

        // Reference Beans
        Collection<ReferenceConfigBase<?>> references = applicationModel.getDefaultModule().getConfigManager().getReferences();
        for (ReferenceConfigBase<?> reference : references) {
            reference.destroy();
        }
        shutdownCountData.put(""references"", references.size());

        // Set Result to complete
        Map<String, Object> shutdownData = new TreeMap<>();
        shutdownData.put(""shutdown.count"", shutdownCountData);


        return shutdownData;
    }",0
dubbo-3.2,NULL_DEREFERENCE,dubbo-common/src/main/java/org/apache/dubbo/common/compiler/support/AdaptiveCompiler.java,"org.apache.dubbo.common.compiler.support.AdaptiveCompiler.compile(java.lang.Class,java.lang.String,java.lang.ClassLoader):java.lang.Class",53,object `compiler` last assigned on line 51 could be null and is dereferenced at line 53.,"44: public Class<?> compile(Class<?> neighbor, String code, ClassLoader classLoader) {
 45: Compiler compiler;
 46: ExtensionLoader<Compiler> loader = frameworkModel.getExtensionLoader(Compiler.class);
 47: String name = DEFAULT_COMPILER; // copy reference
 48: if (name != null && name.length() > 0) {
 49: compiler = loader.getExtension(name);
 50: } else {
 51: compiler = loader.getDefaultExtension();
 52: }
 53: return compiler.compile(neighbor, code, classLoader);","public Class<?> compile(Class<?> neighbor, String code, ClassLoader classLoader) {
        Compiler compiler;
        ExtensionLoader<Compiler> loader = frameworkModel.getExtensionLoader(Compiler.class);
        String name = DEFAULT_COMPILER; // copy reference
        if (name != null && name.length() > 0) {
            compiler = loader.getExtension(name);
        } else {
            compiler = loader.getDefaultExtension();
        }
        return compiler.compile(neighbor, code, classLoader);
    }
",0
dubbo-3.2,NULL_DEREFERENCE,dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/protocol/ProtocolSerializationWrapper.java,org.apache.dubbo.rpc.protocol.ProtocolSerializationWrapper.export(org.apache.dubbo.rpc.Invoker):org.apache.dubbo.rpc.Exporter,46,object returned by `getFrameworkModel(invoker.getUrl().getScopeModel()).getBeanFactory().getBean(org.apache.dubbo.rpc.protocol.PermittedSerializationKeeper)` could be null and is dereferenced at line 46.,"45: public <T> Exporter<T> export(Invoker<T> invoker) throws RpcException {
 46: getFrameworkModel(invoker.getUrl().getScopeModel()).getBeanFactory().getBean(PermittedSerializationKeeper.class).registerService(invoker.getUrl());
 47: return protocol.export(invoker);","public <T> Exporter<T> export(Invoker<T> invoker) throws RpcException {
        getFrameworkModel(invoker.getUrl().getScopeModel()).getBeanFactory().getBean(PermittedSerializationKeeper.class).registerService(invoker.getUrl());
        return protocol.export(invoker);
    }",1
dubbo-3.2,NULL_DEREFERENCE,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/configurator/parser/ConfigParser.java,org.apache.dubbo.rpc.cluster.configurator.parser.ConfigParser.parseConfigurators(java.lang.String):java.util.List,60,object `items` last assigned on line 57 could be null and is dereferenced at line 60.,"46: public static List<URL> parseConfigurators(String rawConfig) {
 47: // compatible url JsonArray, such as [ ""override://xxx"", ""override://xxx"" ]
 48: List<URL> compatibleUrls = parseJsonArray(rawConfig);
 49: if (CollectionUtils.isNotEmpty(compatibleUrls)) {
 50: return compatibleUrls;
 51: }
 52: 
 53: List<URL> urls = new ArrayList<>();
 54: ConfiguratorConfig configuratorConfig = parseObject(rawConfig);
 55: 
 56: String scope = configuratorConfig.getScope();
 57: List<ConfigItem> items = configuratorConfig.getConfigs();
 58: 
 59: if (ConfiguratorConfig.SCOPE_APPLICATION.equals(scope)) {
 60: items.forEach(item -> urls.addAll(appItemToUrls(item, configuratorConfig)));
 61: } else {
 62: // service scope by default.
 63: items.forEach(item -> urls.addAll(serviceItemToUrls(item, configuratorConfig)));
 64: }
 65: 
 66: return urls;","public static List<URL> parseConfigurators(String rawConfig) {
        // compatible url JsonArray, such as [ ""override://xxx"", ""override://xxx"" ]
        List<URL> compatibleUrls = parseJsonArray(rawConfig);
        if (CollectionUtils.isNotEmpty(compatibleUrls)) {
            return compatibleUrls;
        }

        List<URL> urls = new ArrayList<>();
        ConfiguratorConfig configuratorConfig = parseObject(rawConfig);

        String scope = configuratorConfig.getScope();
        List<ConfigItem> items = configuratorConfig.getConfigs();

        if (ConfiguratorConfig.SCOPE_APPLICATION.equals(scope)) {
            items.forEach(item -> urls.addAll(appItemToUrls(item, configuratorConfig)));
        } else {
            // service scope by default.
            items.forEach(item -> urls.addAll(serviceItemToUrls(item, configuratorConfig)));
        }

        return urls;
    }",1
dubbo-3.2,NULL_DEREFERENCE,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/configurator/parser/ConfigParser.java,org.apache.dubbo.rpc.cluster.configurator.parser.ConfigParser.parseConfigurators(java.lang.String):java.util.List,63,object `items` last assigned on line 57 could be null and is dereferenced at line 63.,"46: public static List<URL> parseConfigurators(String rawConfig) {
 47: // compatible url JsonArray, such as [ ""override://xxx"", ""override://xxx"" ]
 48: List<URL> compatibleUrls = parseJsonArray(rawConfig);
 49: if (CollectionUtils.isNotEmpty(compatibleUrls)) {
 50: return compatibleUrls;
 51: }
 52: 
 53: List<URL> urls = new ArrayList<>();
 54: ConfiguratorConfig configuratorConfig = parseObject(rawConfig);
 55: 
 56: String scope = configuratorConfig.getScope();
 57: List<ConfigItem> items = configuratorConfig.getConfigs();
 58: 
 59: if (ConfiguratorConfig.SCOPE_APPLICATION.equals(scope)) {
 60: items.forEach(item -> urls.addAll(appItemToUrls(item, configuratorConfig)));
 61: } else {
 62: // service scope by default.
 63: items.forEach(item -> urls.addAll(serviceItemToUrls(item, configuratorConfig)));
 64: }
 65: 
 66: return urls;","public static List<URL> parseConfigurators(String rawConfig) {
        // compatible url JsonArray, such as [ ""override://xxx"", ""override://xxx"" ]
        List<URL> compatibleUrls = parseJsonArray(rawConfig);
        if (CollectionUtils.isNotEmpty(compatibleUrls)) {
            return compatibleUrls;
        }

        List<URL> urls = new ArrayList<>();
        ConfiguratorConfig configuratorConfig = parseObject(rawConfig);

        String scope = configuratorConfig.getScope();
        List<ConfigItem> items = configuratorConfig.getConfigs();

        if (ConfiguratorConfig.SCOPE_APPLICATION.equals(scope)) {
            items.forEach(item -> urls.addAll(appItemToUrls(item, configuratorConfig)));
        } else {
            // service scope by default.
            items.forEach(item -> urls.addAll(serviceItemToUrls(item, configuratorConfig)));
        }

        return urls;
    }",1
dubbo-3.2,NULL_DEREFERENCE,dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/transport/dispatcher/WrappedChannelHandler.java,"org.apache.dubbo.remoting.transport.dispatcher.WrappedChannelHandler.<init>(org.apache.dubbo.remoting.ChannelHandler,org.apache.dubbo.common.URL)",50,object returned by `getInstance(url.getOrDefaultApplicationModel())` could be null and is dereferenced at line 50.,https://github.com/apache/dubbo/blob/3.2/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/transport/dispatcher/WrappedChannelHandler.java,"public WrappedChannelHandler(ChannelHandler handler, URL url) {
        this.handler = handler;
        this.url = url;
        this.executorSupport = ExecutorRepository.getInstance(url.getOrDefaultApplicationModel()).getExecutorSupport(url);
    }",1
dubbo-3.2,NULL_DEREFERENCE,dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/command/impl/PublishMetadata.java,"org.apache.dubbo.qos.command.impl.PublishMetadata.execute(org.apache.dubbo.qos.api.CommandContext,java.lang.String[]):java.lang.String",62,object `frameworkExecutorRepository` last assigned on line 61 could be null and is dereferenced at line 62.,"48: public String execute(CommandContext commandContext, String[] args) {
 49: logger.info(""received publishMetadata command."");
 50: 
 51: StringBuilder stringBuilder = new StringBuilder();
 52: List<ApplicationModel> applicationModels = frameworkModel.getApplicationModels();
 53: 
 54: for (ApplicationModel applicationModel : applicationModels) {
 55: if (ArrayUtils.isEmpty(args)) {
 56: ServiceInstanceMetadataUtils.refreshMetadataAndInstance(applicationModel);
 57: stringBuilder.append(""publish metadata succeeded. App:"").append(applicationModel.getApplicationName()).append(""\n"");
 58: } else {
 59: try {
 60: int delay = Integer.parseInt(args[0]);
 61: FrameworkExecutorRepository frameworkExecutorRepository = applicationModel.getFrameworkModel().getBeanFactory().getBean(FrameworkExecutorRepository.class);
 62: frameworkExecutorRepository.nextScheduledExecutor()
 63: .schedule(() -> ServiceInstanceMetadataUtils.refreshMetadataAndInstance(applicationModel), delay, TimeUnit.SECONDS);
 64: } catch (NumberFormatException e) {
 65: logger.error(CONFIG_PARAMETER_FORMAT_ERROR, """", """", ""Wrong delay param"", e);
 66: return ""publishMetadata failed! Wrong delay param!"";
 67: }
 68: stringBuilder.append(""publish task submitted, will publish in "").append(args[0]).append("" seconds. App:"").append(applicationModel.getApplicationName()).append(""\n"");
 69: }
 70: }
 71: return stringBuilder.toString();","public String execute(CommandContext commandContext, String[] args) {
        logger.info(""received publishMetadata command."");

        StringBuilder stringBuilder = new StringBuilder();
        List<ApplicationModel> applicationModels = frameworkModel.getApplicationModels();

        for (ApplicationModel applicationModel : applicationModels) {
            if (ArrayUtils.isEmpty(args)) {
                ServiceInstanceMetadataUtils.refreshMetadataAndInstance(applicationModel);
                stringBuilder.append(""publish metadata succeeded. App:"").append(applicationModel.getApplicationName()).append(""\n"");
            } else {
                try {
                    int delay = Integer.parseInt(args[0]);
                    FrameworkExecutorRepository frameworkExecutorRepository = applicationModel.getFrameworkModel().getBeanFactory().getBean(FrameworkExecutorRepository.class);
                    frameworkExecutorRepository.nextScheduledExecutor()
                        .schedule(() -> ServiceInstanceMetadataUtils.refreshMetadataAndInstance(applicationModel), delay, TimeUnit.SECONDS);
                } catch (NumberFormatException e) {
                    logger.error(CONFIG_PARAMETER_FORMAT_ERROR, """", """", ""Wrong delay param"", e);
                    return ""publishMetadata failed! Wrong delay param!"";
                }
                stringBuilder.append(""publish task submitted, will publish in "").append(args[0]).append("" seconds. App:"").append(applicationModel.getApplicationName()).append(""\n"");
            }
        }
        return stringBuilder.toString();
    }
",0
dubbo-3.2,NULL_DEREFERENCE,dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/command/impl/PublishMetadata.java,"org.apache.dubbo.qos.command.impl.PublishMetadata.execute(org.apache.dubbo.qos.api.CommandContext,java.lang.String[]):java.lang.String",63,object returned by `frameworkExecutorRepository.nextScheduledExecutor()` could be null and is dereferenced at line 63.,"48: public String execute(CommandContext commandContext, String[] args) {
 49: logger.info(""received publishMetadata command."");
 50: 
 51: StringBuilder stringBuilder = new StringBuilder();
 52: List<ApplicationModel> applicationModels = frameworkModel.getApplicationModels();
 53: 
 54: for (ApplicationModel applicationModel : applicationModels) {
 55: if (ArrayUtils.isEmpty(args)) {
 56: ServiceInstanceMetadataUtils.refreshMetadataAndInstance(applicationModel);
 57: stringBuilder.append(""publish metadata succeeded. App:"").append(applicationModel.getApplicationName()).append(""\n"");
 58: } else {
 59: try {
 60: int delay = Integer.parseInt(args[0]);
 61: FrameworkExecutorRepository frameworkExecutorRepository = applicationModel.getFrameworkModel().getBeanFactory().getBean(FrameworkExecutorRepository.class);
 62: frameworkExecutorRepository.nextScheduledExecutor()
 63: .schedule(() -> ServiceInstanceMetadataUtils.refreshMetadataAndInstance(applicationModel), delay, TimeUnit.SECONDS);
 64: } catch (NumberFormatException e) {
 65: logger.error(CONFIG_PARAMETER_FORMAT_ERROR, """", """", ""Wrong delay param"", e);
 66: return ""publishMetadata failed! Wrong delay param!"";
 67: }
 68: stringBuilder.append(""publish task submitted, will publish in "").append(args[0]).append("" seconds. App:"").append(applicationModel.getApplicationName()).append(""\n"");
 69: }
 70: }
 71: return stringBuilder.toString();","public String execute(CommandContext commandContext, String[] args) {
        logger.info(""received publishMetadata command."");

        StringBuilder stringBuilder = new StringBuilder();
        List<ApplicationModel> applicationModels = frameworkModel.getApplicationModels();

        for (ApplicationModel applicationModel : applicationModels) {
            if (ArrayUtils.isEmpty(args)) {
                ServiceInstanceMetadataUtils.refreshMetadataAndInstance(applicationModel);
                stringBuilder.append(""publish metadata succeeded. App:"").append(applicationModel.getApplicationName()).append(""\n"");
            } else {
                try {
                    int delay = Integer.parseInt(args[0]);
                    FrameworkExecutorRepository frameworkExecutorRepository = applicationModel.getFrameworkModel().getBeanFactory().getBean(FrameworkExecutorRepository.class);
                    frameworkExecutorRepository.nextScheduledExecutor()
                        .schedule(() -> ServiceInstanceMetadataUtils.refreshMetadataAndInstance(applicationModel), delay, TimeUnit.SECONDS);
                } catch (NumberFormatException e) {
                    logger.error(CONFIG_PARAMETER_FORMAT_ERROR, """", """", ""Wrong delay param"", e);
                    return ""publishMetadata failed! Wrong delay param!"";
                }
                stringBuilder.append(""publish task submitted, will publish in "").append(args[0]).append("" seconds. App:"").append(applicationModel.getApplicationName()).append(""\n"");
            }
        }
        return stringBuilder.toString();
    }
",0
dubbo-3.2,NULL_DEREFERENCE,dubbo-registry/dubbo-registry-multiple/src/main/java/org/apache/dubbo/registry/multiple/MultipleServiceDiscovery.java,org.apache.dubbo.registry.multiple.MultipleServiceDiscovery.<init>(org.apache.dubbo.common.URL),55,object returned by `registryURL.getParameter(key)` could be null and is dereferenced by call to `valueOf(...)` at line 55.,https://github.com/apache/dubbo/blob/3.2/dubbo-registry/dubbo-registry-multiple/src/main/java/org/apache/dubbo/registry/multiple/MultipleServiceDiscovery.java,"public MultipleServiceDiscovery(URL registryURL) {
        this.registryURL = registryURL;
        this.applicationName = registryURL.getApplication();

        Map<String, String> parameters = registryURL.getParameters();
        for (String key : parameters.keySet()) {
            if (key.startsWith(REGISTRY_PREFIX_KEY)) {
                URL url = URL.valueOf(registryURL.getParameter(key)).addParameter(CommonConstants.APPLICATION_KEY, applicationName)
                    .addParameter(REGISTRY_TYPE, SERVICE);
                ServiceDiscovery serviceDiscovery = ServiceDiscoveryFactory.getExtension(url).getServiceDiscovery(url);
                serviceDiscoveries.put(key, serviceDiscovery);
            }
        }
    }
",0
dubbo-3.2,NULL_DEREFERENCE,dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/RegistryNotifier.java,"org.apache.dubbo.registry.RegistryNotifier.<init>(org.apache.dubbo.common.URL,long,java.util.concurrent.ScheduledExecutorService)",56,object returned by `registryUrl.getOrDefaultFrameworkModel().getBeanFactory().getBean(org.apache.dubbo.common.threadpool.manager.FrameworkExecutorRepository)` could be null and is dereferenced at line 56.,https://github.com/apache/dubbo/blob/3.2/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/RegistryNotifier.java,"public RegistryNotifier(URL registryUrl, long delayTime, ScheduledExecutorService scheduler) {
        this.delayTime = delayTime;
        if (scheduler == null) {
            this.scheduler = registryUrl.getOrDefaultFrameworkModel().getBeanFactory()
                .getBean(FrameworkExecutorRepository.class).getRegistryNotificationExecutor();
        } else {
            this.scheduler = scheduler;
        }
    }",0
dubbo-3.2,NULL_DEREFERENCE,dubbo-rpc/dubbo-rpc-injvm/src/main/java/org/apache/dubbo/rpc/protocol/injvm/InjvmProtocol.java,"org.apache.dubbo.rpc.protocol.injvm.InjvmProtocol.getExporter(java.util.Map,org.apache.dubbo.common.URL):org.apache.dubbo.rpc.Exporter",55,object returned by `key.getServiceKey()` could be null and is dereferenced at line 55.,"52: static Exporter<?> getExporter(Map<String, Exporter<?>> map, URL key) {
 53: Exporter<?> result = null;
 54: 
 55: if (!key.getServiceKey().contains(""*"")) {
 56: result = map.get(key.getServiceKey());
 57: } else {
 58: if (CollectionUtils.isNotEmptyMap(map)) {
 59: for (Exporter<?> exporter : map.values()) {
 60: if (UrlUtils.isServiceKeyMatch(key, exporter.getInvoker().getUrl())) {
 61: result = exporter;
 62: break;
 63: }
 64: }
 65: }
 66: }
 67: 
 68: return result;","static Exporter<?> getExporter(Map<String, Exporter<?>> map, URL key) {
        Exporter<?> result = null;

        if (!key.getServiceKey().contains(""*"")) {
            result = map.get(key.getServiceKey());
        } else {
            if (CollectionUtils.isNotEmptyMap(map)) {
                for (Exporter<?> exporter : map.values()) {
                    if (UrlUtils.isServiceKeyMatch(key, exporter.getInvoker().getUrl())) {
                        result = exporter;
                        break;
                    }
                }
            }
        }

        return result;
    }",1
dubbo-3.2,NULL_DEREFERENCE,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/service/ReflectionV1AlphaService.java,org.apache.dubbo.rpc.protocol.tri.service.ReflectionV1AlphaService$1.onNext(io.grpc.reflection.v1alpha.ServerReflectionRequest):void,53,object returned by `request.getMessageRequestCase()` could be null and is dereferenced at line 53.,"52: public void onNext(ServerReflectionRequest request) {
 53: switch (request.getMessageRequestCase()) {","public StreamObserver<ServerReflectionRequest> serverReflectionInfo(
        StreamObserver<ServerReflectionResponse> responseObserver) {
        return new StreamObserver<ServerReflectionRequest>() {
            @Override
            public void onNext(ServerReflectionRequest request) {
                switch (request.getMessageRequestCase()) {
                    case FILE_BY_FILENAME:
                        getFileByName(request, responseObserver);
                        break;
                    case FILE_CONTAINING_SYMBOL:
                        getFileContainingSymbol(request, responseObserver);
                        break;
                    case FILE_CONTAINING_EXTENSION:
                        getFileByExtension(request, responseObserver);
                        break;
                    case ALL_EXTENSION_NUMBERS_OF_TYPE:
                        getAllExtensions(request, responseObserver);
                        break;
                    case LIST_SERVICES:
                        listServices(request, responseObserver);
                        break;
                    default:
                        sendErrorResponse(
                            request,
                            TriRpcStatus.Code.UNIMPLEMENTED,
                            ""not implemented "" + request.getMessageRequestCase(), responseObserver);
                }
            }",1
dubbo-3.2,NULL_DEREFERENCE,dubbo-serialization/dubbo-serialization-fastjson2/src/main/java/org/apache/dubbo/common/serialize/fastjson2/FastJson2Serialization.java,"org.apache.dubbo.common.serialize.fastjson2.FastJson2Serialization.serialize(org.apache.dubbo.common.URL,java.io.OutputStream):org.apache.dubbo.common.serialize.ObjectOutput",62,object `fastjson2CreatorManager` last assigned on line 56 could be null and is dereferenced by call to `FastJson2ObjectOutput(...)` at line 62.,"52: public ObjectOutput serialize(URL url, OutputStream output) throws IOException {
 53: Fastjson2CreatorManager fastjson2CreatorManager = Optional.ofNullable(url)
 54: .map(URL::getOrDefaultFrameworkModel)
 55: .orElse(FrameworkModel.defaultModel())
 56: .getBeanFactory().getBean(Fastjson2CreatorManager.class);
 57: Fastjson2SecurityManager fastjson2SecurityManager = Optional.ofNullable(url)
 58: .map(URL::getOrDefaultFrameworkModel)
 59: .orElse(FrameworkModel.defaultModel())
 60: .getBeanFactory().getBean(Fastjson2SecurityManager.class);
 61: 
 62: return new FastJson2ObjectOutput(fastjson2CreatorManager, fastjson2SecurityManager, output);","public ObjectOutput serialize(URL url, OutputStream output) throws IOException {
        Fastjson2CreatorManager fastjson2CreatorManager = Optional.ofNullable(url)
            .map(URL::getOrDefaultFrameworkModel)
            .orElseGet(FrameworkModel::defaultModel)
            .getBeanFactory().getBean(Fastjson2CreatorManager.class);
        Fastjson2SecurityManager fastjson2SecurityManager = Optional.ofNullable(url)
            .map(URL::getOrDefaultFrameworkModel)
            .orElseGet(FrameworkModel::defaultModel)
            .getBeanFactory().getBean(Fastjson2SecurityManager.class);

        return new FastJson2ObjectOutput(fastjson2CreatorManager, fastjson2SecurityManager, output);
    }",0
dubbo-3.2,NULL_DEREFERENCE,dubbo-serialization/dubbo-serialization-hessian2/src/main/java/org/apache/dubbo/common/serialize/hessian2/Hessian2Serialization.java,"org.apache.dubbo.common.serialize.hessian2.Hessian2Serialization.serialize(org.apache.dubbo.common.URL,java.io.OutputStream):org.apache.dubbo.common.serialize.ObjectOutput",57,object `hessian2FactoryManager` last assigned on line 56 could be null and is dereferenced by call to `Hessian2ObjectOutput(...)` at line 57.,"52: public ObjectOutput serialize(URL url, OutputStream out) throws IOException {
 53: Hessian2FactoryManager hessian2FactoryManager = Optional.ofNullable(url)
 54: .map(URL::getOrDefaultFrameworkModel)
 55: .orElse(FrameworkModel.defaultModel())
 56: .getBeanFactory().getBean(Hessian2FactoryManager.class);
 57: return new Hessian2ObjectOutput(out, hessian2FactoryManager);","public ObjectOutput serialize(URL url, OutputStream out) throws IOException {
        Hessian2FactoryManager hessian2FactoryManager = Optional.ofNullable(url)
            .map(URL::getOrDefaultFrameworkModel)
            .orElseGet(FrameworkModel::defaultModel)
            .getBeanFactory().getBean(Hessian2FactoryManager.class);
        return new Hessian2ObjectOutput(out, hessian2FactoryManager);
    }",0
dubbo-3.2,NULL_DEREFERENCE,dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/DubboGracefulShutdown.java,org.apache.dubbo.rpc.protocol.dubbo.DubboGracefulShutdown.sendEvent(java.lang.String):void,57,object returned by `server.getRemotingServer()` could be null and is dereferenced at line 57.,https://github.com/apache/dubbo/blob/3.2/dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/DubboGracefulShutdown.java,"private void sendEvent(String event) {
        try {
            for (ProtocolServer server : dubboProtocol.getServers()) {
                Collection<Channel> channels = server.getRemotingServer().getChannels();
                Request request = new Request();
                request.setEvent(event);
                request.setTwoWay(false);
                request.setVersion(Version.getProtocolVersion());

                for (Channel channel : channels) {
                    try {
                        if (channel.isConnected()) {
                            channel.send(request, channel.getUrl().getParameter(Constants.CHANNEL_READONLYEVENT_SENT_KEY, true));
                        }
                    } catch (RemotingException e) {
                        if (e.getCause() instanceof ClosedChannelException) {
                            // ignore ClosedChannelException which means the connection has been closed.
                            continue;
                        }
                        logger.warn(TRANSPORT_FAILED_CLOSE_STREAM, """", """", ""send cannot write message error."", e);
                    }
                }
            }
        } catch (Throwable e) {
            logger.warn(TRANSPORT_FAILED_CLOSE_STREAM, """", """", ""send cannot write message error."", e);
        }
    }",0
dubbo-3.2,NULL_DEREFERENCE,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/filter/ProtocolFilterWrapper.java,org.apache.dubbo.rpc.cluster.filter.ProtocolFilterWrapper.export(org.apache.dubbo.rpc.Invoker):org.apache.dubbo.rpc.Exporter,61,object `builder` last assigned on line 60 could be null and is dereferenced at line 61.,"56: public <T> Exporter<T> export(Invoker<T> invoker) throws RpcException {
 57: if (UrlUtils.isRegistry(invoker.getUrl())) {
 58: return protocol.export(invoker);
 59: }
 60: FilterChainBuilder builder = getFilterChainBuilder(invoker.getUrl());
 61: return protocol.export(builder.buildInvokerChain(invoker, SERVICE_FILTER_KEY, CommonConstants.PROVIDER));","public <T> Exporter<T> export(Invoker<T> invoker) throws RpcException {
        if (UrlUtils.isRegistry(invoker.getUrl())) {
            return protocol.export(invoker);
        }
        FilterChainBuilder builder = getFilterChainBuilder(invoker.getUrl());
        return protocol.export(builder.buildInvokerChain(invoker, SERVICE_FILTER_KEY, CommonConstants.PROVIDER));
    }",1
dubbo-3.2,NULL_DEREFERENCE,dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java,"org.apache.dubbo.qos.server.handler.TelnetProcessHandler.channelRead0(io.netty.channel.ChannelHandlerContext,java.lang.String):void",62,object `commandContext` last assigned on line 61 could be null and is dereferenced at line 62.,https://github.com/apache/dubbo/blob/3.2/dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java,"protected void channelRead0(ChannelHandlerContext ctx, String msg) throws Exception {

        if (StringUtils.isBlank(msg)) {
            ctx.writeAndFlush(QosProcessHandler.PROMPT);
        } else {
            CommandContext commandContext = TelnetCommandDecoder.decode(msg);
            commandContext.setQosConfiguration(qosConfiguration);
            commandContext.setRemote(ctx.channel());

            try {
                String result = commandExecutor.execute(commandContext);
                if (StringUtils.isEquals(QosConstants.CLOSE, result)) {
                    ctx.writeAndFlush(getByeLabel()).addListener(ChannelFutureListener.CLOSE);
                } else {
                    ctx.writeAndFlush(result + QosConstants.BR_STR + QosProcessHandler.PROMPT);
                }
            } catch (NoSuchCommandException ex) {
                ctx.writeAndFlush(msg + "" :no such command"");
                ctx.writeAndFlush(QosConstants.BR_STR + QosProcessHandler.PROMPT);
                log.error(QOS_COMMAND_NOT_FOUND, """", """", ""can not found command "" + commandContext, ex);
            } catch (PermissionDenyException ex) {
                ctx.writeAndFlush(msg + "" :permission deny"");
                ctx.writeAndFlush(QosConstants.BR_STR + QosProcessHandler.PROMPT);
                log.error(QOS_PERMISSION_DENY_EXCEPTION, """", """", ""permission deny to access command "" + commandContext, ex);
            } catch (Exception ex) {
                ctx.writeAndFlush(msg + "" :fail to execute commandContext by "" + ex.getMessage());
                ctx.writeAndFlush(QosConstants.BR_STR + QosProcessHandler.PROMPT);
                log.error(QOS_UNEXPECTED_EXCEPTION, """", """", ""execute commandContext got exception "" + commandContext, ex);
            }
        }
    }
",0
dubbo-3.2,NULL_DEREFERENCE,dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java,org.apache.dubbo.remoting.transport.netty4.NettyClientHandler.channelActive(io.netty.channel.ChannelHandlerContext):void,60,object `channel` last assigned on line 57 could be null and is dereferenced at line 60.,https://github.com/apache/dubbo/blob/3.2/dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java,"public void channelActive(ChannelHandlerContext ctx) throws Exception {
        NettyChannel channel = NettyChannel.getOrAddChannel(ctx.channel(), url, handler);
        handler.connected(channel);
        if (logger.isInfoEnabled()) {
            logger.info(""The connection of "" + channel.getLocalAddress() + "" -> "" + channel.getRemoteAddress() + "" is established."");
        }
    }
",1
dubbo-3.2,NULL_DEREFERENCE,dubbo-metadata/dubbo-metadata-api/src/main/java/org/apache/dubbo/metadata/AbstractServiceNameMapping.java,org.apache.dubbo.metadata.AbstractServiceNameMapping.<init>(org.apache.dubbo.rpc.model.ApplicationModel),67,object returned by `applicationModel.getFrameworkModel().getBeanFactory().getBean(org.apache.dubbo.common.threadpool.manager.FrameworkExecutorRepository)` could be null and is dereferenced at line 67.,https://github.com/apache/dubbo/blob/3.2/dubbo-metadata/dubbo-metadata-api/src/main/java/org/apache/dubbo/metadata/AbstractServiceNameMapping.java,"public AbstractServiceNameMapping(ApplicationModel applicationModel) {
        this.applicationModel = applicationModel;
        boolean enableFileCache = true;
        Optional<ApplicationConfig> application = applicationModel.getApplicationConfigManager().getApplication();
        if (application.isPresent()) {
            enableFileCache = Boolean.TRUE.equals(application.get().getEnableFileCache()) ? true : false;
        }
        this.mappingCacheManager = new MappingCacheManager(enableFileCache,
            applicationModel.tryGetApplicationName(),
            applicationModel.getFrameworkModel().getBeanFactory()
                .getBean(FrameworkExecutorRepository.class).getCacheRefreshingScheduledExecutor());
    }",0
dubbo-3.2,NULL_DEREFERENCE,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/FailoverClusterInvoker.java,"org.apache.dubbo.rpc.cluster.support.FailoverClusterInvoker.doInvoke(org.apache.dubbo.rpc.Invocation,java.util.Collection,org.apache.dubbo.rpc.cluster.LoadBalance):org.apache.dubbo.rpc.Result",107,object `le` last assigned on line 63 could be null and is dereferenced at line 107.,"58: public Result doInvoke(Invocation invocation, final List<Invoker<T>> invokers, LoadBalance loadbalance) throws RpcException {
 59: List<Invoker<T>> copyInvokers = invokers;
 60: String methodName = RpcUtils.getMethodName(invocation);
 61: int len = calculateInvokeTimes(methodName);
 62: // retry loop.
 63: RpcException le = null; // last exception.
 64: List<Invoker<T>> invoked = new ArrayList<Invoker<T>>(copyInvokers.size()); // invoked invokers.
 65: Set<String> providers = new HashSet<String>(len);
 66: for (int i = 0; i < len; i++) {
 67: //Reselect before retry to avoid a change of candidate `invokers`.
 68: //NOTE: if `invokers` changed, then `invoked` also lose accuracy.
 69: if (i > 0) {
 70: checkWhetherDestroyed();
 71: copyInvokers = list(invocation);
 72: // check again
 73: checkInvokers(copyInvokers, invocation);
 74: }
 75: Invoker<T> invoker = select(loadbalance, invocation, copyInvokers, invoked);
 76: invoked.add(invoker);
 77: RpcContext.getServiceContext().setInvokers((List) invoked);
 78: boolean success = false;
 79: try {
 80: Result result = invokeWithContext(invoker, invocation);
 81: if (le != null && logger.isWarnEnabled()) {
 82: logger.warn(CLUSTER_FAILED_MULTIPLE_RETRIES,""failed to retry do invoke"","""",""Although retry the method "" + methodName
 83: + "" in the service "" + getInterface().getName()
 84: + "" was successful by the provider "" + invoker.getUrl().getAddress()
 85: + "", but there have been failed providers "" + providers
 86: + "" ("" + providers.size() + ""/"" + copyInvokers.size()
 87: + "") from the registry "" + directory.getUrl().getAddress()
 88: + "" on the consumer "" + NetUtils.getLocalHost()
 89: + "" using the dubbo version "" + Version.getVersion() + "". Last error is: ""
 90: + le.getMessage(),le);
 91: }
 92: success = true;
 93: return result;
 94: } catch (RpcException e) {
 95: if (e.isBiz()) { // biz exception.
 96: throw e;
 97: }
 98: le = e;
 99: } catch (Throwable e) {
 100: le = new RpcException(e.getMessage(), e);
 101: } finally {
 102: if (!success) {
 103: providers.add(invoker.getUrl().getAddress());
 104: }
 105: }
 106: }
 107: throw new RpcException(le.getCode(), ""Failed to invoke the method ""","public Result doInvoke(Invocation invocation, final List<Invoker<T>> invokers, LoadBalance loadbalance) throws RpcException {
        List<Invoker<T>> copyInvokers = invokers;
        String methodName = RpcUtils.getMethodName(invocation);
        int len = calculateInvokeTimes(methodName);
        // retry loop.
        RpcException le = null; // last exception.
        List<Invoker<T>> invoked = new ArrayList<Invoker<T>>(copyInvokers.size()); // invoked invokers.
        Set<String> providers = new HashSet<String>(len);
        for (int i = 0; i < len; i++) {
            //Reselect before retry to avoid a change of candidate `invokers`.
            //NOTE: if `invokers` changed, then `invoked` also lose accuracy.
            if (i > 0) {
                checkWhetherDestroyed();
                copyInvokers = list(invocation);
                // check again
                checkInvokers(copyInvokers, invocation);
            }
            Invoker<T> invoker = select(loadbalance, invocation, copyInvokers, invoked);
            invoked.add(invoker);
            RpcContext.getServiceContext().setInvokers((List) invoked);
            boolean success = false;
            try {
                Result result = invokeWithContext(invoker, invocation);
                if (le != null && logger.isWarnEnabled()) {
                    logger.warn(CLUSTER_FAILED_MULTIPLE_RETRIES,""failed to retry do invoke"","""",""Although retry the method "" + methodName
                        + "" in the service "" + getInterface().getName()
                        + "" was successful by the provider "" + invoker.getUrl().getAddress()
                        + "", but there have been failed providers "" + providers
                        + "" ("" + providers.size() + ""/"" + copyInvokers.size()
                        + "") from the registry "" + directory.getUrl().getAddress()
                        + "" on the consumer "" + NetUtils.getLocalHost()
                        + "" using the dubbo version "" + Version.getVersion() + "". Last error is: ""
                        + le.getMessage(),le);
                }
                success = true;
                return result;
            } catch (RpcException e) {
                if (e.isBiz()) { // biz exception.
                    throw e;
                }
                le = e;
            } catch (Throwable e) {
                le = new RpcException(e.getMessage(), e);
            } finally {
                if (!success) {
                    providers.add(invoker.getUrl().getAddress());
                }
            }
        }
        throw new RpcException(le.getCode(), ""Failed to invoke the method ""
                + methodName + "" in the service "" + getInterface().getName()
                + "". Tried "" + len + "" times of the providers "" + providers
                + "" ("" + providers.size() + ""/"" + copyInvokers.size()
                + "") from the registry "" + directory.getUrl().getAddress()
                + "" on the consumer "" + NetUtils.getLocalHost() + "" using the dubbo version ""
                + Version.getVersion() + "". Last error is: ""
                + le.getMessage(), le.getCause() != null ? le.getCause() : le);
    }",0
dubbo-3.2,NULL_DEREFERENCE,dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/metadata/ConfigurableMetadataServiceExporter.java,org.apache.dubbo.config.metadata.ConfigurableMetadataServiceExporter.export():org.apache.dubbo.config.metadata.ConfigurableMetadataServiceExporter,61,object returned by `ConfigurableMetadataServiceExporter.applicationModel.getFrameworkModel().getBeanFactory().getBean(org.apache.dubbo.common.threadpool.manager.FrameworkExecutorRepository)` could be null and is dereferenced at line 61.,"58: public synchronized ConfigurableMetadataServiceExporter export() {
 59: if (serviceConfig == null || !isExported()) {
 60: ExecutorService internalServiceExecutor = applicationModel.getFrameworkModel().getBeanFactory()
 61: .getBean(FrameworkExecutorRepository.class).getInternalServiceExecutor();
 62: this.serviceConfig = InternalServiceConfigBuilder.<MetadataService>newBuilder(applicationModel)
 63: .interfaceClass(MetadataService.class)
 64: .protocol(getApplicationConfig().getMetadataServiceProtocol(), METADATA_SERVICE_PROTOCOL_KEY)
 65: .port(getApplicationConfig().getMetadataServicePort(), METADATA_SERVICE_PORT_KEY)
 66: .registryId(""internal-metadata-registry"")
 67: .executor(internalServiceExecutor)
 68: .ref(metadataService)
 69: .build(configConsumer -> configConsumer.setMethods(generateMethodConfig()));
 70: 
 71: // export
 72: serviceConfig.export();
 73: 
 74: metadataService.setMetadataURL(serviceConfig.getExportedUrls().get(0));
 75: if (logger.isInfoEnabled()) {
 76: logger.info(""The MetadataService exports urls : "" + serviceConfig.getExportedUrls());
 77: }
 78: } else {
 79: if (logger.isWarnEnabled()) {
 80: logger.warn(CONFIG_METADATA_SERVICE_EXPORTED, """", """", ""The MetadataService has been exported : "" + serviceConfig.getExportedUrls());
 81: }
 82: }
 83: 
 84: return this;","public synchronized ConfigurableMetadataServiceExporter export() {
        if (serviceConfig == null || !isExported()) {
            ExecutorService internalServiceExecutor = applicationModel.getFrameworkModel().getBeanFactory()
                .getBean(FrameworkExecutorRepository.class).getInternalServiceExecutor();
            this.serviceConfig = InternalServiceConfigBuilder.<MetadataService>newBuilder(applicationModel)
                .interfaceClass(MetadataService.class)
                .protocol(getApplicationConfig().getMetadataServiceProtocol(), METADATA_SERVICE_PROTOCOL_KEY)
                .port(getApplicationConfig().getMetadataServicePort(), METADATA_SERVICE_PORT_KEY)
                .registryId(""internal-metadata-registry"")
                .executor(internalServiceExecutor)
                .ref(metadataService)
                .build(configConsumer -> configConsumer.setMethods(generateMethodConfig()));

            // export
            serviceConfig.export();

            metadataService.setMetadataURL(serviceConfig.getExportedUrls().get(0));
            if (logger.isInfoEnabled()) {
                logger.info(""The MetadataService exports urls : "" + serviceConfig.getExportedUrls());
            }
        } else {
            if (logger.isWarnEnabled()) {
                logger.warn(CONFIG_METADATA_SERVICE_EXPORTED, """", """", ""The MetadataService has been exported : "" + serviceConfig.getExportedUrls());
            }
        }

        return this;
    }",0
dubbo-3.2,NULL_DEREFERENCE,dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/protocol/ProtocolSecurityWrapper.java,org.apache.dubbo.rpc.protocol.ProtocolSecurityWrapper.export(org.apache.dubbo.rpc.Invoker):org.apache.dubbo.rpc.Exporter,65,object `serializeSecurityConfigurator` last assigned on line 64 could be null and is dereferenced at line 65.,"59: public <T> Exporter<T> export(Invoker<T> invoker) throws RpcException {
 60: try {
 61: ServiceModel serviceModel = invoker.getUrl().getServiceModel();
 62: ScopeModel scopeModel = invoker.getUrl().getScopeModel();
 63: SerializeSecurityConfigurator serializeSecurityConfigurator = ScopeModelUtil.getModuleModel(scopeModel)
 64: .getBeanFactory().getBean(SerializeSecurityConfigurator.class);
 65: serializeSecurityConfigurator.refreshStatus();
 66: serializeSecurityConfigurator.refreshCheck();
 67: 
 68: Optional.ofNullable(invoker.getInterface())
 69: .ifPresent(serializeSecurityConfigurator::registerInterface);
 70: 
 71: Optional.ofNullable(serviceModel)
 72: .map(ServiceModel::getServiceModel)
 73: .map(ServiceDescriptor::getServiceInterfaceClass)
 74: .ifPresent(serializeSecurityConfigurator::registerInterface);
 75: 
 76: Optional.ofNullable(serviceModel)
 77: .map(ServiceModel::getServiceMetadata)
 78: .map(ServiceMetadata::getServiceType)
 79: .ifPresent(serializeSecurityConfigurator::registerInterface);
 80: } catch (Throwable t) {
 81: logger.error(INTERNAL_ERROR, """", """", ""Failed to register interface for security check"", t);
 82: }
 83: return protocol.export(invoker);","public <T> Exporter<T> export(Invoker<T> invoker) throws RpcException {
        try {
            ServiceModel serviceModel = invoker.getUrl().getServiceModel();
            ScopeModel scopeModel = invoker.getUrl().getScopeModel();
            SerializeSecurityConfigurator serializeSecurityConfigurator = ScopeModelUtil.getModuleModel(scopeModel)
                .getBeanFactory().getBean(SerializeSecurityConfigurator.class);
            serializeSecurityConfigurator.refreshStatus();
            serializeSecurityConfigurator.refreshCheck();

            Optional.ofNullable(invoker.getInterface())
                .ifPresent(serializeSecurityConfigurator::registerInterface);

            Optional.ofNullable(serviceModel)
                .map(ServiceModel::getServiceModel)
                .map(ServiceDescriptor::getServiceInterfaceClass)
                .ifPresent(serializeSecurityConfigurator::registerInterface);

            Optional.ofNullable(serviceModel)
                .map(ServiceModel::getServiceMetadata)
                .map(ServiceMetadata::getServiceType)
                .ifPresent(serializeSecurityConfigurator::registerInterface);
        } catch (Throwable t) {
            logger.error(INTERNAL_ERROR, """", """", ""Failed to register interface for security check"", t);
        }
        return protocol.export(invoker);
    }
",0
dubbo-3.2,NULL_DEREFERENCE,dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/context/DubboDeployApplicationListener.java,org.apache.dubbo.config.spring.context.DubboDeployApplicationListener.setApplicationContext(org.springframework.context.ApplicationContext):void,65,object `DubboDeployApplicationListener.applicationModel` last assigned on line 62 could be null and is dereferenced at line 65.,"60: public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
 61: this.applicationContext = applicationContext;
 62: this.applicationModel = DubboBeanUtils.getApplicationModel(applicationContext);
 63: this.moduleModel = DubboBeanUtils.getModuleModel(applicationContext);
 64: // listen deploy events and publish DubboApplicationStateEvent
 65: applicationModel.getDeployer().addDeployListener(new DeployListenerAdapter<ApplicationModel>(){
 66: @Override
 67: public void onStarting(ApplicationModel scopeModel) {
 68: publishApplicationEvent(DeployState.STARTING);
 69: }
 70: 
 71: @Override
 72: public void onStarted(ApplicationModel scopeModel) {
 73: publishApplicationEvent(DeployState.STARTED);
 74: }
 75: 
 76: @Override
 77: public void onStopping(ApplicationModel scopeModel) {
 78: publishApplicationEvent(DeployState.STOPPING);
 79: }
 80: 
 81: @Override
 82: public void onStopped(ApplicationModel scopeModel) {
 83: publishApplicationEvent(DeployState.STOPPED);
 84: }
 85: 
 86: @Override
 87: public void onFailure(ApplicationModel scopeModel, Throwable cause) {
 88: publishApplicationEvent(DeployState.FAILED, cause);
 89: }
 90: });
 91: moduleModel.getDeployer().addDeployListener(new DeployListenerAdapter<ModuleModel>(){","public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
        this.applicationContext = applicationContext;
        this.applicationModel = DubboBeanUtils.getApplicationModel(applicationContext);
        this.moduleModel = DubboBeanUtils.getModuleModel(applicationContext);
        // listen deploy events and publish DubboApplicationStateEvent
        applicationModel.getDeployer().addDeployListener(new DeployListenerAdapter<ApplicationModel>(){
            @Override
            public void onStarting(ApplicationModel scopeModel) {
                publishApplicationEvent(DeployState.STARTING);
            }

            @Override
            public void onStarted(ApplicationModel scopeModel) {
                publishApplicationEvent(DeployState.STARTED);
            }

            @Override
            public void onStopping(ApplicationModel scopeModel) {
                publishApplicationEvent(DeployState.STOPPING);
            }

            @Override
            public void onStopped(ApplicationModel scopeModel) {
                publishApplicationEvent(DeployState.STOPPED);
            }

            @Override
            public void onFailure(ApplicationModel scopeModel, Throwable cause) {
                publishApplicationEvent(DeployState.FAILED, cause);
            }
        });
        moduleModel.getDeployer().addDeployListener(new DeployListenerAdapter<ModuleModel>(){
            @Override
            public void onStarting(ModuleModel scopeModel) {
                publishModuleEvent(DeployState.STARTING);
            }

            @Override
            public void onStarted(ModuleModel scopeModel) {
                publishModuleEvent(DeployState.STARTED);
            }

            @Override
            public void onStopping(ModuleModel scopeModel) {
                publishModuleEvent(DeployState.STOPPING);
            }

            @Override
            public void onStopped(ModuleModel scopeModel) {
                publishModuleEvent(DeployState.STOPPED);
            }

            @Override
            public void onFailure(ModuleModel scopeModel, Throwable cause) {
                publishModuleEvent(DeployState.FAILED, cause);
            }
        });
    }",1
dubbo-3.2,NULL_DEREFERENCE,dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/context/DubboDeployApplicationListener.java,org.apache.dubbo.config.spring.context.DubboDeployApplicationListener.setApplicationContext(org.springframework.context.ApplicationContext):void,91,object `DubboDeployApplicationListener.moduleModel` last assigned on line 63 could be null and is dereferenced at line 91.,"60: public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
 61: this.applicationContext = applicationContext;
 62: this.applicationModel = DubboBeanUtils.getApplicationModel(applicationContext);
 63: this.moduleModel = DubboBeanUtils.getModuleModel(applicationContext);
 64: // listen deploy events and publish DubboApplicationStateEvent
 65: applicationModel.getDeployer().addDeployListener(new DeployListenerAdapter<ApplicationModel>(){
 66: @Override
 67: public void onStarting(ApplicationModel scopeModel) {
 68: publishApplicationEvent(DeployState.STARTING);
 69: }
 70: 
 71: @Override
 72: public void onStarted(ApplicationModel scopeModel) {
 73: publishApplicationEvent(DeployState.STARTED);
 74: }
 75: 
 76: @Override
 77: public void onStopping(ApplicationModel scopeModel) {
 78: publishApplicationEvent(DeployState.STOPPING);
 79: }
 80: 
 81: @Override
 82: public void onStopped(ApplicationModel scopeModel) {
 83: publishApplicationEvent(DeployState.STOPPED);
 84: }
 85: 
 86: @Override
 87: public void onFailure(ApplicationModel scopeModel, Throwable cause) {
 88: publishApplicationEvent(DeployState.FAILED, cause);
 89: }
 90: });
 91: moduleModel.getDeployer().addDeployListener(new DeployListenerAdapter<ModuleModel>(){","public void onFailure(ApplicationModel scopeModel, Throwable cause) {
                publishApplicationEvent(DeployState.FAILED, cause);
            }",1
dubbo-3.2,NULL_DEREFERENCE,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/loadbalance/ShortestResponseLoadBalance.java,org.apache.dubbo.rpc.cluster.loadbalance.ShortestResponseLoadBalance.setApplicationModel(org.apache.dubbo.rpc.model.ApplicationModel):void,64,object returned by `applicationModel.getFrameworkModel().getBeanFactory().getBean(org.apache.dubbo.common.threadpool.manager.FrameworkExecutorRepository)` could be null and is dereferenced at line 64.,,"public void setApplicationModel(ApplicationModel applicationModel) {
        slidePeriod = applicationModel.modelEnvironment().getConfiguration().getInt(Constants.SHORTEST_RESPONSE_SLIDE_PERIOD, 30_000);
        executorService = applicationModel.getFrameworkModel().getBeanFactory()
            .getBean(FrameworkExecutorRepository.class).getSharedExecutor();
    }",0
dubbo-3.2,NULL_DEREFERENCE,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/ForkingClusterInvoker.java,org.apache.dubbo.rpc.cluster.support.ForkingClusterInvoker.<init>(org.apache.dubbo.rpc.cluster.Directory),63,object returned by `directory.getUrl().getOrDefaultFrameworkModel().getBeanFactory().getBean(org.apache.dubbo.common.threadpool.manager.FrameworkExecutorRepository)` could be null and is dereferenced at line 63.,,"public ForkingClusterInvoker(Directory<T> directory) {
        super(directory);
        executor = directory.getUrl().getOrDefaultFrameworkModel().getBeanFactory()
            .getBean(FrameworkExecutorRepository.class).getSharedExecutor();
    }",0
dubbo-3.2,NULL_DEREFERENCE,dubbo-common/src/main/java/org/apache/dubbo/common/utils/SerializeSecurityConfigurator.java,org.apache.dubbo.common.utils.SerializeSecurityConfigurator.<init>(org.apache.dubbo.rpc.model.ModuleModel),69,object `SerializeSecurityConfigurator.serializeSecurityManager` last assigned on line 66 could be null and is dereferenced by call to `refreshCheck()` at line 69.,,"public SerializeSecurityConfigurator(ModuleModel moduleModel) {
        this.moduleModel = moduleModel;
        moduleModel.addClassLoaderListener(this);

        FrameworkModel frameworkModel = moduleModel.getApplicationModel().getFrameworkModel();
        serializeSecurityManager = frameworkModel.getBeanFactory().getBean(SerializeSecurityManager.class);

        refreshStatus();
        refreshCheck();
        refreshConfig();

        onAddClassLoader(moduleModel, Thread.currentThread().getContextClassLoader());
    }",0
dubbo-3.2,NULL_DEREFERENCE,dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyChannelHandler.java,org.apache.dubbo.remoting.transport.netty4.NettyChannelHandler.channelInactive(io.netty.channel.ChannelHandlerContext):void,65,object returned by `ctx.channel()` could be null and is dereferenced at line 65.,,"public void channelInactive(ChannelHandlerContext ctx) throws Exception {
        super.channelInactive(ctx);
        NettyChannel channel = NettyChannel.getOrAddChannel(ctx.channel(), url, handler);
        try {
            dubboChannels.remove(NetUtils.toAddressString((InetSocketAddress) ctx.channel().remoteAddress()));
            if (channel != null) {
                handler.disconnected(channel);
                if (logger.isInfoEnabled()) {
                    logger.info(""The connection of "" + channel.getRemoteAddress() + "" -> "" + channel.getLocalAddress() + "" is disconnected."");
                }
            }
        } finally {
            NettyChannel.removeChannel(ctx.channel());
        }
    }",0
dubbo-3.2,NULL_DEREFERENCE,dubbo-serialization/dubbo-serialization-hessian2/src/main/java/org/apache/dubbo/common/serialize/hessian2/Hessian2Serialization.java,"org.apache.dubbo.common.serialize.hessian2.Hessian2Serialization.deserialize(org.apache.dubbo.common.URL,java.io.InputStream):org.apache.dubbo.common.serialize.ObjectInput",66,object `hessian2FactoryManager` last assigned on line 65 could be null and is dereferenced by call to `Hessian2ObjectInput(...)` at line 66.,"61: public ObjectInput deserialize(URL url, InputStream is) throws IOException {
 62: Hessian2FactoryManager hessian2FactoryManager = Optional.ofNullable(url)
 63: .map(URL::getOrDefaultFrameworkModel)
 64: .orElse(FrameworkModel.defaultModel())
 65: .getBeanFactory().getBean(Hessian2FactoryManager.class);
 66: return new Hessian2ObjectInput(is, hessian2FactoryManager);","public ObjectInput deserialize(URL url, InputStream is) throws IOException {
        Hessian2FactoryManager hessian2FactoryManager = Optional.ofNullable(url)
            .map(URL::getOrDefaultFrameworkModel)
            .orElseGet(FrameworkModel::defaultModel)
            .getBeanFactory().getBean(Hessian2FactoryManager.class);
        return new Hessian2ObjectInput(is, hessian2FactoryManager);
    }",0
dubbo-3.2,NULL_DEREFERENCE,dubbo-compatible/src/main/java/com/alibaba/dubbo/rpc/Invoker.java,com.alibaba.dubbo.rpc.Invoker$CompatibleInvoker.invoke(com.alibaba.dubbo.rpc.Invocation):com.alibaba.dubbo.rpc.Result,68,object returned by `invocation.getOriginal()` could be null and is dereferenced by call to `newDefaultAsyncResult(...)` at line 68.,https://github.com/apache/dubbo/blob/3.2/dubbo-compatible/src/main/java/com/alibaba/dubbo/rpc/Invoker.java,"public Result invoke(Invocation invocation) throws RpcException {
            if (invoker instanceof Invoker) {
                Result result = ((Invoker) invoker).invoke(invocation);
                if (result instanceof Result.CompatibleResult) {
                    return result;
                } else {
                    AsyncRpcResult asyncRpcResult = AsyncRpcResult.newDefaultAsyncResult(invocation.getOriginal());
                    asyncRpcResult.setValue(result.getValue());
                    asyncRpcResult.setException(result.getException());
                    asyncRpcResult.setObjectAttachments(result.getObjectAttachments());

                    return new Result.CompatibleResult(asyncRpcResult);
                }
            }
            return new Result.CompatibleResult(invoker.invoke(invocation.getOriginal()));
        }",0
dubbo-3.2,NULL_DEREFERENCE,dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/context/DubboInfraBeanRegisterPostProcessor.java,org.apache.dubbo.config.spring.context.DubboInfraBeanRegisterPostProcessor.postProcessBeanFactory(org.springframework.beans.factory.config.ConfigurableListableBeanFactory):void,80,object `applicationModel` last assigned on line 76 could be null and is dereferenced by call to `get(...)` at line 80.,"62: public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {
 63: 
 64: // In Spring 3.2.x, registry may be null because do not call postProcessBeanDefinitionRegistry method before postProcessBeanFactory
 65: if (registry != null) {
 66: // register ReferenceAnnotationBeanPostProcessor early before PropertySourcesPlaceholderConfigurer/PropertyPlaceholderConfigurer
 67: // for processing early init ReferenceBean
 68: ReferenceAnnotationBeanPostProcessor referenceAnnotationBeanPostProcessor = beanFactory.getBean(
 69: ReferenceAnnotationBeanPostProcessor.BEAN_NAME, ReferenceAnnotationBeanPostProcessor.class);
 70: beanFactory.addBeanPostProcessor(referenceAnnotationBeanPostProcessor);
 71: 
 72: // register PropertySourcesPlaceholderConfigurer bean if not exits
 73: DubboBeanUtils.registerPlaceholderConfigurerBeanIfNotExists(beanFactory, registry);
 74: }
 75: 
 76: ApplicationModel applicationModel = DubboBeanUtils.getApplicationModel(beanFactory);
 77: ModuleModel moduleModel = DubboBeanUtils.getModuleModel(beanFactory);
 78: 
 79: // Initialize SpringExtensionInjector
 80: SpringExtensionInjector.get(applicationModel).init(applicationContext);
 81: SpringExtensionInjector.get(moduleModel).init(applicationContext);
 82: DubboBeanUtils.getInitializationContext(beanFactory).setApplicationContext(applicationContext);
 83: 
 84: // Initialize dubbo Environment before ConfigManager
 85: // Extract dubbo props from Spring env and put them to app config
 86: ConfigurableEnvironment environment = (ConfigurableEnvironment) applicationContext.getEnvironment();
 87: SortedMap<String, String> dubboProperties = EnvironmentUtils.filterDubboProperties(environment);
 88: applicationModel.modelEnvironment().setAppConfigMap(dubboProperties);
 89: 
 90: // register ConfigManager singleton
 91: beanFactory.registerSingleton(ConfigManager.BEAN_NAME, applicationModel.getApplicationConfigManager());
 92: 
 93: // fix https://github.com/apache/dubbo/issues/10278
 94: if (registry != null){","public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {

        // In Spring 3.2.x, registry may be null because do not call postProcessBeanDefinitionRegistry method before postProcessBeanFactory
        if (registry != null) {
            // register ReferenceAnnotationBeanPostProcessor early before PropertySourcesPlaceholderConfigurer/PropertyPlaceholderConfigurer
            // for processing early init ReferenceBean
            ReferenceAnnotationBeanPostProcessor referenceAnnotationBeanPostProcessor = beanFactory.getBean(
                ReferenceAnnotationBeanPostProcessor.BEAN_NAME, ReferenceAnnotationBeanPostProcessor.class);
            beanFactory.addBeanPostProcessor(referenceAnnotationBeanPostProcessor);

            // register PropertySourcesPlaceholderConfigurer bean if not exits
            DubboBeanUtils.registerPlaceholderConfigurerBeanIfNotExists(beanFactory, registry);
        }

        ApplicationModel applicationModel = DubboBeanUtils.getApplicationModel(beanFactory);
        ModuleModel moduleModel = DubboBeanUtils.getModuleModel(beanFactory);

        // Initialize SpringExtensionInjector
        SpringExtensionInjector.get(applicationModel).init(applicationContext);
        SpringExtensionInjector.get(moduleModel).init(applicationContext);
        DubboBeanUtils.getInitializationContext(beanFactory).setApplicationContext(applicationContext);

        // Initialize dubbo Environment before ConfigManager
        // Extract dubbo props from Spring env and put them to app config
        ConfigurableEnvironment environment = (ConfigurableEnvironment) applicationContext.getEnvironment();
        SortedMap<String, String> dubboProperties = EnvironmentUtils.filterDubboProperties(environment);
        applicationModel.modelEnvironment().getAppConfigMap().putAll(dubboProperties);

        // register ConfigManager singleton
        beanFactory.registerSingleton(ConfigManager.BEAN_NAME, applicationModel.getApplicationConfigManager());

        // fix https://github.com/apache/dubbo/issues/10278
        if (registry != null){
            registry.removeBeanDefinition(BEAN_NAME);
        }
    }",0
dubbo-3.2,NULL_DEREFERENCE,dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/context/DubboInfraBeanRegisterPostProcessor.java,org.apache.dubbo.config.spring.context.DubboInfraBeanRegisterPostProcessor.postProcessBeanFactory(org.springframework.beans.factory.config.ConfigurableListableBeanFactory):void,81,object `moduleModel` last assigned on line 77 could be null and is dereferenced by call to `get(...)` at line 81.,"62: public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {
 63: 
 64: // In Spring 3.2.x, registry may be null because do not call postProcessBeanDefinitionRegistry method before postProcessBeanFactory
 65: if (registry != null) {
 66: // register ReferenceAnnotationBeanPostProcessor early before PropertySourcesPlaceholderConfigurer/PropertyPlaceholderConfigurer
 67: // for processing early init ReferenceBean
 68: ReferenceAnnotationBeanPostProcessor referenceAnnotationBeanPostProcessor = beanFactory.getBean(
 69: ReferenceAnnotationBeanPostProcessor.BEAN_NAME, ReferenceAnnotationBeanPostProcessor.class);
 70: beanFactory.addBeanPostProcessor(referenceAnnotationBeanPostProcessor);
 71: 
 72: // register PropertySourcesPlaceholderConfigurer bean if not exits
 73: DubboBeanUtils.registerPlaceholderConfigurerBeanIfNotExists(beanFactory, registry);
 74: }
 75: 
 76: ApplicationModel applicationModel = DubboBeanUtils.getApplicationModel(beanFactory);
 77: ModuleModel moduleModel = DubboBeanUtils.getModuleModel(beanFactory);
 78: 
 79: // Initialize SpringExtensionInjector
 80: SpringExtensionInjector.get(applicationModel).init(applicationContext);
 81: SpringExtensionInjector.get(moduleModel).init(applicationContext);
 82: DubboBeanUtils.getInitializationContext(beanFactory).setApplicationContext(applicationContext);
 83: 
 84: // Initialize dubbo Environment before ConfigManager
 85: // Extract dubbo props from Spring env and put them to app config
 86: ConfigurableEnvironment environment = (ConfigurableEnvironment) applicationContext.getEnvironment();
 87: SortedMap<String, String> dubboProperties = EnvironmentUtils.filterDubboProperties(environment);
 88: applicationModel.modelEnvironment().setAppConfigMap(dubboProperties);
 89: 
 90: // register ConfigManager singleton
 91: beanFactory.registerSingleton(ConfigManager.BEAN_NAME, applicationModel.getApplicationConfigManager());
 92: 
 93: // fix https://github.com/apache/dubbo/issues/10278
 94: if (registry != null){","public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {

        // In Spring 3.2.x, registry may be null because do not call postProcessBeanDefinitionRegistry method before postProcessBeanFactory
        if (registry != null) {
            // register ReferenceAnnotationBeanPostProcessor early before PropertySourcesPlaceholderConfigurer/PropertyPlaceholderConfigurer
            // for processing early init ReferenceBean
            ReferenceAnnotationBeanPostProcessor referenceAnnotationBeanPostProcessor = beanFactory.getBean(
                ReferenceAnnotationBeanPostProcessor.BEAN_NAME, ReferenceAnnotationBeanPostProcessor.class);
            beanFactory.addBeanPostProcessor(referenceAnnotationBeanPostProcessor);

            // register PropertySourcesPlaceholderConfigurer bean if not exits
            DubboBeanUtils.registerPlaceholderConfigurerBeanIfNotExists(beanFactory, registry);
        }

        ApplicationModel applicationModel = DubboBeanUtils.getApplicationModel(beanFactory);
        ModuleModel moduleModel = DubboBeanUtils.getModuleModel(beanFactory);

        // Initialize SpringExtensionInjector
        SpringExtensionInjector.get(applicationModel).init(applicationContext);
        SpringExtensionInjector.get(moduleModel).init(applicationContext);
        DubboBeanUtils.getInitializationContext(beanFactory).setApplicationContext(applicationContext);

        // Initialize dubbo Environment before ConfigManager
        // Extract dubbo props from Spring env and put them to app config
        ConfigurableEnvironment environment = (ConfigurableEnvironment) applicationContext.getEnvironment();
        SortedMap<String, String> dubboProperties = EnvironmentUtils.filterDubboProperties(environment);
        applicationModel.modelEnvironment().getAppConfigMap().putAll(dubboProperties);

        // register ConfigManager singleton
        beanFactory.registerSingleton(ConfigManager.BEAN_NAME, applicationModel.getApplicationConfigManager());

        // fix https://github.com/apache/dubbo/issues/10278
        if (registry != null){
            registry.removeBeanDefinition(BEAN_NAME);
        }
    }
",0
dubbo-3.2,NULL_DEREFERENCE,dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/context/DubboInfraBeanRegisterPostProcessor.java,org.apache.dubbo.config.spring.context.DubboInfraBeanRegisterPostProcessor.postProcessBeanFactory(org.springframework.beans.factory.config.ConfigurableListableBeanFactory):void,82,object returned by `getInitializationContext(beanFactory)` could be null and is dereferenced at line 82.,"62: public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {
 63: 
 64: // In Spring 3.2.x, registry may be null because do not call postProcessBeanDefinitionRegistry method before postProcessBeanFactory
 65: if (registry != null) {
 66: // register ReferenceAnnotationBeanPostProcessor early before PropertySourcesPlaceholderConfigurer/PropertyPlaceholderConfigurer
 67: // for processing early init ReferenceBean
 68: ReferenceAnnotationBeanPostProcessor referenceAnnotationBeanPostProcessor = beanFactory.getBean(
 69: ReferenceAnnotationBeanPostProcessor.BEAN_NAME, ReferenceAnnotationBeanPostProcessor.class);
 70: beanFactory.addBeanPostProcessor(referenceAnnotationBeanPostProcessor);
 71: 
 72: // register PropertySourcesPlaceholderConfigurer bean if not exits
 73: DubboBeanUtils.registerPlaceholderConfigurerBeanIfNotExists(beanFactory, registry);
 74: }
 75: 
 76: ApplicationModel applicationModel = DubboBeanUtils.getApplicationModel(beanFactory);
 77: ModuleModel moduleModel = DubboBeanUtils.getModuleModel(beanFactory);
 78: 
 79: // Initialize SpringExtensionInjector
 80: SpringExtensionInjector.get(applicationModel).init(applicationContext);
 81: SpringExtensionInjector.get(moduleModel).init(applicationContext);
 82: DubboBeanUtils.getInitializationContext(beanFactory).setApplicationContext(applicationContext);
 83: 
 84: // Initialize dubbo Environment before ConfigManager
 85: // Extract dubbo props from Spring env and put them to app config
 86: ConfigurableEnvironment environment = (ConfigurableEnvironment) applicationContext.getEnvironment();
 87: SortedMap<String, String> dubboProperties = EnvironmentUtils.filterDubboProperties(environment);
 88: applicationModel.modelEnvironment().setAppConfigMap(dubboProperties);
 89: 
 90: // register ConfigManager singleton
 91: beanFactory.registerSingleton(ConfigManager.BEAN_NAME, applicationModel.getApplicationConfigManager());
 92: 
 93: // fix https://github.com/apache/dubbo/issues/10278
 94: if (registry != null){","public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {

        // In Spring 3.2.x, registry may be null because do not call postProcessBeanDefinitionRegistry method before postProcessBeanFactory
        if (registry != null) {
            // register ReferenceAnnotationBeanPostProcessor early before PropertySourcesPlaceholderConfigurer/PropertyPlaceholderConfigurer
            // for processing early init ReferenceBean
            ReferenceAnnotationBeanPostProcessor referenceAnnotationBeanPostProcessor = beanFactory.getBean(
                ReferenceAnnotationBeanPostProcessor.BEAN_NAME, ReferenceAnnotationBeanPostProcessor.class);
            beanFactory.addBeanPostProcessor(referenceAnnotationBeanPostProcessor);

            // register PropertySourcesPlaceholderConfigurer bean if not exits
            DubboBeanUtils.registerPlaceholderConfigurerBeanIfNotExists(beanFactory, registry);
        }

        ApplicationModel applicationModel = DubboBeanUtils.getApplicationModel(beanFactory);
        ModuleModel moduleModel = DubboBeanUtils.getModuleModel(beanFactory);

        // Initialize SpringExtensionInjector
        SpringExtensionInjector.get(applicationModel).init(applicationContext);
        SpringExtensionInjector.get(moduleModel).init(applicationContext);
        DubboBeanUtils.getInitializationContext(beanFactory).setApplicationContext(applicationContext);

        // Initialize dubbo Environment before ConfigManager
        // Extract dubbo props from Spring env and put them to app config
        ConfigurableEnvironment environment = (ConfigurableEnvironment) applicationContext.getEnvironment();
        SortedMap<String, String> dubboProperties = EnvironmentUtils.filterDubboProperties(environment);
        applicationModel.modelEnvironment().getAppConfigMap().putAll(dubboProperties);

        // register ConfigManager singleton
        beanFactory.registerSingleton(ConfigManager.BEAN_NAME, applicationModel.getApplicationConfigManager());

        // fix https://github.com/apache/dubbo/issues/10278
        if (registry != null){
            registry.removeBeanDefinition(BEAN_NAME);
        }
    }
",0
dubbo-3.2,NULL_DEREFERENCE,dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/pu/TelnetDetector.java,org.apache.dubbo.qos.pu.TelnetDetector.commandDetect(org.apache.dubbo.remoting.buffer.ChannelBuffer):org.apache.dubbo.remoting.api.ProtocolDetector$Result,77,object `commandContext` last assigned on line 76 could be null and is dereferenced at line 77.,"62: private Result commandDetect(ChannelBuffer in) {
 63: // detect if remote channel send a qos command to server
 64: ChannelBuffer back = in.copy();
 65: byte[] backBytes;
 66: try {
 67: backBytes = new byte[back.readableBytes()];
 68: back.getBytes(back.readerIndex(), backBytes);
 69: } finally {
 70: back.release();
 71: }
 72: 
 73: String s = new String(backBytes, CharsetUtil.UTF_8);
 74: // trim /r/n to let parser work for input
 75: s = s.trim();
 76: CommandContext commandContext = TelnetCommandDecoder.decode(s);
 77: if (frameworkModel.getExtensionLoader(BaseCommand.class).hasExtension(commandContext.getCommandName())) {
 78: return Result.RECOGNIZED;
 79: }
 80: return Result.UNRECOGNIZED;","private Result commandDetect(ChannelBuffer in) {
        // detect if remote channel send a qos command to server
        ChannelBuffer back = in.copy();
        byte[] backBytes;
        try {
            backBytes = new byte[back.readableBytes()];
            back.getBytes(back.readerIndex(), backBytes);
        } finally {
            back.release();
        }

        String s = new String(backBytes, CharsetUtil.UTF_8);
        // trim /r/n to let parser work for input
        s = s.trim();
        CommandContext commandContext = TelnetCommandDecoder.decode(s);
        if (frameworkModel.getExtensionLoader(BaseCommand.class).hasExtension(commandContext.getCommandName())) {
            return Result.RECOGNIZED;
        }
        return Result.UNRECOGNIZED;
    }",1
dubbo-3.2,NULL_DEREFERENCE,dubbo-registry/dubbo-registry-zookeeper/src/main/java/org/apache/dubbo/registry/zookeeper/ZookeeperServiceDiscoveryChangeWatcher.java,"org.apache.dubbo.registry.zookeeper.ZookeeperServiceDiscoveryChangeWatcher.<init>(org.apache.dubbo.registry.zookeeper.ZookeeperServiceDiscovery,org.apache.curator.x.discovery.ServiceCache,java.lang.String,java.util.concurrent.CountDownLatch)",68,object returned by `getFrameworkModel(zookeeperServiceDiscovery.getUrl().getScopeModel()).getBeanFactory().getBean(org.apache.dubbo.common.threadpool.manager.FrameworkExecutorRepository)` could be null and is dereferenced at line 68.,,"public ZookeeperServiceDiscoveryChangeWatcher(ZookeeperServiceDiscovery zookeeperServiceDiscovery,
                                                  ServiceCache<ZookeeperInstance> cacheInstance,
                                                  String serviceName,
                                                  CountDownLatch latch) {
        this.zookeeperServiceDiscovery = zookeeperServiceDiscovery;
        this.cacheInstance = cacheInstance;
        this.serviceName = serviceName;
        this.notifier = new RegistryNotifier(zookeeperServiceDiscovery.getUrl(), zookeeperServiceDiscovery.getDelay(),
            ScopeModelUtil.getFrameworkModel(zookeeperServiceDiscovery.getUrl().getScopeModel()).getBeanFactory()
                .getBean(FrameworkExecutorRepository.class).getServiceDiscoveryAddressNotificationExecutor()) {
            @Override
            protected void doNotify(Object rawAddresses) {
                listeners.forEach(listener -> listener.onEvent((ServiceInstancesChangedEvent) rawAddresses));
            }
        };
        this.latch = latch;
    }",0
dubbo-3.2,NULL_DEREFERENCE,dubbo-xds/src/main/java/org/apache/dubbo/rpc/cluster/router/xds/EdsEndpointManager.java,org.apache.dubbo.rpc.cluster.router.xds.EdsEndpointManager.doSubscribeEds(java.lang.String):void,74,object returned by `defaultModel().getBeanFactory().getBean(org.apache.dubbo.common.threadpool.manager.FrameworkExecutorRepository)` could be null and is dereferenced at line 74.,,"private void doSubscribeEds(String cluster) {
        ConcurrentHashMapUtils.computeIfAbsent(EDS_LISTENERS, cluster, key -> endpoints -> {
            Set<Endpoint> result = endpoints.values()
                .stream()
                .map(EndpointResult::getEndpoints)
                .flatMap(Set::stream)
                .collect(Collectors.toSet());
            notifyEndpointChange(cluster, result);
        });
        Consumer<Map<String, EndpointResult>> consumer = EDS_LISTENERS.get(cluster);
        if (PilotExchanger.isEnabled()) {
            FrameworkModel.defaultModel().getBeanFactory().getBean(FrameworkExecutorRepository.class)
                .getSharedExecutor().submit(() -> PilotExchanger.getInstance().observeEds(Collections.singleton(cluster), consumer));
        }
    }",0
dubbo-3.2,NULL_DEREFERENCE,dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyEventLoopFactory.java,org.apache.dubbo.remoting.transport.netty4.NettyEventLoopFactory.shouldEpoll():boolean,66,object `osName` last assigned on line 65 could be null and is dereferenced at line 66.,"63: private static boolean shouldEpoll() {
 64: if (Boolean.parseBoolean(System.getProperty(NETTY_EPOLL_ENABLE_KEY, ""false""))) {
 65: String osName = System.getProperty(OS_NAME_KEY);
 66: return osName.toLowerCase().contains(OS_LINUX_PREFIX) && Epoll.isAvailable();
 67: }
 68: 
 69: return false;","private static boolean shouldEpoll() {
        if (Boolean.parseBoolean(System.getProperty(NETTY_EPOLL_ENABLE_KEY, ""false""))) {
            String osName = System.getProperty(OS_NAME_KEY);
            return osName.toLowerCase().contains(OS_LINUX_PREFIX) && Epoll.isAvailable();
        }

        return false;
    }",1
dubbo-3.2,NULL_DEREFERENCE,dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java,org.apache.dubbo.remoting.transport.netty4.NettyClientHandler.channelInactive(io.netty.channel.ChannelHandlerContext):void,74,object `channel` last assigned on line 66 could be null and is dereferenced at line 74.,https://github.com/apache/dubbo/blob/3.2/dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java,"public void channelInactive(ChannelHandlerContext ctx) throws Exception {
        NettyChannel channel = NettyChannel.getOrAddChannel(ctx.channel(), url, handler);
        try {
            handler.disconnected(channel);
        } finally {
            NettyChannel.removeChannel(ctx.channel());
        }

        if (logger.isInfoEnabled()) {
            logger.info(""The connection of "" + channel.getLocalAddress() + "" -> "" + channel.getRemoteAddress() + "" is disconnected."");
        }
    }",0
dubbo-3.2,NULL_DEREFERENCE,dubbo-serialization/dubbo-serialization-fastjson2/src/main/java/org/apache/dubbo/common/serialize/fastjson2/FastJson2Serialization.java,"org.apache.dubbo.common.serialize.fastjson2.FastJson2Serialization.deserialize(org.apache.dubbo.common.URL,java.io.InputStream):org.apache.dubbo.common.serialize.ObjectInput",76,object `fastjson2CreatorManager` last assigned on line 70 could be null and is dereferenced by call to `FastJson2ObjectInput(...)` at line 76.,"66: public ObjectInput deserialize(URL url, InputStream input) throws IOException {
 67: Fastjson2CreatorManager fastjson2CreatorManager = Optional.ofNullable(url)
 68: .map(URL::getOrDefaultFrameworkModel)
 69: .orElse(FrameworkModel.defaultModel())
 70: .getBeanFactory().getBean(Fastjson2CreatorManager.class);
 71: Fastjson2SecurityManager fastjson2SecurityManager = Optional.ofNullable(url)
 72: .map(URL::getOrDefaultFrameworkModel)
 73: .orElse(FrameworkModel.defaultModel())
 74: .getBeanFactory().getBean(Fastjson2SecurityManager.class);
 75: 
 76: return new FastJson2ObjectInput(fastjson2CreatorManager, fastjson2SecurityManager, input);","public ObjectInput deserialize(URL url, InputStream input) throws IOException {
        Fastjson2CreatorManager fastjson2CreatorManager = Optional.ofNullable(url)
            .map(URL::getOrDefaultFrameworkModel)
            .orElseGet(FrameworkModel::defaultModel)
            .getBeanFactory().getBean(Fastjson2CreatorManager.class);
        Fastjson2SecurityManager fastjson2SecurityManager = Optional.ofNullable(url)
            .map(URL::getOrDefaultFrameworkModel)
            .orElseGet(FrameworkModel::defaultModel)
            .getBeanFactory().getBean(Fastjson2SecurityManager.class);

        return new FastJson2ObjectInput(fastjson2CreatorManager, fastjson2SecurityManager, input);
    }",0
dubbo-3.2,NULL_DEREFERENCE,dubbo-remoting/dubbo-remoting-netty/src/main/java/org/apache/dubbo/remoting/transport/netty/NettyHandler.java,"org.apache.dubbo.remoting.transport.netty.NettyHandler.channelConnected(org.jboss.netty.channel.ChannelHandlerContext,org.jboss.netty.channel.ChannelStateEvent):void",79,object `channel` last assigned on line 68 could be null and is dereferenced at line 79.,https://github.com/apache/dubbo/blob/3.2/dubbo-remoting/dubbo-remoting-netty/src/main/java/org/apache/dubbo/remoting/transport/netty/NettyHandler.java,"public void channelConnected(ChannelHandlerContext ctx, ChannelStateEvent e) throws Exception {
        NettyChannel channel = NettyChannel.getOrAddChannel(ctx.getChannel(), url, handler);
        try {
            if (channel != null) {
                channels.put(NetUtils.toAddressString((InetSocketAddress) ctx.getChannel().getRemoteAddress()), channel);
            }
            handler.connected(channel);
        } finally {
            NettyChannel.removeChannelIfDisconnected(ctx.getChannel());
        }

        if (logger.isInfoEnabled()) {
            logger.info(""The connection between "" + channel.getRemoteAddress() + "" and "" + channel.getLocalAddress() + "" is established"");
        }
    }",0
dubbo-3.2,NULL_DEREFERENCE,dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyServerHandler.java,org.apache.dubbo.remoting.transport.netty4.NettyServerHandler.channelActive(io.netty.channel.ChannelHandlerContext):void,75,object `channel` last assigned on line 68 could be null and is dereferenced at line 75.,https://github.com/apache/dubbo/blob/3.2/dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyServerHandler.java,"public void channelActive(ChannelHandlerContext ctx) throws Exception {
        NettyChannel channel = NettyChannel.getOrAddChannel(ctx.channel(), url, handler);
        if (channel != null) {
            channels.put(NetUtils.toAddressString((InetSocketAddress) ctx.channel().remoteAddress()), channel);
        }
        handler.connected(channel);

        if (logger.isInfoEnabled()) {
            logger.info(""The connection of "" + channel.getRemoteAddress() + "" -> "" + channel.getLocalAddress() + "" is established."");
        }
    }",0
dubbo-3.2,NULL_DEREFERENCE,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/filter/ProtocolFilterWrapper.java,"org.apache.dubbo.rpc.cluster.filter.ProtocolFilterWrapper.refer(java.lang.Class,org.apache.dubbo.common.URL):org.apache.dubbo.rpc.Invoker",74,object `builder` last assigned on line 73 could be null and is dereferenced at line 74.,"69: public <T> Invoker<T> refer(Class<T> type, URL url) throws RpcException {
 70: if (UrlUtils.isRegistry(url)) {
 71: return protocol.refer(type, url);
 72: }
 73: FilterChainBuilder builder = getFilterChainBuilder(url);
 74: return builder.buildInvokerChain(protocol.refer(type, url), REFERENCE_FILTER_KEY, CommonConstants.CONSUMER);","public <T> Invoker<T> refer(Class<T> type, URL url) throws RpcException {
        if (UrlUtils.isRegistry(url)) {
            return protocol.refer(type, url);
        }
        FilterChainBuilder builder = getFilterChainBuilder(url);
        return builder.buildInvokerChain(protocol.refer(type, url), REFERENCE_FILTER_KEY, CommonConstants.CONSUMER);
    }",1
dubbo-3.2,NULL_DEREFERENCE,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/configurator/AbstractConfigurator.java,org.apache.dubbo.rpc.cluster.configurator.AbstractConfigurator.configure(org.apache.dubbo.common.URL):org.apache.dubbo.common.URL,84,object `currentSide` last assigned on line 82 could be null and is dereferenced at line 84.,"73: public URL configure(URL url) {
 74: // If override url is not enabled or is invalid, just return.
 75: if (!configuratorUrl.getParameter(ENABLED_KEY, true) || configuratorUrl.getHost() == null || url == null || url.getHost() == null) {
 76: logger.info(""Cannot apply configurator rule, the rule is disabled or is invalid: \n"" + configuratorUrl);
 77: return url;
 78: }
 79: 
 80: String apiVersion = configuratorUrl.getParameter(CONFIG_VERSION_KEY);
 81: if (StringUtils.isNotEmpty(apiVersion)) { // v2.7 or above
 82: String currentSide = url.getSide();
 83: String configuratorSide = configuratorUrl.getSide();
 84: if (currentSide.equals(configuratorSide) && CONSUMER.equals(configuratorSide)) {
 85: url = configureIfMatch(NetUtils.getLocalHost(), url);
 86: } else if (currentSide.equals(configuratorSide) && PROVIDER.equals(configuratorSide)) {
 87: url = configureIfMatch(url.getHost(), url);
 88: }
 89: }
 90: /*
 91: * This else branch is deprecated and is left only to keep compatibility with versions before 2.7.0
 92: */
 93: else {
 94: url = configureDeprecated(url);
 95: }
 96: return url;","public URL configure(URL url) {
        // If override url is not enabled or is invalid, just return.
        if (!configuratorUrl.getParameter(ENABLED_KEY, true) || configuratorUrl.getHost() == null || url == null || url.getHost() == null) {
            logger.info(""Cannot apply configurator rule, the rule is disabled or is invalid: \n"" + configuratorUrl);
            return url;
        }

        String apiVersion = configuratorUrl.getParameter(CONFIG_VERSION_KEY);
        if (StringUtils.isNotEmpty(apiVersion)) { // v2.7 or above
            String currentSide = url.getSide();
            String configuratorSide = configuratorUrl.getSide();
            if (currentSide.equals(configuratorSide) && CONSUMER.equals(configuratorSide)) {
                url = configureIfMatch(NetUtils.getLocalHost(), url);
            } else if (currentSide.equals(configuratorSide) && PROVIDER.equals(configuratorSide)) {
                url = configureIfMatch(url.getHost(), url);
            }
        }
        /*
         * This else branch is deprecated and is left only to keep compatibility with versions before 2.7.0
         */
        else {
            url = configureDeprecated(url);
        }
        return url;
    }",0
dubbo-3.2,NULL_DEREFERENCE,dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/deploy/DefaultMetricsServiceExporter.java,org.apache.dubbo.config.deploy.DefaultMetricsServiceExporter.export():org.apache.dubbo.metrics.service.MetricsServiceExporter,77,object returned by `DefaultMetricsServiceExporter.applicationModel.getFrameworkModel().getBeanFactory().getBean(org.apache.dubbo.common.threadpool.manager.FrameworkExecutorRepository)` could be null and is dereferenced at line 77.,"73: public MetricsServiceExporter export() {
 74: if (metricsService != null) {
 75: if (!isExported()) {
 76: ExecutorService internalServiceExecutor = applicationModel.getFrameworkModel().getBeanFactory()
 77: .getBean(FrameworkExecutorRepository.class).getInternalServiceExecutor();
 78: ServiceConfig<MetricsService> serviceConfig = InternalServiceConfigBuilder.<MetricsService>newBuilder(applicationModel)
 79: .interfaceClass(MetricsService.class)
 80: .protocol(getMetricsConfig().getExportServiceProtocol())
 81: .port(getMetricsConfig().getExportServicePort())
 82: .executor(internalServiceExecutor)
 83: .ref(metricsService)
 84: .registryId(""internal-metrics-registry"")
 85: .build();
 86: 
 87: // export
 88: serviceConfig.export();
 89: 
 90: if (logger.isInfoEnabled()) {
 91: logger.info(""The MetricsService exports urls : "" + serviceConfig.getExportedUrls());
 92: }
 93: this.serviceConfig = serviceConfig;
 94: } else {
 95: if (logger.isWarnEnabled()) {
 96: logger.warn(LoggerCodeConstants.INTERNAL_ERROR, """", """", ""The MetricsService has been exported : "" + serviceConfig.getExportedUrls());
 97: }
 98: }
 99: } else {
 100: if (logger.isInfoEnabled()) {
 101: logger.info(""The MetricsConfig not exist, will not export metrics service."");
 102: }
 103: }
 104: 
 105: return this;","public MetricsServiceExporter export() {
        if (metricsService != null) {
            if (!isExported()) {
                ExecutorService internalServiceExecutor = applicationModel.getFrameworkModel().getBeanFactory()
                    .getBean(FrameworkExecutorRepository.class).getInternalServiceExecutor();
                ServiceConfig<MetricsService> serviceConfig = InternalServiceConfigBuilder.<MetricsService>newBuilder(applicationModel)
                    .interfaceClass(MetricsService.class)
                    .protocol(getMetricsConfig().getExportServiceProtocol())
                    .port(getMetricsConfig().getExportServicePort())
                    .executor(internalServiceExecutor)
                    .ref(metricsService)
                    .registryId(""internal-metrics-registry"")
                    .build();

                // export
                serviceConfig.export();

                if (logger.isInfoEnabled()) {
                    logger.info(""The MetricsService exports urls : "" + serviceConfig.getExportedUrls());
                }
                this.serviceConfig = serviceConfig;
            } else {
                if (logger.isWarnEnabled()) {
                    logger.warn(LoggerCodeConstants.INTERNAL_ERROR, """", """", ""The MetricsService has been exported : "" + serviceConfig.getExportedUrls());
                }
            }
        } else {
            if (logger.isInfoEnabled()) {
                logger.info(""The MetricsConfig not exist, will not export metrics service."");
            }
        }

        return this;
    }
",0
dubbo-3.2,NULL_DEREFERENCE,dubbo-rpc/dubbo-rpc-rest/src/main/java/org/apache/dubbo/rpc/protocol/rest/RestProtocol.java,org.apache.dubbo.rpc.protocol.rest.RestProtocol.export(org.apache.dubbo.rpc.Invoker):org.apache.dubbo.rpc.Exporter,103,object `server` last assigned on line 93 could be null and is dereferenced at line 103.,"73: public <T> Exporter<T> export(final Invoker<T> invoker) throws RpcException {
 74: URL url = invoker.getUrl();
 75: final String uri = serviceKey(url);
 76: Exporter<T> exporter = (Exporter<T>) exporterMap.get(uri);
 77: if (exporter != null) {
 78: // When modifying the configuration through override, you need to re-expose the newly modified service.
 79: if (Objects.equals(exporter.getInvoker().getUrl(), invoker.getUrl())) {
 80: return exporter;
 81: }
 82: }
 83: 
 84: 
 85: // resolve metadata
 86: ServiceRestMetadata serviceRestMetadata =
 87: MetadataResolver.resolveProviderServiceMetadata(url.getServiceModel().getProxyObject().getClass(),
 88: url, getContextPath(url));
 89: 
 90: 
 91: // TODO add Extension filter
 92: // create rest server
 93: RestProtocolServer server = (RestProtocolServer) ConcurrentHashMapUtils.computeIfAbsent(
 94: (ConcurrentMap<? super String, ? super RestProtocolServer>) serverMap,
 95: getAddr(url), restServer -> {
 96: RestProtocolServer s = serverFactory.createServer(url.getParameter(SERVER_KEY, DEFAULT_SERVER));
 97: s.setAddress(url.getAddress());
 98: s.start(url);
 99: return s;
 100: });
 101: 
 102: 
 103: server.deploy(serviceRestMetadata, invoker);
 104: 
 105: exporter = new AbstractExporter<T>(invoker) {
 106: @Override
 107: public void afterUnExport() {
 108: destroyInternal(url);
 109: exporterMap.remove(uri);
 110: server.undeploy(serviceRestMetadata);
 111: }
 112: };
 113: exporterMap.put(uri, exporter);
 114: return exporter;","public <T> Exporter<T> export(final Invoker<T> invoker) throws RpcException {
        URL url = invoker.getUrl();
        final String uri = serviceKey(url);
        Exporter<T> exporter = (Exporter<T>) exporterMap.get(uri);
        if (exporter != null) {
            // When modifying the configuration through override, you need to re-expose the newly modified service.
            if (Objects.equals(exporter.getInvoker().getUrl(), invoker.getUrl())) {
                return exporter;
            }
        }


        // resolve metadata
        ServiceRestMetadata serviceRestMetadata =
            MetadataResolver.resolveProviderServiceMetadata(url.getServiceModel().getProxyObject().getClass(),
                url, getContextPath(url));


        // TODO add Extension filter
        // create rest server
        RestProtocolServer server = (RestProtocolServer) ConcurrentHashMapUtils.computeIfAbsent(
            (ConcurrentMap<? super String, ? super RestProtocolServer>) serverMap,
            getAddr(url), restServer -> {
                RestProtocolServer s = serverFactory.createServer(url.getParameter(SERVER_KEY, DEFAULT_SERVER));
                s.setAddress(url.getAddress());
                s.start(url);
                return s;
            });


        server.deploy(serviceRestMetadata, invoker);

        exporter = new AbstractExporter<T>(invoker) {
            @Override
            public void afterUnExport() {
                destroyInternal(url);
                exporterMap.remove(uri);
                server.undeploy(serviceRestMetadata);
            }
        };
        exporterMap.put(uri, exporter);
        return exporter;
    }",0
dubbo-3.2,NULL_DEREFERENCE,dubbo-rpc/dubbo-rpc-rest/src/main/java/org/apache/dubbo/rpc/protocol/rest/RestProtocol.java,org.apache.dubbo.rpc.protocol.rest.RestProtocol.export(org.apache.dubbo.rpc.Invoker):org.apache.dubbo.rpc.Exporter,87,object returned by `url.getServiceModel()` could be null and is dereferenced at line 87.,"73: public <T> Exporter<T> export(final Invoker<T> invoker) throws RpcException {
 74: URL url = invoker.getUrl();
 75: final String uri = serviceKey(url);
 76: Exporter<T> exporter = (Exporter<T>) exporterMap.get(uri);
 77: if (exporter != null) {
 78: // When modifying the configuration through override, you need to re-expose the newly modified service.
 79: if (Objects.equals(exporter.getInvoker().getUrl(), invoker.getUrl())) {
 80: return exporter;
 81: }
 82: }
 83: 
 84: 
 85: // resolve metadata
 86: ServiceRestMetadata serviceRestMetadata =
 87: MetadataResolver.resolveProviderServiceMetadata(url.getServiceModel().getProxyObject().getClass(),
 88: url, getContextPath(url));
 89: 
 90: 
 91: // TODO add Extension filter
 92: // create rest server
 93: RestProtocolServer server = (RestProtocolServer) ConcurrentHashMapUtils.computeIfAbsent(
 94: (ConcurrentMap<? super String, ? super RestProtocolServer>) serverMap,
 95: getAddr(url), restServer -> {
 96: RestProtocolServer s = serverFactory.createServer(url.getParameter(SERVER_KEY, DEFAULT_SERVER));
 97: s.setAddress(url.getAddress());
 98: s.start(url);
 99: return s;
 100: });
 101: 
 102: 
 103: server.deploy(serviceRestMetadata, invoker);
 104: 
 105: exporter = new AbstractExporter<T>(invoker) {
 106: @Override
 107: public void afterUnExport() {
 108: destroyInternal(url);
 109: exporterMap.remove(uri);
 110: server.undeploy(serviceRestMetadata);
 111: }
 112: };
 113: exporterMap.put(uri, exporter);
 114: return exporter;","public <T> Exporter<T> export(final Invoker<T> invoker) throws RpcException {
        URL url = invoker.getUrl();
        final String uri = serviceKey(url);
        Exporter<T> exporter = (Exporter<T>) exporterMap.get(uri);
        if (exporter != null) {
            // When modifying the configuration through override, you need to re-expose the newly modified service.
            if (Objects.equals(exporter.getInvoker().getUrl(), invoker.getUrl())) {
                return exporter;
            }
        }


        // resolve metadata
        ServiceRestMetadata serviceRestMetadata =
            MetadataResolver.resolveProviderServiceMetadata(url.getServiceModel().getProxyObject().getClass(),
                url, getContextPath(url));


        // TODO add Extension filter
        // create rest server
        RestProtocolServer server = (RestProtocolServer) ConcurrentHashMapUtils.computeIfAbsent(
            (ConcurrentMap<? super String, ? super RestProtocolServer>) serverMap,
            getAddr(url), restServer -> {
                RestProtocolServer s = serverFactory.createServer(url.getParameter(SERVER_KEY, DEFAULT_SERVER));
                s.setAddress(url.getAddress());
                s.start(url);
                return s;
            });


        server.deploy(serviceRestMetadata, invoker);

        exporter = new AbstractExporter<T>(invoker) {
            @Override
            public void afterUnExport() {
                destroyInternal(url);
                exporterMap.remove(uri);
                server.undeploy(serviceRestMetadata);
            }
        };
        exporterMap.put(uri, exporter);
        return exporter;
    }",0
dubbo-3.2,NULL_DEREFERENCE,dubbo-metrics/dubbo-metrics-default/src/main/java/org/apache/dubbo/metrics/collector/HistogramMetricsCollector.java,org.apache.dubbo.metrics.collector.HistogramMetricsCollector.registerListener():void,75,object returned by `HistogramMetricsCollector.applicationModel.getBeanFactory().getBean(org.apache.dubbo.metrics.collector.DefaultMetricsCollector)` could be null and is dereferenced at line 75.,"74: private void registerListener() {
 75: applicationModel.getBeanFactory().getBean(DefaultMetricsCollector.class).getEventMulticaster().addListener(this);","private void registerListener() {
        applicationModel.getBeanFactory().getBean(DefaultMetricsCollector.class).getEventMulticaster().addListener(this);
    }
",0
dubbo-3.2,NULL_DEREFERENCE,dubbo-monitor/dubbo-monitor-default/src/main/java/org/apache/dubbo/monitor/dubbo/DubboMonitor.java,"org.apache.dubbo.monitor.dubbo.DubboMonitor.<init>(org.apache.dubbo.rpc.Invoker,org.apache.dubbo.monitor.MonitorService)",81,object returned by `monitorInvoker.getUrl().getOrDefaultFrameworkModel().getBeanFactory().getBean(org.apache.dubbo.common.threadpool.manager.FrameworkExecutorRepository)` could be null and is dereferenced at line 81.,https://github.com/apache/dubbo/blob/3.2/dubbo-monitor/dubbo-monitor-default/src/main/java/org/apache/dubbo/monitor/dubbo/DubboMonitor.java,"public DubboMonitor(Invoker<MonitorService> monitorInvoker, MonitorService monitorService) {
        this.monitorInvoker = monitorInvoker;
        this.monitorService = monitorService;
        scheduledExecutorService = monitorInvoker.getUrl().getOrDefaultFrameworkModel().getBeanFactory()
            .getBean(FrameworkExecutorRepository.class).getSharedScheduledExecutor();
        // The time interval for timer <b>scheduledExecutorService</b> to send data
        final long monitorInterval = monitorInvoker.getUrl().getPositiveParameter(MONITOR_SEND_DATA_INTERVAL_KEY, DEFAULT_MONITOR_SEND_DATA_INTERVAL);
        // collect timer for collecting statistics data
        sendFuture = scheduledExecutorService.scheduleWithFixedDelay(() -> {
            try {
                // collect data
                send();
            } catch (Throwable t) {
                logger.error(COMMON_MONITOR_EXCEPTION, """", """", ""Unexpected error occur at send statistic, cause: "" + t.getMessage(), t);
            }
        }, monitorInterval, monitorInterval, TimeUnit.MILLISECONDS);
    }",0
dubbo-3.2,NULL_DEREFERENCE,dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/util/DubboAnnotationUtils.java,"org.apache.dubbo.config.spring.util.DubboAnnotationUtils.resolveInterfaceName(java.util.LinkedHashMap,java.lang.Class):java.lang.String",108,object `interfaceClass` last assigned on line 92 could be null and is dereferenced at line 108.,"78: public static String resolveInterfaceName(Map<String, Object> attributes, Class<?> defaultInterfaceClass) {
 79: // 1. get from DubboService.interfaceName()
 80: String interfaceClassName = AnnotationUtils.getAttribute(attributes, ""interfaceName"");
 81: if (StringUtils.hasText(interfaceClassName)) {
 82: if (GenericService.class.getName().equals(interfaceClassName) ||
 83: com.alibaba.dubbo.rpc.service.GenericService.class.getName().equals(interfaceClassName)) {
 84: throw new IllegalStateException(""@Service interfaceName() cannot be GenericService: "" + interfaceClassName);
 85: }
 86: return interfaceClassName;
 87: }
 88: 
 89: // 2. get from DubboService.interfaceClass()
 90: Class<?> interfaceClass = AnnotationUtils.getAttribute(attributes, ""interfaceClass"");
 91: if (interfaceClass == null || void.class.equals(interfaceClass)) { // default or set void.class for purpose.
 92: interfaceClass = null;
 93: } else if (GenericService.class.isAssignableFrom(interfaceClass)) {
 94: throw new IllegalStateException(""@Service interfaceClass() cannot be GenericService :"" + interfaceClass.getName());
 95: }
 96: 
 97: // 3. get from annotation element type, ignore GenericService
 98: if (interfaceClass == null && defaultInterfaceClass != null && !GenericService.class.isAssignableFrom(defaultInterfaceClass)) {
 99: // Find all interfaces from the annotated class
 100: // To resolve an issue : https://github.com/apache/dubbo/issues/3251
 101: Class<?>[] allInterfaces = getAllInterfacesForClass(defaultInterfaceClass);
 102: if (allInterfaces.length > 0) {
 103: interfaceClass = allInterfaces[0];
 104: }
 105: }
 106: 
 107: Assert.notNull(interfaceClass, ""@Service interfaceClass() or interfaceName() or interface class must be present!"");
 108: Assert.isTrue(interfaceClass.isInterface(), ""The annotated type must be an interface!"");
 109: return interfaceClass.getName();","public static String resolveInterfaceName(Map<String, Object> attributes, Class<?> defaultInterfaceClass) {
        // 1. get from DubboService.interfaceName()
        String interfaceClassName = AnnotationUtils.getAttribute(attributes, ""interfaceName"");
        if (StringUtils.hasText(interfaceClassName)) {
            if (GenericService.class.getName().equals(interfaceClassName) ||
                com.alibaba.dubbo.rpc.service.GenericService.class.getName().equals(interfaceClassName)) {
                throw new IllegalStateException(""@Service interfaceName() cannot be GenericService: "" + interfaceClassName);
            }
            return interfaceClassName;
        }

        // 2. get from DubboService.interfaceClass()
        Class<?> interfaceClass = AnnotationUtils.getAttribute(attributes, ""interfaceClass"");
        if (interfaceClass == null || void.class.equals(interfaceClass)) { // default or set void.class for purpose.
            interfaceClass = null;
        } else  if (GenericService.class.isAssignableFrom(interfaceClass)) {
            throw new IllegalStateException(""@Service interfaceClass() cannot be GenericService :"" + interfaceClass.getName());
        }

        // 3. get from annotation element type, ignore GenericService
        if (interfaceClass == null && defaultInterfaceClass != null  && !GenericService.class.isAssignableFrom(defaultInterfaceClass)) {
            // Find all interfaces from the annotated class
            // To resolve an issue : https://github.com/apache/dubbo/issues/3251
            Class<?>[] allInterfaces = getAllInterfacesForClass(defaultInterfaceClass);
            if (allInterfaces.length > 0) {
                interfaceClass = allInterfaces[0];
            }
        }

        Assert.notNull(interfaceClass, ""@Service interfaceClass() or interfaceName() or interface class must be present!"");
        Assert.isTrue(interfaceClass.isInterface(), ""The annotated type must be an interface!"");
        return interfaceClass.getName();
    }",0
dubbo-3.2,NULL_DEREFERENCE,dubbo-rpc/dubbo-rpc-rest/src/main/java/org/apache/dubbo/rpc/protocol/rest/netty/ssl/SslServerTlsHandler.java,"org.apache.dubbo.rpc.protocol.rest.netty.ssl.SslServerTlsHandler.decode(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List):void",89,object `certManager` last assigned on line 88 could be null and is dereferenced at line 89.,"78: protected void decode(ChannelHandlerContext channelHandlerContext, ByteBuf byteBuf, List<Object> list) throws Exception {
 79: // Will use the first five bytes to detect a protocol.
 80: if (byteBuf.readableBytes() < 5) {
 81: return;
 82: }
 83: 
 84: if (sslDetected) {
 85: return;
 86: }
 87: 
 88: CertManager certManager = url.getOrDefaultFrameworkModel().getBeanFactory().getBean(CertManager.class);
 89: ProviderCert providerConnectionConfig = certManager.getProviderConnectionConfig(url, channelHandlerContext.channel().remoteAddress());
 90: 
 91: if (providerConnectionConfig == null) {
 92: ChannelPipeline p = channelHandlerContext.pipeline();
 93: p.remove(this);
 94: return;
 95: }
 96: 
 97: if (isSsl(byteBuf)) {
 98: SslContext sslContext = SslContexts.buildServerSslContext(providerConnectionConfig);
 99: enableSsl(channelHandlerContext, sslContext);
 100: return;
 101: }
 102: 
 103: if (providerConnectionConfig.getAuthPolicy() == AuthPolicy.NONE) {
 104: ChannelPipeline p = channelHandlerContext.pipeline();
 105: p.remove(this);
 106: }
 107: 
 108: logger.error(INTERNAL_ERROR, """", """", ""TLS negotiation failed when trying to accept new connection."");
 109: channelHandlerContext.close();","protected void decode(ChannelHandlerContext channelHandlerContext, ByteBuf byteBuf, List<Object> list) throws Exception {
        // Will use the first five bytes to detect a protocol.
        if (byteBuf.readableBytes() < 5) {
            return;
        }

        if (sslDetected) {
            return;
        }

        CertManager certManager = url.getOrDefaultFrameworkModel().getBeanFactory().getBean(CertManager.class);
        ProviderCert providerConnectionConfig = certManager.getProviderConnectionConfig(url, channelHandlerContext.channel().remoteAddress());

        if (providerConnectionConfig == null) {
            ChannelPipeline p = channelHandlerContext.pipeline();
            p.remove(this);
            return;
        }

        if (isSsl(byteBuf)) {
            SslContext sslContext = SslContexts.buildServerSslContext(providerConnectionConfig);
            enableSsl(channelHandlerContext, sslContext);
            return;
        }

        if (providerConnectionConfig.getAuthPolicy() == AuthPolicy.NONE) {
            ChannelPipeline p = channelHandlerContext.pipeline();
            p.remove(this);
        }

        logger.error(INTERNAL_ERROR, """", """", ""TLS negotiation failed when trying to accept new connection."");
        channelHandlerContext.close();
    }",0
dubbo-3.2,NULL_DEREFERENCE,dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/ssl/SslServerTlsHandler.java,"org.apache.dubbo.remoting.transport.netty4.ssl.SslServerTlsHandler.decode(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List):void",90,object `certManager` last assigned on line 89 could be null and is dereferenced at line 90.,"79: protected void decode(ChannelHandlerContext channelHandlerContext, ByteBuf byteBuf, List<Object> list) throws Exception {
 80: // Will use the first five bytes to detect a protocol.
 81: if (byteBuf.readableBytes() < 5) {
 82: return;
 83: }
 84: 
 85: if (sslDetected) {
 86: return;
 87: }
 88: 
 89: CertManager certManager = url.getOrDefaultFrameworkModel().getBeanFactory().getBean(CertManager.class);
 90: ProviderCert providerConnectionConfig = certManager.getProviderConnectionConfig(url, channelHandlerContext.channel().remoteAddress());
 91: 
 92: if (providerConnectionConfig == null) {
 93: ChannelPipeline p = channelHandlerContext.pipeline();
 94: p.remove(this);
 95: return;
 96: }
 97: 
 98: if (isSsl(byteBuf)) {
 99: SslContext sslContext = SslContexts.buildServerSslContext(providerConnectionConfig);
 100: enableSsl(channelHandlerContext, sslContext);
 101: return;
 102: }
 103: 
 104: if (providerConnectionConfig.getAuthPolicy() == AuthPolicy.NONE) {
 105: ChannelPipeline p = channelHandlerContext.pipeline();
 106: p.remove(this);
 107: }
 108: 
 109: logger.error(INTERNAL_ERROR, """", """", ""TLS negotiation failed when trying to accept new connection."");
 110: channelHandlerContext.close();","protected void decode(ChannelHandlerContext channelHandlerContext, ByteBuf byteBuf, List<Object> list) throws Exception {
        // Will use the first five bytes to detect a protocol.
        if (byteBuf.readableBytes() < 5) {
            return;
        }

        if (sslDetected) {
            return;
        }

        CertManager certManager = url.getOrDefaultFrameworkModel().getBeanFactory().getBean(CertManager.class);
        ProviderCert providerConnectionConfig = certManager.getProviderConnectionConfig(url, channelHandlerContext.channel().remoteAddress());

        if (providerConnectionConfig == null) {
            ChannelPipeline p = channelHandlerContext.pipeline();
            p.remove(this);
            return;
        }

        if (isSsl(byteBuf)) {
            SslContext sslContext = SslContexts.buildServerSslContext(providerConnectionConfig);
            enableSsl(channelHandlerContext, sslContext);
            return;
        }

        if (providerConnectionConfig.getAuthPolicy() == AuthPolicy.NONE) {
            ChannelPipeline p = channelHandlerContext.pipeline();
            p.remove(this);
        }

        logger.error(INTERNAL_ERROR, """", """", ""TLS negotiation failed when trying to accept new connection."");
        channelHandlerContext.close();
    }",0
dubbo-3.2,NULL_DEREFERENCE,dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyServerHandler.java,org.apache.dubbo.remoting.transport.netty4.NettyServerHandler.channelInactive(io.netty.channel.ChannelHandlerContext):void,83,object returned by `ctx.channel()` could be null and is dereferenced at line 83.,"80: public void channelInactive(ChannelHandlerContext ctx) throws Exception {
 81: NettyChannel channel = NettyChannel.getOrAddChannel(ctx.channel(), url, handler);
 82: try {
 83: channels.remove(NetUtils.toAddressString((InetSocketAddress) ctx.channel().remoteAddress()));
 84: handler.disconnected(channel);
 85: } finally {
 86: NettyChannel.removeChannel(ctx.channel());
 87: }
 88: 
 89: if (logger.isInfoEnabled()) {","public void channelInactive(ChannelHandlerContext ctx) throws Exception {
        NettyChannel channel = NettyChannel.getOrAddChannel(ctx.channel(), url, handler);
        try {
            channels.remove(NetUtils.toAddressString((InetSocketAddress) ctx.channel().remoteAddress()));
            handler.disconnected(channel);
        } finally {
            NettyChannel.removeChannel(ctx.channel());
        }

        if (logger.isInfoEnabled()) {
            logger.info(""The connection of "" + channel.getRemoteAddress() + "" -> "" + channel.getLocalAddress() + "" is disconnected."");
        }
    }",1
dubbo-3.2,NULL_DEREFERENCE,dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/AbstractServiceDiscovery.java,"org.apache.dubbo.registry.client.AbstractServiceDiscovery.<init>(org.apache.dubbo.rpc.model.ApplicationModel,org.apache.dubbo.common.URL)",86,object `metadataReportInstance` last assigned on line 85 could be null and is dereferenced at line 86.,https://github.com/apache/dubbo/blob/3.2/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/AbstractServiceDiscovery.java,"public AbstractServiceDiscovery(ApplicationModel applicationModel, URL registryURL) {
        this(applicationModel, applicationModel.getApplicationName(), registryURL);
        MetadataReportInstance metadataReportInstance = applicationModel.getBeanFactory().getBean(MetadataReportInstance.class);
        metadataType = metadataReportInstance.getMetadataType();
        this.metadataReport = metadataReportInstance.getMetadataReport(registryURL.getParameter(REGISTRY_CLUSTER_KEY));
    }",0
dubbo-3.2,NULL_DEREFERENCE,dubbo-remoting/dubbo-remoting-netty/src/main/java/org/apache/dubbo/remoting/transport/netty/NettyHandler.java,"org.apache.dubbo.remoting.transport.netty.NettyHandler.channelDisconnected(org.jboss.netty.channel.ChannelHandlerContext,org.jboss.netty.channel.ChannelStateEvent):void",87,object returned by `ctx.getChannel()` could be null and is dereferenced at line 87.,"84: public void channelDisconnected(ChannelHandlerContext ctx, ChannelStateEvent e) throws Exception {
 85: NettyChannel channel = NettyChannel.getOrAddChannel(ctx.getChannel(), url, handler);
 86: try {
 87: channels.remove(NetUtils.toAddressString((InetSocketAddress) ctx.getChannel().getRemoteAddress()));
 88: handler.disconnected(channel);
 89: } finally {
 90: NettyChannel.removeChannelIfDisconnected(ctx.getChannel());
 91: }
 92: 
 93: if (logger.isInfoEnabled()) {","public void channelDisconnected(ChannelHandlerContext ctx, ChannelStateEvent e) throws Exception {
        NettyChannel channel = NettyChannel.getOrAddChannel(ctx.getChannel(), url, handler);
        try {
            channels.remove(NetUtils.toAddressString((InetSocketAddress) ctx.getChannel().getRemoteAddress()));
            handler.disconnected(channel);
        } finally {
            NettyChannel.removeChannelIfDisconnected(ctx.getChannel());
        }

        if (logger.isInfoEnabled()) {
            logger.info(""The connection between "" + channel.getRemoteAddress() + "" and "" + channel.getLocalAddress() + "" is disconnected"");
        }
    }",1
dubbo-3.2,NULL_DEREFERENCE,dubbo-rpc/dubbo-rpc-rest/src/main/java/org/apache/dubbo/rpc/protocol/rest/netty/ssl/SslContexts.java,org.apache.dubbo.rpc.protocol.rest.netty.ssl.SslContexts.buildClientSslContext(org.apache.dubbo.common.URL):io.netty.handler.ssl.SslContext,86,object `certManager` last assigned on line 85 could be null and is dereferenced at line 86.,"84: public static SslContext buildClientSslContext(URL url) {
 85: CertManager certManager = url.getOrDefaultFrameworkModel().getBeanFactory().getBean(CertManager.class);
 86: Cert consumerConnectionConfig = certManager.getConsumerConnectionConfig(url);
 87: if (consumerConnectionConfig == null) {
 88: return null;
 89: }
 90: 
 91: SslContextBuilder builder = SslContextBuilder.forClient();
 92: InputStream clientTrustCertCollectionPath = null;
 93: InputStream clientCertChainFilePath = null;
 94: InputStream clientPrivateKeyFilePath = null;
 95: try {
 96: clientTrustCertCollectionPath = consumerConnectionConfig.getTrustCertInputStream();
 97: if (clientTrustCertCollectionPath != null) {
 98: builder.trustManager(clientTrustCertCollectionPath);
 99: }
 100: 
 101: clientCertChainFilePath = consumerConnectionConfig.getKeyCertChainInputStream();
 102: clientPrivateKeyFilePath = consumerConnectionConfig.getPrivateKeyInputStream();
 103: if (clientCertChainFilePath != null && clientPrivateKeyFilePath != null) {
 104: String password = consumerConnectionConfig.getPassword();
 105: if (password != null) {
 106: builder.keyManager(clientCertChainFilePath, clientPrivateKeyFilePath, password);
 107: } else {
 108: builder.keyManager(clientCertChainFilePath, clientPrivateKeyFilePath);
 109: }
 110: }
 111: } catch (Exception e) {
 112: throw new IllegalArgumentException(""Could not find certificate file or find invalid certificate."", e);
 113: } finally {
 114: safeCloseStream(clientTrustCertCollectionPath);
 115: safeCloseStream(clientCertChainFilePath);
 116: safeCloseStream(clientPrivateKeyFilePath);
 117: }
 118: try {","public static SslContext buildClientSslContext(URL url) {
        CertManager certManager = url.getOrDefaultFrameworkModel().getBeanFactory().getBean(CertManager.class);
        Cert consumerConnectionConfig = certManager.getConsumerConnectionConfig(url);
        if (consumerConnectionConfig == null) {
            return null;
        }

        SslContextBuilder builder = SslContextBuilder.forClient();
        InputStream clientTrustCertCollectionPath = null;
        InputStream clientCertChainFilePath = null;
        InputStream clientPrivateKeyFilePath = null;
        try {
            clientTrustCertCollectionPath = consumerConnectionConfig.getTrustCertInputStream();
            if (clientTrustCertCollectionPath != null) {
                builder.trustManager(clientTrustCertCollectionPath);
            }

            clientCertChainFilePath = consumerConnectionConfig.getKeyCertChainInputStream();
            clientPrivateKeyFilePath = consumerConnectionConfig.getPrivateKeyInputStream();
            if (clientCertChainFilePath != null && clientPrivateKeyFilePath != null) {
                String password = consumerConnectionConfig.getPassword();
                if (password != null) {
                    builder.keyManager(clientCertChainFilePath, clientPrivateKeyFilePath, password);
                } else {
                    builder.keyManager(clientCertChainFilePath, clientPrivateKeyFilePath);
                }
            }
        } catch (Exception e) {
            throw new IllegalArgumentException(""Could not find certificate file or find invalid certificate."", e);
        } finally {
            safeCloseStream(clientTrustCertCollectionPath);
            safeCloseStream(clientCertChainFilePath);
            safeCloseStream(clientPrivateKeyFilePath);
        }
        try {
            return builder.sslProvider(findSslProvider()).build();
        } catch (SSLException e) {
            throw new IllegalStateException(""Build SslSession failed."", e);
        }
    }",0
dubbo-3.2,NULL_DEREFERENCE,dubbo-rpc/dubbo-rpc-rest/src/main/java/org/apache/dubbo/rpc/protocol/rest/util/MultiValueCreator.java,"org.apache.dubbo.rpc.protocol.rest.util.MultiValueCreator.add(java.lang.Object,java.lang.String,java.lang.Object):void",97,object `multiValueMapAdd` last assigned on line 90 could be null and is dereferenced by call to `invokeAndTryCatch(...)` at line 97.,https://github.com/apache/dubbo/blob/3.2/dubbo-rpc/dubbo-rpc-rest/src/main/java/org/apache/dubbo/rpc/protocol/rest/util/MultiValueCreator.java,"public static void add(Object multiValueMap, String key, Object value) {
        try {
            if (multiValueMap == null) {
                return;
            }

            Method multiValueMapAdd = null;
            if (springMultiValueMapImplClass.equals(multiValueMap.getClass())) {
                multiValueMapAdd = springMultiValueMapAdd;
            } else if (jaxrsMultiValueMapImplClass.equals(multiValueMap.getClass())) {
                multiValueMapAdd = jaxrsMultiValueMapAdd;
            }

            ReflectUtils.invokeAndTryCatch(multiValueMap, multiValueMapAdd, new Object[]{key, value});
        } catch (Exception e) {
            logger.error("""", e.getMessage(), """", ""dubbo rest form content-type param add data  error: "", e);
        }
    }",0
dubbo-3.2,NULL_DEREFERENCE,dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/ssl/SslContexts.java,org.apache.dubbo.remoting.transport.netty4.ssl.SslContexts.buildClientSslContext(org.apache.dubbo.common.URL):io.netty.handler.ssl.SslContext,87,object `certManager` last assigned on line 86 could be null and is dereferenced at line 87.,"85: public static SslContext buildClientSslContext(URL url) {
 86: CertManager certManager = url.getOrDefaultFrameworkModel().getBeanFactory().getBean(CertManager.class);
 87: Cert consumerConnectionConfig = certManager.getConsumerConnectionConfig(url);
 88: if (consumerConnectionConfig == null) {
 89: return null;
 90: }
 91: 
 92: SslContextBuilder builder = SslContextBuilder.forClient();
 93: InputStream clientTrustCertCollectionPath = null;
 94: InputStream clientCertChainFilePath = null;
 95: InputStream clientPrivateKeyFilePath = null;
 96: try {
 97: clientTrustCertCollectionPath = consumerConnectionConfig.getTrustCertInputStream();
 98: if (clientTrustCertCollectionPath != null) {
 99: builder.trustManager(clientTrustCertCollectionPath);
 100: }
 101: 
 102: clientCertChainFilePath = consumerConnectionConfig.getKeyCertChainInputStream();
 103: clientPrivateKeyFilePath = consumerConnectionConfig.getPrivateKeyInputStream();
 104: if (clientCertChainFilePath != null && clientPrivateKeyFilePath != null) {
 105: String password = consumerConnectionConfig.getPassword();
 106: if (password != null) {
 107: builder.keyManager(clientCertChainFilePath, clientPrivateKeyFilePath, password);
 108: } else {
 109: builder.keyManager(clientCertChainFilePath, clientPrivateKeyFilePath);
 110: }
 111: }
 112: } catch (Exception e) {
 113: throw new IllegalArgumentException(""Could not find certificate file or find invalid certificate."", e);
 114: } finally {
 115: safeCloseStream(clientTrustCertCollectionPath);
 116: safeCloseStream(clientCertChainFilePath);
 117: safeCloseStream(clientPrivateKeyFilePath);
 118: }
 119: try {","public static SslContext buildClientSslContext(URL url) {
        CertManager certManager = url.getOrDefaultFrameworkModel().getBeanFactory().getBean(CertManager.class);
        Cert consumerConnectionConfig = certManager.getConsumerConnectionConfig(url);
        if (consumerConnectionConfig == null) {
            return null;
        }

        SslContextBuilder builder = SslContextBuilder.forClient();
        InputStream clientTrustCertCollectionPath = null;
        InputStream clientCertChainFilePath = null;
        InputStream clientPrivateKeyFilePath = null;
        try {
            clientTrustCertCollectionPath = consumerConnectionConfig.getTrustCertInputStream();
            if (clientTrustCertCollectionPath != null) {
                builder.trustManager(clientTrustCertCollectionPath);
            }

            clientCertChainFilePath = consumerConnectionConfig.getKeyCertChainInputStream();
            clientPrivateKeyFilePath = consumerConnectionConfig.getPrivateKeyInputStream();
            if (clientCertChainFilePath != null && clientPrivateKeyFilePath != null) {
                String password = consumerConnectionConfig.getPassword();
                if (password != null) {
                    builder.keyManager(clientCertChainFilePath, clientPrivateKeyFilePath, password);
                } else {
                    builder.keyManager(clientCertChainFilePath, clientPrivateKeyFilePath);
                }
            }
        } catch (Exception e) {
            throw new IllegalArgumentException(""Could not find certificate file or find invalid certificate."", e);
        } finally {
            safeCloseStream(clientTrustCertCollectionPath);
            safeCloseStream(clientCertChainFilePath);
            safeCloseStream(clientPrivateKeyFilePath);
        }
        try {
            return builder.sslProvider(findSslProvider()).build();
        } catch (SSLException e) {
            throw new IllegalStateException(""Build SslSession failed."", e);
        }
    }",0
dubbo-3.2,NULL_DEREFERENCE,dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/protocol/ProtocolSecurityWrapper.java,"org.apache.dubbo.rpc.protocol.ProtocolSecurityWrapper.refer(java.lang.Class,org.apache.dubbo.common.URL):org.apache.dubbo.rpc.Invoker",93,object `serializeSecurityConfigurator` last assigned on line 92 could be null and is dereferenced at line 93.,"87: public <T> Invoker<T> refer(Class<T> type, URL url) throws RpcException {
 88: try {
 89: ServiceModel serviceModel = url.getServiceModel();
 90: ScopeModel scopeModel = url.getScopeModel();
 91: SerializeSecurityConfigurator serializeSecurityConfigurator = ScopeModelUtil.getModuleModel(scopeModel)
 92: .getBeanFactory().getBean(SerializeSecurityConfigurator.class);
 93: serializeSecurityConfigurator.refreshStatus();
 94: serializeSecurityConfigurator.refreshCheck();
 95: 
 96: Optional.ofNullable(serviceModel)
 97: .map(ServiceModel::getServiceModel)
 98: .map(ServiceDescriptor::getServiceInterfaceClass)
 99: .ifPresent(serializeSecurityConfigurator::registerInterface);
 100: 
 101: Optional.ofNullable(serviceModel)
 102: .map(ServiceModel::getServiceMetadata)
 103: .map(ServiceMetadata::getServiceType)
 104: .ifPresent(serializeSecurityConfigurator::registerInterface);
 105: serializeSecurityConfigurator.registerInterface(type);
 106: } catch (Throwable t) {
 107: logger.error(INTERNAL_ERROR, """", """", ""Failed to register interface for security check"", t);
 108: }
 109: 
 110: return protocol.refer(type, url);","public <T> Invoker<T> refer(Class<T> type, URL url) throws RpcException {
        try {
            ServiceModel serviceModel = url.getServiceModel();
            ScopeModel scopeModel = url.getScopeModel();
            SerializeSecurityConfigurator serializeSecurityConfigurator = ScopeModelUtil.getModuleModel(scopeModel)
                .getBeanFactory().getBean(SerializeSecurityConfigurator.class);
            serializeSecurityConfigurator.refreshStatus();
            serializeSecurityConfigurator.refreshCheck();

            Optional.ofNullable(serviceModel)
                .map(ServiceModel::getServiceModel)
                .map(ServiceDescriptor::getServiceInterfaceClass)
                .ifPresent(serializeSecurityConfigurator::registerInterface);

            Optional.ofNullable(serviceModel)
                .map(ServiceModel::getServiceMetadata)
                .map(ServiceMetadata::getServiceType)
                .ifPresent(serializeSecurityConfigurator::registerInterface);
            serializeSecurityConfigurator.registerInterface(type);
        } catch (Throwable t) {
            logger.error(INTERNAL_ERROR, """", """", ""Failed to register interface for security check"", t);
        }

        return protocol.refer(type, url);
    }",0
dubbo-3.2,NULL_DEREFERENCE,dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java,"org.apache.dubbo.remoting.transport.netty4.NettyClientHandler.userEventTriggered(io.netty.channel.ChannelHandlerContext,java.lang.Object):void",102,object `channel` last assigned on line 94 could be null and is dereferenced at line 102.,https://github.com/apache/dubbo/blob/3.2/dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyPortUnificationServerHandler.java,"public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {
        // send heartbeat when read idle.
        if (evt instanceof IdleStateEvent) {
            try {
                NettyChannel channel = NettyChannel.getOrAddChannel(ctx.channel(), url, handler);
                if (logger.isDebugEnabled()) {
                    logger.debug(""IdleStateEvent triggered, send heartbeat to channel "" + channel);
                }
                Request req = new Request();
                req.setVersion(Version.getProtocolVersion());
                req.setTwoWay(true);
                req.setEvent(HEARTBEAT_EVENT);
                channel.send(req);
            } finally {
                NettyChannel.removeChannelIfDisconnected(ctx.channel());
            }
        } else {
            super.userEventTriggered(ctx, evt);
        }
    }",1
dubbo-3.2,NULL_DEREFERENCE,dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyPortUnificationServerHandler.java,"org.apache.dubbo.remoting.transport.netty4.NettyPortUnificationServerHandler.decode(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List):void",100,object `certManager` last assigned on line 99 could be null and is dereferenced at line 100.,"90: protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out)
 91: throws Exception {
 92: NettyChannel channel = NettyChannel.getOrAddChannel(ctx.channel(), url, handler);
 93: // Will use the first five bytes to detect a protocol.
 94: // size of telnet command ls is 2 bytes
 95: if (in.readableBytes() < 2) {
 96: return;
 97: }
 98: 
 99: CertManager certManager = url.getOrDefaultFrameworkModel().getBeanFactory().getBean(CertManager.class);
 100: ProviderCert providerConnectionConfig = certManager.getProviderConnectionConfig(url, ctx.channel().remoteAddress());
 101: 
 102: if (providerConnectionConfig != null && isSsl(in)) {","protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out)
        throws Exception {
        NettyChannel channel = NettyChannel.getOrAddChannel(ctx.channel(), url, handler);
        // Will use the first five bytes to detect a protocol.
        // size of telnet command ls is 2 bytes
        if (in.readableBytes() < 2) {
            return;
        }

        CertManager certManager = url.getOrDefaultFrameworkModel().getBeanFactory().getBean(CertManager.class);
        ProviderCert providerConnectionConfig = certManager.getProviderConnectionConfig(url, ctx.channel().remoteAddress());

        if (providerConnectionConfig != null && isSsl(in)) {
            enableSsl(ctx, providerConnectionConfig);
        } else {
            for (final WireProtocol protocol : protocols) {
                in.markReaderIndex();
                ChannelBuffer buf = new NettyBackedChannelBuffer(in);
                final ProtocolDetector.Result result = protocol.detector().detect(buf);
                in.resetReaderIndex();
                switch (result) {
                    case UNRECOGNIZED:
                        continue;
                    case RECOGNIZED:
                        String protocolName = url.getOrDefaultFrameworkModel().getExtensionLoader(WireProtocol.class)
                            .getExtensionName(protocol);
                        ChannelHandler localHandler = this.handlerMapper.getOrDefault(protocolName, handler);
                        URL localURL = this.urlMapper.getOrDefault(protocolName, url);
                        channel.setUrl(localURL);
                        NettyConfigOperator operator = new NettyConfigOperator(channel, localHandler);
                        protocol.configServerProtocolHandler(url, operator);
                        ctx.pipeline().remove(this);
                    case NEED_MORE_DATA:
                        return;
                    default:
                        return;
                }
            }
            byte[] preface = new byte[in.readableBytes()];
            in.readBytes(preface);
            Set<String> supported = url.getApplicationModel()
                .getExtensionLoader(WireProtocol.class)
                .getSupportedExtensions();
            LOGGER.error(INTERNAL_ERROR, ""unknown error in remoting module"", """", String.format(""Can not recognize protocol from downstream=%s . ""
                    + ""preface=%s protocols=%s"", ctx.channel().remoteAddress(),
                Bytes.bytes2hex(preface),
                supported));

            // Unknown protocol; discard everything and close the connection.
            in.clear();
            ctx.close();
        }
    }",0
dubbo-3.2,NULL_DEREFERENCE,dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyPortUnificationServerHandler.java,"org.apache.dubbo.remoting.transport.netty4.NettyPortUnificationServerHandler.decode(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List):void",131,object returned by `NettyPortUnificationServerHandler.url.getApplicationModel()` could be null and is dereferenced at line 131.,https://github.com/apache/dubbo/blob/3.2/dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyPortUnificationServerHandler.java,"protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out)
        throws Exception {
        NettyChannel channel = NettyChannel.getOrAddChannel(ctx.channel(), url, handler);
        // Will use the first five bytes to detect a protocol.
        // size of telnet command ls is 2 bytes
        if (in.readableBytes() < 2) {
            return;
        }

        CertManager certManager = url.getOrDefaultFrameworkModel().getBeanFactory().getBean(CertManager.class);
        ProviderCert providerConnectionConfig = certManager.getProviderConnectionConfig(url, ctx.channel().remoteAddress());

        if (providerConnectionConfig != null && isSsl(in)) {
            enableSsl(ctx, providerConnectionConfig);
        } else {
            for (final WireProtocol protocol : protocols) {
                in.markReaderIndex();
                ChannelBuffer buf = new NettyBackedChannelBuffer(in);
                final ProtocolDetector.Result result = protocol.detector().detect(buf);
                in.resetReaderIndex();
                switch (result) {
                    case UNRECOGNIZED:
                        continue;
                    case RECOGNIZED:
                        String protocolName = url.getOrDefaultFrameworkModel().getExtensionLoader(WireProtocol.class)
                            .getExtensionName(protocol);
                        ChannelHandler localHandler = this.handlerMapper.getOrDefault(protocolName, handler);
                        URL localURL = this.urlMapper.getOrDefault(protocolName, url);
                        channel.setUrl(localURL);
                        NettyConfigOperator operator = new NettyConfigOperator(channel, localHandler);
                        protocol.configServerProtocolHandler(url, operator);
                        ctx.pipeline().remove(this);
                    case NEED_MORE_DATA:
                        return;
                    default:
                        return;
                }
            }
            byte[] preface = new byte[in.readableBytes()];
            in.readBytes(preface);
            Set<String> supported = url.getApplicationModel()
                .getExtensionLoader(WireProtocol.class)
                .getSupportedExtensions();
            LOGGER.error(INTERNAL_ERROR, ""unknown error in remoting module"", """", String.format(""Can not recognize protocol from downstream=%s . ""
                    + ""preface=%s protocols=%s"", ctx.channel().remoteAddress(),
                Bytes.bytes2hex(preface),
                supported));

            // Unknown protocol; discard everything and close the connection.
            in.clear();
            ctx.close();
        }
    }

   ",1
dubbo-3.2,NULL_DEREFERENCE,dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyPortUnificationServerHandler.java,"org.apache.dubbo.remoting.transport.netty4.NettyPortUnificationServerHandler.decode(io.netty.channel.ChannelHandlerContext,io.netty.buffer.ByteBuf,java.util.List):void",100,object returned by `ctx.channel()` could be null and is dereferenced at line 100.,"90: protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out)
 91: throws Exception {
 92: NettyChannel channel = NettyChannel.getOrAddChannel(ctx.channel(), url, handler);
 93: // Will use the first five bytes to detect a protocol.
 94: // size of telnet command ls is 2 bytes
 95: if (in.readableBytes() < 2) {
 96: return;
 97: }
 98: 
 99: CertManager certManager = url.getOrDefaultFrameworkModel().getBeanFactory().getBean(CertManager.class);
 100: ProviderCert providerConnectionConfig = certManager.getProviderConnectionConfig(url, ctx.channel().remoteAddress());
 101: 
 102: if (providerConnectionConfig != null && isSsl(in)) {","protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out)
        throws Exception {
        NettyChannel channel = NettyChannel.getOrAddChannel(ctx.channel(), url, handler);
        // Will use the first five bytes to detect a protocol.
        // size of telnet command ls is 2 bytes
        if (in.readableBytes() < 2) {
            return;
        }

        CertManager certManager = url.getOrDefaultFrameworkModel().getBeanFactory().getBean(CertManager.class);
        ProviderCert providerConnectionConfig = certManager.getProviderConnectionConfig(url, ctx.channel().remoteAddress());

        if (providerConnectionConfig != null && isSsl(in)) {
            enableSsl(ctx, providerConnectionConfig);
        } else {
            for (final WireProtocol protocol : protocols) {
                in.markReaderIndex();
                ChannelBuffer buf = new NettyBackedChannelBuffer(in);
                final ProtocolDetector.Result result = protocol.detector().detect(buf);
                in.resetReaderIndex();
                switch (result) {
                    case UNRECOGNIZED:
                        continue;
                    case RECOGNIZED:
                        String protocolName = url.getOrDefaultFrameworkModel().getExtensionLoader(WireProtocol.class)
                            .getExtensionName(protocol);
                        ChannelHandler localHandler = this.handlerMapper.getOrDefault(protocolName, handler);
                        URL localURL = this.urlMapper.getOrDefault(protocolName, url);
                        channel.setUrl(localURL);
                        NettyConfigOperator operator = new NettyConfigOperator(channel, localHandler);
                        protocol.configServerProtocolHandler(url, operator);
                        ctx.pipeline().remove(this);
                    case NEED_MORE_DATA:
                        return;
                    default:
                        return;
                }
            }
            byte[] preface = new byte[in.readableBytes()];
            in.readBytes(preface);
            Set<String> supported = url.getApplicationModel()
                .getExtensionLoader(WireProtocol.class)
                .getSupportedExtensions();
            LOGGER.error(INTERNAL_ERROR, ""unknown error in remoting module"", """", String.format(""Can not recognize protocol from downstream=%s . ""
                    + ""preface=%s protocols=%s"", ctx.channel().remoteAddress(),
                Bytes.bytes2hex(preface),
                supported));

            // Unknown protocol; discard everything and close the connection.
            in.clear();
            ctx.close();
        }
    }

   ",1
dubbo-3.2,NULL_DEREFERENCE,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/state/AbstractStateRouter.java,"org.apache.dubbo.rpc.cluster.router.state.AbstractStateRouter.route(org.apache.dubbo.rpc.cluster.router.state.BitList,org.apache.dubbo.common.URL,org.apache.dubbo.rpc.RpcInvocation,boolean,org.apache.dubbo.common.utils.Holder):org.apache.dubbo.rpc.cluster.router.state.BitList",125,object `routeResult` last assigned on line 118 could be null and is dereferenced at line 125.,"92: public final BitList<Invoker<T>> route(BitList<Invoker<T>> invokers, URL url, Invocation invocation, boolean needToPrintMessage, Holder<RouterSnapshotNode<T>> nodeHolder) throws RpcException {
 93: if (needToPrintMessage && (nodeHolder == null || nodeHolder.get() == null)) {
 94: needToPrintMessage = false;
 95: }
 96: 
 97: RouterSnapshotNode<T> currentNode = null;
 98: RouterSnapshotNode<T> parentNode = null;
 99: Holder<String> messageHolder = null;
 100: 
 101: // pre-build current node
 102: if (needToPrintMessage) {
 103: parentNode = nodeHolder.get();
 104: currentNode = new RouterSnapshotNode<>(this.getClass().getSimpleName(), invokers.clone());
 105: parentNode.appendNode(currentNode);
 106: 
 107: // set parent node's output size in the first child invoke
 108: // initial node output size is zero, first child will override it
 109: if (parentNode.getNodeOutputSize() < invokers.size()) {
 110: parentNode.setNodeOutputInvokers(invokers.clone());
 111: }
 112: 
 113: messageHolder = new Holder<>();
 114: nodeHolder.set(currentNode);
 115: }
 116: BitList<Invoker<T>> routeResult;
 117: 
 118: routeResult = doRoute(invokers, url, invocation, needToPrintMessage, nodeHolder, messageHolder);
 119: if (routeResult != invokers) {
 120: routeResult = invokers.and(routeResult);
 121: }
 122: // check if router support call continue route by itself
 123: if (!supportContinueRoute()) {
 124: // use current node's result as next node's parameter
 125: if (!shouldFailFast || !routeResult.isEmpty()) {
 126: routeResult = continueRoute(routeResult, url, invocation, needToPrintMessage, nodeHolder);
 127: }
 128: }
 129: 
 130: // post-build current node
 131: if (needToPrintMessage) {
 132: currentNode.setRouterMessage(messageHolder.get());
 133: if (currentNode.getNodeOutputSize() == 0) {
 134: // no child call
 135: currentNode.setNodeOutputInvokers(routeResult.clone());
 136: }
 137: currentNode.setChainOutputInvokers(routeResult.clone());
 138: nodeHolder.set(parentNode);
 139: }
 140: return routeResult;","public final BitList<Invoker<T>> route(BitList<Invoker<T>> invokers, URL url, Invocation invocation, boolean needToPrintMessage, Holder<RouterSnapshotNode<T>> nodeHolder) throws RpcException {
        if (needToPrintMessage && (nodeHolder == null || nodeHolder.get() == null)) {
            needToPrintMessage = false;
        }

        RouterSnapshotNode<T> currentNode = null;
        RouterSnapshotNode<T> parentNode = null;
        Holder<String> messageHolder = null;

        // pre-build current node
        if (needToPrintMessage) {
            parentNode = nodeHolder.get();
            currentNode = new RouterSnapshotNode<>(this.getClass().getSimpleName(), invokers.clone());
            parentNode.appendNode(currentNode);

            // set parent node's output size in the first child invoke
            // initial node output size is zero, first child will override it
            if (parentNode.getNodeOutputSize() < invokers.size()) {
                parentNode.setNodeOutputInvokers(invokers.clone());
            }

            messageHolder = new Holder<>();
            nodeHolder.set(currentNode);
        }
        BitList<Invoker<T>> routeResult;

        routeResult = doRoute(invokers, url, invocation, needToPrintMessage, nodeHolder, messageHolder);
        if (routeResult != invokers) {
            routeResult = invokers.and(routeResult);
        }
        // check if router support call continue route by itself
        if (!supportContinueRoute()) {
            // use current node's result as next node's parameter
            if (!shouldFailFast || !routeResult.isEmpty()) {
                routeResult = continueRoute(routeResult, url, invocation, needToPrintMessage, nodeHolder);
            }
        }

        // post-build current node
        if (needToPrintMessage) {
            currentNode.setRouterMessage(messageHolder.get());
            if (currentNode.getNodeOutputSize() == 0) {
                // no child call
                currentNode.setNodeOutputInvokers(routeResult.clone());
            }
            currentNode.setChainOutputInvokers(routeResult.clone());
            nodeHolder.set(parentNode);
        }
        return routeResult;
    }",0
dubbo-3.2,NULL_DEREFERENCE,dubbo-metadata/dubbo-metadata-api/src/main/java/org/apache/dubbo/metadata/AbstractServiceNameMapping.java,"org.apache.dubbo.metadata.AbstractServiceNameMapping.getAndListen(org.apache.dubbo.common.URL,org.apache.dubbo.common.URL,org.apache.dubbo.metadata.MappingListener):java.util.Set",117,object returned by `AbstractServiceNameMapping.applicationModel.getFrameworkModel().getBeanFactory().getBean(org.apache.dubbo.common.threadpool.manager.FrameworkExecutorRepository)` could be null and is dereferenced at line 117.,https://github.com/apache/dubbo/blob/3.2/dubbo-metadata/dubbo-metadata-api/src/main/java/org/apache/dubbo/metadata/AbstractServiceNameMapping.java,"public Set<String> getAndListen(URL registryURL, URL subscribedURL, MappingListener listener) {
        String key = ServiceNameMapping.buildMappingKey(subscribedURL);
        // use previously cached services.
        Set<String> mappingServices = mappingCacheManager.get(key);

        // Asynchronously register listener in case previous cache does not exist or cache expired.
        if (CollectionUtils.isEmpty(mappingServices)) {
            try {
                logger.info(""Local cache mapping is empty"");
                mappingServices = (new AsyncMappingTask(listener, subscribedURL, false)).call();
            } catch (Exception e) {
                // ignore
            }
            if (CollectionUtils.isEmpty(mappingServices)) {
                String registryServices = registryURL.getParameter(SUBSCRIBED_SERVICE_NAMES_KEY);
                if (StringUtils.isNotEmpty(registryServices)) {
                    logger.info(subscribedURL.getServiceInterface() + "" mapping to "" + registryServices + "" instructed by registry subscribed-services."");
                    mappingServices = parseServices(registryServices);
                }
            }
            if (CollectionUtils.isNotEmpty(mappingServices)) {
                this.putCachedMapping(ServiceNameMapping.buildMappingKey(subscribedURL), mappingServices);
            }
        } else {
            ExecutorService executorService = applicationModel.getFrameworkModel().getBeanFactory()
                .getBean(FrameworkExecutorRepository.class).getMappingRefreshingExecutor();
            executorService.submit(new AsyncMappingTask(listener, subscribedURL, true));
        }

        return mappingServices;
    }",0
dubbo-3.2,NULL_DEREFERENCE,dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/ServiceDiscovery.java,org.apache.dubbo.registry.client.ServiceDiscovery.getDelay():long,94,object returned by `getUrl()` could be null and is dereferenced at line 94.,https://github.com/apache/dubbo/blob/3.2/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/ServiceDiscovery.java,"default long getDelay() {
        return getUrl().getParameter(REGISTRY_DELAY_NOTIFICATION_KEY, 5000);
    }",1
dubbo-3.2,NULL_DEREFERENCE,dubbo-common/src/main/java/org/apache/dubbo/common/config/Configuration.java,"org.apache.dubbo.common.config.Configuration.getBoolean(java.lang.String,boolean):boolean",95,"object returned by `getBoolean(key,toBooleanObject(defaultValue))` could be null and is dereferenced at line 95.","94: default boolean getBoolean(String key, boolean defaultValue) {
 95: return this.getBoolean(key, toBooleanObject(defaultValue));","default boolean getBoolean(String key, boolean defaultValue) {
        return this.getBoolean(key, toBooleanObject(defaultValue));
    }",0
dubbo-3.2,NULL_DEREFERENCE,dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/AbstractServiceDiscovery.java,"org.apache.dubbo.registry.client.AbstractServiceDiscovery.<init>(org.apache.dubbo.rpc.model.ApplicationModel,java.lang.String,org.apache.dubbo.common.URL)",102,object returned by `applicationModel.getFrameworkModel().getBeanFactory().getBean(org.apache.dubbo.common.threadpool.manager.FrameworkExecutorRepository)` could be null and is dereferenced at line 102.,https://github.com/apache/dubbo/blob/3.2/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/AbstractServiceDiscovery.java,"private AbstractServiceDiscovery(ApplicationModel applicationModel, String serviceName, URL registryURL) {
        this.applicationModel = applicationModel;
        this.serviceName = serviceName;
        this.registryURL = registryURL;
        this.metadataInfo = new MetadataInfo(serviceName);
        boolean localCacheEnabled = registryURL.getParameter(REGISTRY_LOCAL_FILE_CACHE_ENABLED, true);
        this.metaCacheManager = new MetaCacheManager(localCacheEnabled, getCacheNameSuffix(),
                applicationModel.getFrameworkModel().getBeanFactory()
                        .getBean(FrameworkExecutorRepository.class).getCacheRefreshingScheduledExecutor());
        int metadataInfoCacheExpireTime = registryURL.getParameter(METADATA_INFO_CACHE_EXPIRE_KEY, DEFAULT_METADATA_INFO_CACHE_EXPIRE);
        int metadataInfoCacheSize = registryURL.getParameter(METADATA_INFO_CACHE_SIZE_KEY, DEFAULT_METADATA_INFO_CACHE_SIZE);
        this.refreshCacheFuture = applicationModel.getFrameworkModel().getBeanFactory()
                .getBean(FrameworkExecutorRepository.class).getSharedScheduledExecutor()
                .scheduleAtFixedRate(() -> {
                    try {
                        while (metadataInfos.size() > metadataInfoCacheSize) {
                            AtomicReference<String> oldestRevision = new AtomicReference<>();
                            AtomicReference<MetadataInfoStat> oldestStat = new AtomicReference<>();
                            metadataInfos.forEach((k, v) -> {
                                if (System.currentTimeMillis() - v.getUpdateTime() > metadataInfoCacheExpireTime &&
                                        (oldestStat.get() == null || oldestStat.get().getUpdateTime() > v.getUpdateTime())) {
                                    oldestRevision.set(k);
                                    oldestStat.set(v);
                                }
                            });
                            if (oldestStat.get() != null) {
                                metadataInfos.remove(oldestRevision.get(), oldestStat.get());
                            }
                        }
                    } catch (Throwable t) {
                        logger.error(INTERNAL_ERROR, """", """", ""Error occurred when clean up metadata info cache."", t);
                    }
                }, metadataInfoCacheExpireTime / 2, metadataInfoCacheExpireTime / 2, TimeUnit.MILLISECONDS);
    }",0
dubbo-3.2,NULL_DEREFERENCE,dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/protocol/AbstractProtocol.java,org.apache.dubbo.rpc.protocol.AbstractProtocol.loadServerProperties(org.apache.dubbo.rpc.ProtocolServer):void,96,object returned by `server.getUrl()` could be null and is dereferenced at line 96.,"94: protected void loadServerProperties(ProtocolServer server) {
 95: // read and hold config before destroy
 96: int serverShutdownTimeout = ConfigurationUtils.getServerShutdownTimeout(server.getUrl().getScopeModel());
 97: server.getAttributes().put(SHUTDOWN_WAIT_KEY, serverShutdownTimeout);","protected void loadServerProperties(ProtocolServer server) {
        // read and hold config before destroy
        int serverShutdownTimeout = ConfigurationUtils.getServerShutdownTimeout(server.getUrl().getScopeModel());
        server.getAttributes().put(SHUTDOWN_WAIT_KEY, serverShutdownTimeout);
    }",1
dubbo-3.2,NULL_DEREFERENCE,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/mock/MockInvokersSelector.java,org.apache.dubbo.rpc.cluster.router.mock.MockInvokersSelector.lambda$cacheMockedInvokers$0(org.apache.dubbo.rpc.Invoker):boolean,95,object returned by `invoker.getUrl().getProtocol()` could be null and is dereferenced at line 95.,"93: private void cacheMockedInvokers(BitList<Invoker<T>> invokers) {
 94: BitList<Invoker<T>> clonedInvokers = invokers.clone();
 95: clonedInvokers.removeIf((invoker) -> !invoker.getUrl().getProtocol().equals(MOCK_PROTOCOL));
 96: mockedInvokers = clonedInvokers;","private void cacheMockedInvokers(BitList<Invoker<T>> invokers) {
        BitList<Invoker<T>> clonedInvokers = invokers.clone();
        clonedInvokers.removeIf((invoker) -> !invoker.getUrl().getProtocol().equals(MOCK_PROTOCOL));
        mockedInvokers = clonedInvokers;
    }",0
dubbo-3.2,NULL_DEREFERENCE,dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/ServiceBean.java,org.apache.dubbo.config.spring.ServiceBean.afterPropertiesSet():void,103,object `moduleModel` last assigned on line 102 could be null and is dereferenced at line 103.,"95: public void afterPropertiesSet() throws Exception {
 96: if (StringUtils.isEmpty(getPath())) {
 97: if (StringUtils.isNotEmpty(getInterface())) {
 98: setPath(getInterface());
 99: }
 100: }
 101: //register service bean
 102: ModuleModel moduleModel = DubboBeanUtils.getModuleModel(applicationContext);
 103: moduleModel.getConfigManager().addService(this);
 104: moduleModel.getDeployer().setPending();","public void afterPropertiesSet() throws Exception {
        if (StringUtils.isEmpty(getPath())) {
            if (StringUtils.isNotEmpty(getInterface())) {
                setPath(getInterface());
            }
        }
        //register service bean
        ModuleModel moduleModel = DubboBeanUtils.getModuleModel(applicationContext);
        moduleModel.getConfigManager().addService(this);
        moduleModel.getDeployer().setPending();
    }",1
dubbo-3.2,NULL_DEREFERENCE,dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/event/listener/ServiceInstancesChangedListener.java,"org.apache.dubbo.registry.client.event.listener.ServiceInstancesChangedListener.<init>(java.util.HashSet,org.apache.dubbo.registry.client.ServiceDiscovery)",105,object returned by `applicationModel.getBeanFactory().getBean(org.apache.dubbo.common.threadpool.manager.FrameworkExecutorRepository)` could be null and is dereferenced at line 105.,https://github.com/apache/dubbo/blob/3.2/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/event/listener/ServiceInstancesChangedListener.java,"public ServiceInstancesChangedListener(Set<String> serviceNames, ServiceDiscovery serviceDiscovery) {
        this.serviceNames = serviceNames;
        this.serviceDiscovery = serviceDiscovery;
        this.listeners = new ConcurrentHashMap<>();
        this.allInstances = new HashMap<>();
        this.serviceUrls = new HashMap<>();
        retryPermission = new Semaphore(1);
        ApplicationModel applicationModel = ScopeModelUtil.getApplicationModel(serviceDiscovery == null || serviceDiscovery.getUrl() == null ? null : serviceDiscovery.getUrl().getScopeModel());
        this.scheduler = applicationModel.getBeanFactory().getBean(FrameworkExecutorRepository.class).getMetadataRetryExecutor();
        this.serviceInstanceNotificationCustomizers = applicationModel.getExtensionLoader(ServiceInstanceNotificationCustomizer.class).getSupportedExtensionInstances();
        this.applicationModel = applicationModel;
    }",0
dubbo-3.2,NULL_DEREFERENCE,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/loadbalance/ConsistentHashLoadBalance.java,org.apache.dubbo.rpc.cluster.loadbalance.ConsistentHashLoadBalance$ConsistentHashSelector.select(org.apache.dubbo.rpc.Invocation):org.apache.dubbo.rpc.Invoker,99,object returned by `getMethodName(invocation)` could be null and is dereferenced by call to `getMD5(...)` at line 99.,"98: public Invoker<T> select(Invocation invocation) {
 99: byte[] digest = Bytes.getMD5(RpcUtils.getMethodName(invocation));
 100: return selectForKey(hash(digest, 0));","public Invoker<T> select(Invocation invocation) {
            byte[] digest = Bytes.getMD5(RpcUtils.getMethodName(invocation));
            return selectForKey(hash(digest, 0));
        }",1
dubbo-3.2,NULL_DEREFERENCE,dubbo-compatible/src/main/java/com/alibaba/dubbo/config/ServiceConfig.java,com.alibaba.dubbo.config.ServiceConfig.convertProviderToProtocol(com.alibaba.dubbo.config.ProviderConfig):com.alibaba.dubbo.config.ProtocolConfig,100,object returned by `provider.getProtocol()` could be null and is dereferenced at line 100.,"98: private static ProtocolConfig convertProviderToProtocol(ProviderConfig provider) {
 99: ProtocolConfig protocol = new ProtocolConfig();
 100: protocol.setName(provider.getProtocol().getName());
 101: protocol.setServer(provider.getServer());
 102: protocol.setClient(provider.getClient());
 103: protocol.setCodec(provider.getCodec());
 104: protocol.setHost(provider.getHost());
 105: protocol.setPort(provider.getPort());
 106: protocol.setPath(provider.getPath());
 107: protocol.setPayload(provider.getPayload());
 108: protocol.setThreads(provider.getThreads());
 109: protocol.setParameters(provider.getParameters());
 110: return protocol;","private static ProtocolConfig convertProviderToProtocol(ProviderConfig provider) {
        ProtocolConfig protocol = new ProtocolConfig();
        protocol.setName(provider.getProtocol().getName());
        protocol.setServer(provider.getServer());
        protocol.setClient(provider.getClient());
        protocol.setCodec(provider.getCodec());
        protocol.setHost(provider.getHost());
        protocol.setPort(provider.getPort());
        protocol.setPath(provider.getPath());
        protocol.setPayload(provider.getPayload());
        protocol.setThreads(provider.getThreads());
        protocol.setParameters(provider.getParameters());
        return protocol;
    }",1
dubbo-3.2,NULL_DEREFERENCE,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleProtocol.java,org.apache.dubbo.rpc.protocol.tri.TripleProtocol$1.afterUnExport():void,100,object returned by `TripleProtocol$1.val$url.getServiceModel()` could be null and is dereferenced at line 100.,"93: public <T> Exporter<T> export(Invoker<T> invoker) throws RpcException {
 94: URL url = invoker.getUrl();
 95: String key = serviceKey(url);
 96: final AbstractExporter<T> exporter = new AbstractExporter<T>(invoker) {
 97: @Override
 98: public void afterUnExport() {
 99: pathResolver.remove(url.getServiceKey());
 100: pathResolver.remove(url.getServiceModel().getServiceModel().getInterfaceName());
 101: // set service status
 102: if (triBuiltinService.enable()) {
 103: triBuiltinService.getHealthStatusManager()
 104: .setStatus(url.getServiceKey(), ServingStatus.NOT_SERVING);
 105: triBuiltinService.getHealthStatusManager()
 106: .setStatus(url.getServiceInterface(), ServingStatus.NOT_SERVING);
 107: }
 108: exporterMap.remove(key);
 109: }
 110: };
 111: 
 112: exporterMap.put(key, exporter);
 113: 
 114: invokers.add(invoker);
 115: 
 116: Invoker<?> previous = pathResolver.add(url.getServiceKey(), invoker);
 117: if (previous != null) {
 118: if (url.getServiceKey().equals(url.getServiceModel().getServiceModel().getInterfaceName())) {
 119: logger.info(""Already exists an invoker["" + previous.getUrl() + ""] on path["" + url.getServiceKey()
 120: + ""], dubbo will override with invoker["" + url + ""]"");
 121: } else {
 122: throw new IllegalStateException(""Already exists an invoker["" + previous.getUrl() + ""] on path["" +
 123: url.getServiceKey() + ""], failed to add invoker["" + url +
 124: ""] , please use unique serviceKey."");
 125: }
 126: }
 127: if (RESOLVE_FALLBACK_TO_DEFAULT) {
 128: previous = pathResolver.addIfAbsent(url.getServiceModel().getServiceModel().getInterfaceName(), invoker);
 129: if (previous != null) {
 130: logger.info(""Already exists an invoker["" + previous.getUrl() + ""] on path["" +
 131: url.getServiceModel().getServiceModel().getInterfaceName() +
 132: ""], dubbo will skip override with invoker["" + url + ""]"");
 133: } else {
 134: logger.info(""Add fallback triple invoker["" + url + ""] to path["" +
 135: url.getServiceModel().getServiceModel().getInterfaceName() + ""] with invoker["" + url + ""]"");
 136: }
 137: }
 138: 
 139: // set service status
 140: if (triBuiltinService.enable()) {
 141: triBuiltinService.getHealthStatusManager()
 142: .setStatus(url.getServiceKey(), HealthCheckResponse.ServingStatus.SERVING);
 143: triBuiltinService.getHealthStatusManager()
 144: .setStatus(url.getServiceInterface(), HealthCheckResponse.ServingStatus.SERVING);
 145: }
 146: // init
 147: ExecutorRepository.getInstance(url.getOrDefaultApplicationModel()).createExecutorIfAbsent(ExecutorUtil.setThreadName(url, SERVER_THREAD_POOL_NAME));
 148: 
 149: PortUnificationExchanger.bind(url, new DefaultPuHandler());
 150: optimizeSerialization(url);
 151: return exporter;","final AbstractExporter<T> exporter = new AbstractExporter<T>(invoker) {
            @Override
            public void afterUnExport() {
                pathResolver.remove(url.getServiceKey());
                pathResolver.remove(url.getServiceModel().getServiceModel().getInterfaceName());
                // set service status
                if (triBuiltinService.enable()) {
                    triBuiltinService.getHealthStatusManager()
                        .setStatus(url.getServiceKey(), ServingStatus.NOT_SERVING);
                    triBuiltinService.getHealthStatusManager()
                        .setStatus(url.getServiceInterface(), ServingStatus.NOT_SERVING);
                }
                exporterMap.remove(key);
            }",0
dubbo-3.2,NULL_DEREFERENCE,dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/support/CacheableFailbackRegistry.java,org.apache.dubbo.registry.support.CacheableFailbackRegistry.<init>(org.apache.dubbo.common.URL),105,object returned by `url.getOrDefaultFrameworkModel().getBeanFactory().getBean(org.apache.dubbo.common.threadpool.manager.FrameworkExecutorRepository)` could be null and is dereferenced at line 105.,https://github.com/apache/dubbo/blob/3.2/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/support/CacheableFailbackRegistry.java,"protected CacheableFailbackRegistry(URL url) {
        super(url);
        extraParameters = new HashMap<>(8);
        extraParameters.put(CHECK_KEY, String.valueOf(false));

        cacheRemovalScheduler = url.getOrDefaultFrameworkModel().getBeanFactory().getBean(FrameworkExecutorRepository.class).nextScheduledExecutor();
        cacheRemovalTaskIntervalInMillis = getIntConfig(url.getScopeModel(), CACHE_CLEAR_TASK_INTERVAL, 2 * 60 * 1000);
        cacheClearWaitingThresholdInMillis = getIntConfig(url.getScopeModel(), CACHE_CLEAR_WAITING_THRESHOLD, 5 * 60 * 1000);
    }",0
dubbo-3.2,NULL_DEREFERENCE,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/mock/MockInvokersSelector.java,org.apache.dubbo.rpc.cluster.router.mock.MockInvokersSelector.lambda$cacheNormalInvokers$1(org.apache.dubbo.rpc.Invoker):boolean,102,object returned by `invoker.getUrl().getProtocol()` could be null and is dereferenced at line 102.,"100: private void cacheNormalInvokers(BitList<Invoker<T>> invokers) {
 101: BitList<Invoker<T>> clonedInvokers = invokers.clone();
 102: clonedInvokers.removeIf((invoker) -> invoker.getUrl().getProtocol().equals(MOCK_PROTOCOL));
 103: normalInvokers = clonedInvokers;","private void cacheNormalInvokers(BitList<Invoker<T>> invokers) {
        BitList<Invoker<T>> clonedInvokers = invokers.clone();
        clonedInvokers.removeIf((invoker) -> invoker.getUrl().getProtocol().equals(MOCK_PROTOCOL));
        normalInvokers = clonedInvokers;
    }",1
dubbo-3.2,NULL_DEREFERENCE,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/Configurator.java,org.apache.dubbo.rpc.cluster.Configurator.compareTo(org.apache.dubbo.rpc.cluster.Configurator):int,108,object returned by `getUrl().getHost()` could be null and is dereferenced at line 108.,https://github.com/apache/dubbo/blob/3.2/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/Configurator.java,"default int compareTo(Configurator o) {
        if (o == null) {
            return -1;
        }

        int ipCompare = getUrl().getHost().compareTo(o.getUrl().getHost());
        // host is the same, sort by priority
        if (ipCompare == 0) {
            int i = getUrl().getParameter(PRIORITY_KEY, 0);
            int j = o.getUrl().getParameter(PRIORITY_KEY, 0);
            return Integer.compare(i, j);
        } else {
            return ipCompare;
        }
    }",0
dubbo-3.2,NULL_DEREFERENCE,dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/migration/MigrationRuleHandler.java,"org.apache.dubbo.registry.client.migration.MigrationRuleHandler.report(org.apache.dubbo.registry.client.migration.model.MigrationStep,org.apache.dubbo.registry.client.migration.model.MigrationStep,java.lang.String):void",107,object `reportService` last assigned on line 105 could be null and is dereferenced at line 107.,"103: private void report(MigrationStep step, MigrationStep originStep, String success) {
 104: FrameworkStatusReportService reportService =
 105: consumerURL.getOrDefaultApplicationModel().getBeanFactory().getBean(FrameworkStatusReportService.class);
 106: 
 107: if (reportService.hasReporter()) {","private void report(MigrationStep step, MigrationStep originStep, String success) {
        FrameworkStatusReportService reportService =
            consumerURL.getOrDefaultApplicationModel().getBeanFactory().getBean(FrameworkStatusReportService.class);

        if (reportService.hasReporter()) {
            reportService.reportMigrationStepStatus(
                reportService.createMigrationStepReport(consumerURL.getServiceInterface(), consumerURL.getVersion(),
                    consumerURL.getGroup(), String.valueOf(originStep), String.valueOf(step), success));
        }
    }",0
dubbo-3.2,NULL_DEREFERENCE,dubbo-xds/src/main/java/org/apache/dubbo/registry/xds/util/PilotExchanger.java,org.apache.dubbo.registry.xds.util.PilotExchanger.lambda$createRouteObserve$4(java.util.Map):void,123,object returned by `PilotExchanger.applicationModel.getFrameworkModel().getBeanFactory().getBean(org.apache.dubbo.common.threadpool.manager.FrameworkExecutorRepository)` could be null and is dereferenced at line 123.,,"private void createRouteObserve() {
        rdsProtocol.observeResource(listenerResult.values().iterator().next().getRouteConfigNames(), (newResult) -> {
            // check if observed domain update ( will update endpoint observation )
            List<String> domainsToUpdate = new LinkedList<>();
            domainObserveConsumer.forEach((domain, consumer) -> {
                newResult.values().forEach(o -> {
                    Set<String> newRoute = o.searchDomain(domain);
                    for (Map.Entry<String, RouteResult> entry : routeResult.entrySet()) {
                        if (!entry.getValue().searchDomain(domain).equals(newRoute)) {
                            // routers in observed domain has been updated
//                    Long domainRequest = domainObserveRequest.get(domain);
                            // router list is empty when observeEndpoints() called and domainRequest has not been created yet
                            // create new observation
                            domainsToUpdate.add(domain);
//                            doObserveEndpoints(domain);
                        }
                    }
                });
            });
            routeResult = newResult;
            ExecutorService executorService = applicationModel.getFrameworkModel().getBeanFactory()
                .getBean(FrameworkExecutorRepository.class).getSharedExecutor();
            executorService.submit(() -> domainsToUpdate.forEach(this::doObserveEndpoints));
        }, false);
    }",0
dubbo-3.2,NULL_DEREFERENCE,dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/filter/AccessLogFilter.java,"org.apache.dubbo.rpc.filter.AccessLogFilter.invoke(org.apache.dubbo.rpc.Invoker,org.apache.dubbo.rpc.Invocation):org.apache.dubbo.rpc.Result",124,object returned by `inv.getModuleModel().getApplicationModel().getFrameworkModel().getBeanFactory().getBean(org.apache.dubbo.common.threadpool.manager.FrameworkExecutorRepository)` could be null and is dereferenced at line 124.,"109: public Result invoke(Invoker<?> invoker, Invocation inv) throws RpcException {
 110: String accessLogKey = invoker.getUrl().getParameter(Constants.ACCESS_LOG_KEY);
 111: boolean isFixedPath = invoker.getUrl().getParameter(ACCESS_LOG_FIXED_PATH_KEY, true);
 112: if (StringUtils.isEmpty(accessLogKey)) {
 113: // Notice that disable accesslog of one service may cause the whole application to stop collecting accesslog.
 114: // It's recommended to use application level configuration to enable or disable accesslog if dynamically configuration is needed .
 115: if (future != null && !future.isCancelled()) {
 116: future.cancel(true);
 117: logger.info(""Access log task cancelled ..."");
 118: }
 119: return invoker.invoke(inv);
 120: }
 121: 
 122: if (scheduled.compareAndSet(false, true)) {
 123: future = inv.getModuleModel().getApplicationModel().getFrameworkModel().getBeanFactory()
 124: .getBean(FrameworkExecutorRepository.class).getSharedScheduledExecutor()
 125: .scheduleWithFixedDelay(new AccesslogRefreshTask(isFixedPath), LOG_OUTPUT_INTERVAL, LOG_OUTPUT_INTERVAL, TimeUnit.MILLISECONDS);
 126: logger.info(""Access log task started ..."");
 127: }
 128: Optional<AccessLogData> optionalAccessLogData = Optional.empty();
 129: try {
 130: optionalAccessLogData = Optional.of(buildAccessLogData(invoker, inv));
 131: } catch (Throwable t) {
 132: logger.warn(CONFIG_FILTER_VALIDATION_EXCEPTION, """", """", ""Exception in AccessLogFilter of service("" + invoker + "" -> "" + inv + "")"", t);
 133: }
 134: try {","public Result invoke(Invoker<?> invoker, Invocation inv) throws RpcException {
        String accessLogKey = invoker.getUrl().getParameter(Constants.ACCESS_LOG_KEY);
        boolean isFixedPath = invoker.getUrl().getParameter(ACCESS_LOG_FIXED_PATH_KEY, true);
        if (StringUtils.isEmpty(accessLogKey)) {
            // Notice that disable accesslog of one service may cause the whole application to stop collecting accesslog.
            // It's recommended to use application level configuration to enable or disable accesslog if dynamically configuration is needed .
            if (future != null && !future.isCancelled()) {
                future.cancel(true);
                logger.info(""Access log task cancelled ..."");
            }
            return invoker.invoke(inv);
        }

        if (scheduled.compareAndSet(false, true)) {
            future = inv.getModuleModel().getApplicationModel().getFrameworkModel().getBeanFactory()
                .getBean(FrameworkExecutorRepository.class).getSharedScheduledExecutor()
                .scheduleWithFixedDelay(new AccesslogRefreshTask(isFixedPath), LOG_OUTPUT_INTERVAL, LOG_OUTPUT_INTERVAL, TimeUnit.MILLISECONDS);
            logger.info(""Access log task started ..."");
        }
        Optional<AccessLogData> optionalAccessLogData = Optional.empty();
        try {
            optionalAccessLogData = Optional.of(buildAccessLogData(invoker, inv));
        } catch (Throwable t) {
            logger.warn(CONFIG_FILTER_VALIDATION_EXCEPTION, """", """", ""Exception in AccessLogFilter of service("" + invoker + "" -> "" + inv + "")"", t);
        }
        try {
            return invoker.invoke(inv);
        } finally {
            String finalAccessLogKey = accessLogKey;
            optionalAccessLogData.ifPresent(logData -> {
                logData.setOutTime(new Date());
                log(finalAccessLogKey, logData, isFixedPath);
            });
        }
    }",0
dubbo-3.2,NULL_DEREFERENCE,dubbo-xds/src/main/java/org/apache/dubbo/registry/xds/util/AdsObserver.java,org.apache.dubbo.registry.xds.util.AdsObserver.triggerReConnectTask():void,111,object returned by `AdsObserver.applicationModel.getFrameworkModel().getBeanFactory().getBean(org.apache.dubbo.common.threadpool.manager.FrameworkExecutorRepository)` could be null and is dereferenced at line 111.,"109: private void triggerReConnectTask() {
 110: ScheduledExecutorService scheduledFuture = applicationModel.getFrameworkModel().getBeanFactory()
 111: .getBean(FrameworkExecutorRepository.class).getSharedScheduledExecutor();
 112: scheduledFuture.schedule(this::recover, 3, TimeUnit.SECONDS);","private void triggerReConnectTask() {
        ScheduledExecutorService scheduledFuture = applicationModel.getFrameworkModel().getBeanFactory()
            .getBean(FrameworkExecutorRepository.class).getSharedScheduledExecutor();
        scheduledFuture.schedule(this::recover, 3, TimeUnit.SECONDS);
    }",0
dubbo-3.2,NULL_DEREFERENCE,dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyServerHandler.java,"org.apache.dubbo.remoting.transport.netty4.NettyServerHandler.userEventTriggered(io.netty.channel.ChannelHandlerContext,java.lang.Object):void",117,object `channel` last assigned on line 114 could be null and is dereferenced at line 117.,"111: public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {
 112: // server will close channel when server don't receive any heartbeat from client util timeout.
 113: if (evt instanceof IdleStateEvent) {
 114: NettyChannel channel = NettyChannel.getOrAddChannel(ctx.channel(), url, handler);
 115: try {
 116: logger.info(""IdleStateEvent triggered, close channel "" + channel);
 117: channel.close();
 118: } finally {
 119: NettyChannel.removeChannelIfDisconnected(ctx.channel());
 120: }
 121: }
 122: super.userEventTriggered(ctx, evt);","public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {
        // server will close channel when server don't receive any heartbeat from client util timeout.
        if (evt instanceof IdleStateEvent) {
            NettyChannel channel = NettyChannel.getOrAddChannel(ctx.channel(), url, handler);
            try {
                logger.info(""IdleStateEvent triggered, close channel "" + channel);
                channel.close();
            } finally {
                NettyChannel.removeChannelIfDisconnected(ctx.channel());
            }
        }
        super.userEventTriggered(ctx, evt);
    }",1
dubbo-3.2,NULL_DEREFERENCE,dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/metadata/MetadataUtils.java,org.apache.dubbo.registry.client.metadata.MetadataUtils.referProxy(org.apache.dubbo.registry.client.ServiceInstance):org.apache.dubbo.registry.client.metadata.MetadataUtils$ProxyHolder,144,object `protocol` last assigned on line 140 could be null and is dereferenced at line 144.,"113: public static ProxyHolder referProxy(ServiceInstance instance) {
 114: MetadataServiceURLBuilder builder;
 115: ExtensionLoader<MetadataServiceURLBuilder> loader = instance.getApplicationModel()
 116: .getExtensionLoader(MetadataServiceURLBuilder.class);
 117: 
 118: Map<String, String> metadata = instance.getMetadata();
 119: // METADATA_SERVICE_URLS_PROPERTY_NAME is a unique key exists only on instances of spring-cloud-alibaba.
 120: String dubboUrlsForJson = metadata.get(METADATA_SERVICE_URLS_PROPERTY_NAME);
 121: if (metadata.isEmpty() || StringUtils.isEmpty(dubboUrlsForJson)) {
 122: builder = loader.getExtension(StandardMetadataServiceURLBuilder.NAME);
 123: } else {
 124: builder = loader.getExtension(SpringCloudMetadataServiceURLBuilder.NAME);
 125: }
 126: 
 127: List<URL> urls = builder.build(instance);
 128: if (CollectionUtils.isEmpty(urls)) {
 129: throw new IllegalStateException(""Introspection service discovery mode is enabled ""
 130: + instance + "", but no metadata service can build from it."");
 131: }
 132: 
 133: URL url = urls.get(0);
 134: 
 135: // Simply rely on the first metadata url, as stated in MetadataServiceURLBuilder.
 136: ApplicationModel applicationModel = instance.getApplicationModel();
 137: ModuleModel internalModel = applicationModel.getInternalModule();
 138: ConsumerModel consumerModel = applicationModel.getInternalModule().registerInternalConsumer(MetadataService.class, url);
 139: 
 140: Protocol protocol = applicationModel.getExtensionLoader(Protocol.class).getExtension(url.getProtocol(), false);
 141: 
 142: url = url.setServiceModel(consumerModel);
 143: 
 144: Invoker<MetadataService> invoker = protocol.refer(MetadataService.class, url);
 145: 
 146: ProxyFactory proxyFactory = applicationModel.getExtensionLoader(ProxyFactory.class).getAdaptiveExtension();
 147: 
 148: MetadataService metadataService = proxyFactory.getProxy(invoker);
 149: 
 150: consumerModel.getServiceMetadata().setTarget(metadataService);
 151: consumerModel.getServiceMetadata().addAttribute(PROXY_CLASS_REF, metadataService);
 152: consumerModel.setProxyObject(metadataService);
 153: consumerModel.initMethodModels();
 154: 
 155: return new ProxyHolder(consumerModel, metadataService, internalModel);","public static ProxyHolder referProxy(ServiceInstance instance) {
        MetadataServiceURLBuilder builder;
        ExtensionLoader<MetadataServiceURLBuilder> loader = instance.getApplicationModel()
            .getExtensionLoader(MetadataServiceURLBuilder.class);

        Map<String, String> metadata = instance.getMetadata();
        // METADATA_SERVICE_URLS_PROPERTY_NAME is a unique key exists only on instances of spring-cloud-alibaba.
        String dubboUrlsForJson = metadata.get(METADATA_SERVICE_URLS_PROPERTY_NAME);
        if (metadata.isEmpty() || StringUtils.isEmpty(dubboUrlsForJson)) {
            builder = loader.getExtension(StandardMetadataServiceURLBuilder.NAME);
        } else {
            builder = loader.getExtension(SpringCloudMetadataServiceURLBuilder.NAME);
        }

        List<URL> urls = builder.build(instance);
        if (CollectionUtils.isEmpty(urls)) {
            throw new IllegalStateException(""Introspection service discovery mode is enabled ""
                + instance + "", but no metadata service can build from it."");
        }

        URL url = urls.get(0);

        // Simply rely on the first metadata url, as stated in MetadataServiceURLBuilder.
        ApplicationModel applicationModel = instance.getApplicationModel();
        ModuleModel internalModel = applicationModel.getInternalModule();
        ConsumerModel consumerModel = applicationModel.getInternalModule().registerInternalConsumer(MetadataService.class, url);

        Protocol protocol = applicationModel.getExtensionLoader(Protocol.class).getExtension(url.getProtocol(), false);

        url = url.setServiceModel(consumerModel);

        Invoker<MetadataService> invoker = protocol.refer(MetadataService.class, url);

        ProxyFactory proxyFactory = applicationModel.getExtensionLoader(ProxyFactory.class).getAdaptiveExtension();

        MetadataService metadataService = proxyFactory.getProxy(invoker);

        consumerModel.getServiceMetadata().setTarget(metadataService);
        consumerModel.getServiceMetadata().addAttribute(PROXY_CLASS_REF, metadataService);
        consumerModel.setProxyObject(metadataService);
        consumerModel.initMethodModels();

        return new ProxyHolder(consumerModel, metadataService, internalModel);
    }",0
dubbo-3.2,NULL_DEREFERENCE,dubbo-native/src/main/java/org/apache/dubbo/aot/generate/ClassSourceScanner.java,org.apache.dubbo.aot.generate.ClassSourceScanner.scopeModelInitializer():java.util.List,121,object returned by `defaultModel().defaultApplication().getDefaultModule().getBeanFactory()` could be null and is dereferenced at line 121.,"117: public List<Class<?>> scopeModelInitializer(){
 118: List<Class<?>> classes = new ArrayList<>();
 119: classes.addAll(FrameworkModel.defaultModel().getBeanFactory().getRegisteredClasses());
 120: classes.addAll(FrameworkModel.defaultModel().defaultApplication().getBeanFactory().getRegisteredClasses());
 121: classes.addAll(FrameworkModel.defaultModel().defaultApplication().getDefaultModule().getBeanFactory().getRegisteredClasses());
 122: return classes.stream().distinct().collect(Collectors.toList());","public  List<Class<?>> scopeModelInitializer(){
        List<Class<?>> classes = new ArrayList<>();
        classes.addAll(FrameworkModel.defaultModel().getBeanFactory().getRegisteredClasses());
        classes.addAll(FrameworkModel.defaultModel().defaultApplication().getBeanFactory().getRegisteredClasses());
        classes.addAll(FrameworkModel.defaultModel().defaultApplication().getDefaultModule().getBeanFactory().getRegisteredClasses());
        return classes.stream().distinct().collect(Collectors.toList());
    }",0
dubbo-3.2,NULL_DEREFERENCE,dubbo-remoting/dubbo-remoting-http/src/main/java/org/apache/dubbo/remoting/http/restclient/OKHttpRestClient.java,org.apache.dubbo.remoting.http.restclient.OKHttpRestClient$1$1.getMessage():java.lang.String,120,object returned by `getBody()` could be null and is dereferenced by call to `String(...)` at line 120.,"51: public CompletableFuture<RestResult> send(RequestTemplate requestTemplate) {
 52: 
 53: Request.Builder builder = new Request.Builder();
 54: // url
 55: builder.url(requestTemplate.getURL());
 56: 
 57: Map<String, Collection<String>> allHeaders = requestTemplate.getAllHeaders();
 58: 
 59: boolean hasBody = false;
 60: RequestBody requestBody = null;
 61: // GET & HEAD body is forbidden
 62: if (HttpMethod.permitsRequestBody(requestTemplate.getHttpMethod())) {
 63: requestBody = RequestBody.create(null, requestTemplate.getSerializedBody());
 64: hasBody = true;
 65: }
 66: 
 67: // header
 68: for (String headerName : allHeaders.keySet()) {
 69: Collection<String> headerValues = allHeaders.get(headerName);
 70: if (!hasBody && ""Content-Length"".equals(headerName)) {
 71: continue;
 72: }
 73: for (String headerValue : headerValues) {
 74: 
 75: builder.addHeader(headerName, headerValue);
 76: }
 77: }
 78: 
 79: builder.method(requestTemplate.getHttpMethod(), requestBody);
 80: 
 81: CompletableFuture<RestResult> future = new CompletableFuture<>();
 82: 
 83: okHttpClient.newCall(builder.build()).enqueue(new Callback() {
 84: @Override
 85: public void onFailure(Call call, IOException e) {
 86: future.completeExceptionally(e);
 87: }
 88: 
 89: @Override
 90: public void onResponse(Call call, Response response) throws IOException {
 91: future.complete(new RestResult() {
 92: @Override
 93: public String getContentType() {
 94: return response.header(""Content-Type"");
 95: }
 96: 
 97: @Override
 98: public byte[] getBody() throws IOException {
 99: ResponseBody body = response.body();
 100: return body == null ? null : body.bytes();
 101: }
 102: 
 103: @Override
 104: public Map<String, List<String>> headers() {
 105: return response.headers().toMultimap();
 106: }
 107: 
 108: @Override
 109: public byte[] getErrorResponse() throws IOException {
 110: return getBody();
 111: }
 112: 
 113: @Override
 114: public int getResponseCode() throws IOException {
 115: return response.code();
 116: }
 117: 
 118: @Override
 119: public String getMessage() throws IOException {
 120: return appendErrorMessage(response.message(), new String(getBody()));
 121: }
 122: });
 123: }
 124: });
 125: 
 126: return future;","public CompletableFuture<RestResult> send(RequestTemplate requestTemplate) {

        Request.Builder builder = new Request.Builder();
        // url
        builder.url(requestTemplate.getURL());

        Map<String, Collection<String>> allHeaders = requestTemplate.getAllHeaders();

        boolean hasBody = false;
        RequestBody requestBody = null;
        // GET & HEAD body is forbidden
        if (HttpMethod.permitsRequestBody(requestTemplate.getHttpMethod())) {
            requestBody = RequestBody.create(null, requestTemplate.getSerializedBody());
            hasBody = true;
        }

        // header
        for (String headerName : allHeaders.keySet()) {
            Collection<String> headerValues = allHeaders.get(headerName);
            if (!hasBody && ""Content-Length"".equals(headerName)) {
                continue;
            }
            for (String headerValue : headerValues) {

                builder.addHeader(headerName, headerValue);
            }
        }

        builder.method(requestTemplate.getHttpMethod(), requestBody);

        CompletableFuture<RestResult> future = new CompletableFuture<>();

        okHttpClient.newCall(builder.build()).enqueue(new Callback() {
            @Override
            public void onFailure(Call call, IOException e) {
                future.completeExceptionally(e);
            }

            @Override
            public void onResponse(Call call, Response response) throws IOException {
                future.complete(new RestResult() {
                    @Override
                    public String getContentType() {
                        return response.header(""Content-Type"");
                    }

                    @Override
                    public byte[] getBody() throws IOException {
                        ResponseBody body = response.body();
                        return body == null ? null : body.bytes();
                    }

                    @Override
                    public Map<String, List<String>> headers() {
                        return response.headers().toMultimap();
                    }

                    @Override
                    public byte[] getErrorResponse() throws IOException {
                        return getBody();
                    }

                    @Override
                    public int getResponseCode() throws IOException {
                        return response.code();
                    }

                    @Override
                    public String getMessage() throws IOException {
                        return appendErrorMessage(response.message(), new String(getBody()));
                    }
                });
            }
        });

        return future;
    }",1
dubbo-3.2,NULL_DEREFERENCE,dubbo-plugin/dubbo-security/src/main/java/org/apache/dubbo/security/cert/DubboCertManager.java,org.apache.dubbo.security.cert.DubboCertManager.scheduleRefresh():void,122,object `repository` last assigned on line 121 could be null and is dereferenced at line 122.,"120: protected void scheduleRefresh() {
 121: FrameworkExecutorRepository repository = frameworkModel.getBeanFactory().getBean(FrameworkExecutorRepository.class);
 122: refreshFuture = repository.getSharedScheduledExecutor().scheduleAtFixedRate(this::generateCert,","protected void scheduleRefresh() {
        FrameworkExecutorRepository repository = frameworkModel.getBeanFactory().getBean(FrameworkExecutorRepository.class);
        refreshFuture = repository.getSharedScheduledExecutor().scheduleAtFixedRate(this::generateCert,
            certConfig.getRefreshInterval(), certConfig.getRefreshInterval(), TimeUnit.MILLISECONDS);
    }",0
dubbo-3.2,NULL_DEREFERENCE,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleInvoker.java,org.apache.dubbo.rpc.protocol.tri.TripleInvoker.doInvoke(org.apache.dubbo.rpc.Invocation):org.apache.dubbo.rpc.Result,132,object `consumerModel` last assigned on line 131 could be null and is dereferenced at line 132.,"120: protected Result doInvoke(final Invocation invocation) {
 121: if (!connectionClient.isConnected()) {
 122: CompletableFuture<AppResponse> future = new CompletableFuture<>();
 123: RpcException exception = TriRpcStatus.UNAVAILABLE.withDescription(
 124: String.format(""upstream %s is unavailable"", getUrl().getAddress()))
 125: .asException();
 126: future.completeExceptionally(exception);
 127: return new AsyncRpcResult(future, invocation);
 128: }
 129: 
 130: ConsumerModel consumerModel = (ConsumerModel) (invocation.getServiceModel() != null
 131: ? invocation.getServiceModel() : getUrl().getServiceModel());
 132: ServiceDescriptor serviceDescriptor = consumerModel.getServiceModel();
 133: final MethodDescriptor methodDescriptor = serviceDescriptor.getMethod(
 134: invocation.getMethodName(),
 135: invocation.getParameterTypes());
 136: Executor callbackExecutor = isSync(methodDescriptor, invocation) ? new ThreadlessExecutor() : streamExecutor;
 137: ClientCall call = new TripleClientCall(connectionClient, callbackExecutor,
 138: getUrl().getOrDefaultFrameworkModel(), writeQueue);
 139: AsyncRpcResult result;
 140: try {","protected Result doInvoke(final Invocation invocation) {
        if (!connectionClient.isConnected()) {
            CompletableFuture<AppResponse> future = new CompletableFuture<>();
            RpcException exception = TriRpcStatus.UNAVAILABLE.withDescription(
                    String.format(""upstream %s is unavailable"", getUrl().getAddress()))
                .asException();
            future.completeExceptionally(exception);
            return new AsyncRpcResult(future, invocation);
        }",1
dubbo-3.2,NULL_DEREFERENCE,dubbo-common/src/main/java/org/apache/dubbo/common/url/component/URLParam.java,"org.apache.dubbo.common.url.component.URLParam.<init>(java.util.BitSet,java.util.HashMap,java.util.HashMap,java.util.HashMap,java.lang.String)",126,object returned by `value.get(valueOf(i))` could be null and is dereferenced at line 126.,https://github.com/apache/dubbo/blob/3.2/dubbo-common/src/main/java/org/apache/dubbo/common/url/component/URLParam.java,"protected URLParam(BitSet key, Map<Integer, Integer> value, Map<String, String> extraParams, Map<String, Map<String, String>> methodParameters, String rawParam) {
        this.KEY = key;
        this.VALUE = new int[value.size()];
        for (int i = key.nextSetBit(0), offset = 0; i >= 0; i = key.nextSetBit(i + 1)) {
            if (value.containsKey(i)) {
                VALUE[offset++] = value.get(i);
            } else {
                throw new IllegalArgumentException();
            }
        }
        this.EXTRA_PARAMS = Collections.unmodifiableMap((extraParams == null ? new HashMap<>() : new HashMap<>(extraParams)));
        this.METHOD_PARAMETERS = Collections.unmodifiableMap((methodParameters == null) ? Collections.emptyMap() : new LinkedHashMap<>(methodParameters));
        this.rawParam = rawParam;

        this.timestamp = System.currentTimeMillis();
        this.enableCompressed = true;
    }",0
dubbo-3.2,NULL_DEREFERENCE,dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/DecodeableRpcInvocation.java,"org.apache.dubbo.rpc.protocol.dubbo.DecodeableRpcInvocation.decode(org.apache.dubbo.remoting.Channel,java.io.InputStream):java.lang.Object",158,object `desc` last assigned on line 145 could be null and is dereferenced at line 158.,"122: public Object decode(Channel channel, InputStream input) throws IOException {
 123: int contentLength = input.available();
 124: getAttributes().put(Constants.CONTENT_LENGTH_KEY, contentLength);
 125: 
 126: ObjectInput in = CodecSupport.getSerialization(serializationType)
 127: .deserialize(channel.getUrl(), input);
 128: this.put(SERIALIZATION_ID_KEY, serializationType);
 129: 
 130: String dubboVersion = in.readUTF();
 131: request.setVersion(dubboVersion);
 132: setAttachment(DUBBO_VERSION_KEY, dubboVersion);
 133: 
 134: String path = in.readUTF();
 135: setAttachment(PATH_KEY, path);
 136: String version = in.readUTF();
 137: setAttachment(VERSION_KEY, version);
 138: 
 139: // Do provider-level payload checks.
 140: String keyWithoutGroup = keyWithoutGroup(path, version);
 141: checkPayload(keyWithoutGroup);
 142: 
 143: setMethodName(in.readUTF());
 144: 
 145: String desc = in.readUTF();
 146: setParameterTypesDesc(desc);
 147: 
 148: ClassLoader originClassLoader = Thread.currentThread().getContextClassLoader();
 149: try {
 150: if (CHECK_SERIALIZATION) {
 151: PermittedSerializationKeeper keeper = frameworkModel.getBeanFactory().getBean(PermittedSerializationKeeper.class);
 152: if (!keeper.checkSerializationPermitted(keyWithoutGroup, serializationType)) {
 153: throw new IOException(""Unexpected serialization id:"" + serializationType + "" received from network, please check if the peer send the right id."");
 154: }
 155: }
 156: Object[] args = DubboCodec.EMPTY_OBJECT_ARRAY;
 157: Class<?>[] pts = DubboCodec.EMPTY_CLASS_ARRAY;
 158: if (desc.length() > 0) {
 159: pts = drawPts(path, version, desc, pts);
 160: if (pts == DubboCodec.EMPTY_CLASS_ARRAY) {
 161: if (!RpcUtils.isGenericCall(desc, getMethodName()) && !RpcUtils.isEcho(desc, getMethodName())) {
 162: throw new IllegalArgumentException(""Service not found:"" + path + "", "" + getMethodName());
 163: }
 164: pts = ReflectUtils.desc2classArray(desc);
 165: }
 166: args = drawArgs(in, pts);
 167: }
 168: setParameterTypes(pts);
 169: 
 170: Map<String, Object> map = in.readAttachments();
 171: if (CollectionUtils.isNotEmptyMap(map)) {
 172: addObjectAttachments(map);
 173: }
 174: 
 175: decodeArgument(channel, pts, args);
 176: } catch (ClassNotFoundException e) {
 177: throw new IOException(StringUtils.toString(""Read invocation data failed."", e));
 178: } finally {
 179: Thread.currentThread().setContextClassLoader(originClassLoader);
 180: if (in instanceof Cleanable) {
 181: ((Cleanable) in).cleanup();
 182: }
 183: }
 184: return this;","public Object decode(Channel channel, InputStream input) throws IOException {
        int contentLength = input.available();
        getAttributes().put(Constants.CONTENT_LENGTH_KEY, contentLength);

        ObjectInput in = CodecSupport.getSerialization(serializationType)
            .deserialize(channel.getUrl(), input);
        this.put(SERIALIZATION_ID_KEY, serializationType);

        String dubboVersion = in.readUTF();
        request.setVersion(dubboVersion);
        setAttachment(DUBBO_VERSION_KEY, dubboVersion);

        String path = in.readUTF();
        setAttachment(PATH_KEY, path);
        String version = in.readUTF();
        setAttachment(VERSION_KEY, version);

        // Do provider-level payload checks.
        String keyWithoutGroup = keyWithoutGroup(path, version);
        checkPayload(keyWithoutGroup);

        setMethodName(in.readUTF());

        String desc = in.readUTF();
        setParameterTypesDesc(desc);

        ClassLoader originClassLoader = Thread.currentThread().getContextClassLoader();
        try {
            if (CHECK_SERIALIZATION) {
                PermittedSerializationKeeper keeper = frameworkModel.getBeanFactory().getBean(PermittedSerializationKeeper.class);
                if (!keeper.checkSerializationPermitted(keyWithoutGroup, serializationType)) {
                    throw new IOException(""Unexpected serialization id:"" + serializationType + "" received from network, please check if the peer send the right id."");
                }
            }
            Object[] args = DubboCodec.EMPTY_OBJECT_ARRAY;
            Class<?>[] pts = DubboCodec.EMPTY_CLASS_ARRAY;
            if (desc.length() > 0) {
                pts = drawPts(path, version, desc, pts);
                if (pts == DubboCodec.EMPTY_CLASS_ARRAY) {
                    if (RpcUtils.isGenericCall(desc, getMethodName())) {
                        pts = DubboCodec.GENERIC_PTS_ARRAY;
                    } else if (RpcUtils.isEcho(desc, getMethodName())) {
                        pts = DubboCodec.ECHO_PTS_ARRAY;
                    } else {
                        throw new IllegalArgumentException(""Service not found:"" + path + "", "" + getMethodName());
                    }
                }
                args = drawArgs(in, pts);
            }
            setParameterTypes(pts);

            Map<String, Object> map = in.readAttachments();
            if (CollectionUtils.isNotEmptyMap(map)) {
                addObjectAttachments(map);
            }

            decodeArgument(channel, pts, args);
        } catch (ClassNotFoundException e) {
            throw new IOException(StringUtils.toString(""Read invocation data failed."", e));
        } finally {
            Thread.currentThread().setContextClassLoader(originClassLoader);
            if (in instanceof Cleanable) {
                ((Cleanable) in).cleanup();
            }
        }
        return this;
    }",0
dubbo-3.2,NULL_DEREFERENCE,dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/ServiceDiscoveryRegistry.java,org.apache.dubbo.registry.client.ServiceDiscoveryRegistry.getServiceDiscovery(org.apache.dubbo.common.URL):org.apache.dubbo.registry.client.ServiceDiscovery,125,object `factory` last assigned on line 124 could be null and is dereferenced at line 125.,"123: private ServiceDiscovery getServiceDiscovery(URL registryURL) {
 124: ServiceDiscoveryFactory factory = getExtension(registryURL);
 125: return factory.getServiceDiscovery(registryURL);","private ServiceDiscovery getServiceDiscovery(URL registryURL) {
        ServiceDiscoveryFactory factory = getExtension(registryURL);
        return factory.getServiceDiscovery(registryURL);
    }",1
dubbo-3.2,NULL_DEREFERENCE,dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/bootstrap/builders/InternalServiceConfigBuilder.java,org.apache.dubbo.config.bootstrap.builders.InternalServiceConfigBuilder.lambda$getRelatedOrDefaultProtocol$2(org.apache.dubbo.config.ProviderConfig):java.lang.String,140,object returned by `providerConfig.getProtocols()` could be null and is dereferenced at line 140.,"113: private String getRelatedOrDefaultProtocol() {
 114: String protocol = """";
 115: // <dubbo:consumer/>
 116: List<ModuleModel> moduleModels = applicationModel.getPubModuleModels();
 117: protocol = moduleModels.stream()
 118: .map(ModuleModel::getConfigManager)
 119: .map(ModuleConfigManager::getConsumers)
 120: .filter(CollectionUtils::isNotEmpty)
 121: .flatMap(Collection::stream)
 122: .map(ConsumerConfig::getProtocol)
 123: .filter(StringUtils::isNotEmpty)
 124: .filter(p -> !UNACCEPTABLE_PROTOCOL.contains(p))
 125: .findFirst()
 126: .orElse("""");
 127: // <dubbo:provider/>
 128: if (StringUtils.isEmpty(protocol)) {
 129: Stream<ProviderConfig> providerConfigStream = moduleModels.stream()
 130: .map(ModuleModel::getConfigManager)
 131: .map(ModuleConfigManager::getProviders)
 132: .filter(CollectionUtils::isNotEmpty)
 133: .flatMap(Collection::stream);
 134: protocol = providerConfigStream
 135: .filter((providerConfig) -> providerConfig.getProtocol() != null || CollectionUtils.isNotEmpty(providerConfig.getProtocols()))
 136: .map(providerConfig -> {
 137: if (providerConfig.getProtocol() != null && StringUtils.isNotEmpty(providerConfig.getProtocol().getName())) {
 138: return providerConfig.getProtocol().getName();
 139: } else {
 140: return providerConfig.getProtocols().stream()
 141: .map(ProtocolConfig::getName)
 142: .filter(StringUtils::isNotEmpty)
 143: .findFirst()
 144: .orElse("""");
 145: }
 146: })
 147: .filter(StringUtils::isNotEmpty)
 148: .filter(p -> !UNACCEPTABLE_PROTOCOL.contains(p))
 149: .findFirst()
 150: .orElse("""");
 151: }
 152: // <dubbo:protocol/>
 153: if (StringUtils.isEmpty(protocol)) {
 154: Collection<ProtocolConfig> protocols = applicationModel.getApplicationConfigManager().getProtocols();
 155: if (CollectionUtils.isNotEmpty(protocols)) {
 156: protocol = protocols.stream()
 157: .map(ProtocolConfig::getName)
 158: .filter(StringUtils::isNotEmpty)
 159: .filter(p -> !UNACCEPTABLE_PROTOCOL.contains(p))
 160: .findFirst()
 161: .orElse("""");
 162: }
 163: }
 164: // <dubbo:application/>
 165: if (StringUtils.isEmpty(protocol)) {
 166: protocol = getApplicationConfig().getProtocol();
 167: if (StringUtils.isEmpty(protocol)) {
 168: Map<String, String> params = getApplicationConfig().getParameters();
 169: if (CollectionUtils.isNotEmptyMap(params)) {
 170: protocol = params.get(APPLICATION_PROTOCOL_KEY);
 171: }
 172: }
 173: }
 174: return StringUtils.isNotEmpty(protocol) && !UNACCEPTABLE_PROTOCOL.contains(protocol) ? protocol : DUBBO_PROTOCOL;","private String getRelatedOrDefaultProtocol() {
        String protocol = """";
        // <dubbo:consumer/>
        List<ModuleModel> moduleModels = applicationModel.getPubModuleModels();
        protocol = moduleModels.stream()
            .map(ModuleModel::getConfigManager)
            .map(ModuleConfigManager::getConsumers)
            .filter(CollectionUtils::isNotEmpty)
            .flatMap(Collection::stream)
            .map(ConsumerConfig::getProtocol)
            .filter(StringUtils::isNotEmpty)
            .filter(p -> !UNACCEPTABLE_PROTOCOL.contains(p))
            .findFirst()
            .orElse("""");
        // <dubbo:provider/>
        if (StringUtils.isEmpty(protocol)) {
            Stream<ProviderConfig> providerConfigStream = moduleModels.stream()
                .map(ModuleModel::getConfigManager)
                .map(ModuleConfigManager::getProviders)
                .filter(CollectionUtils::isNotEmpty)
                .flatMap(Collection::stream);
            protocol = providerConfigStream
                .filter((providerConfig) -> providerConfig.getProtocol() != null || CollectionUtils.isNotEmpty(providerConfig.getProtocols()))
                .map(providerConfig -> {
                    if (providerConfig.getProtocol() != null && StringUtils.isNotEmpty(providerConfig.getProtocol().getName())) {
                        return providerConfig.getProtocol().getName();
                    } else {
                        return providerConfig.getProtocols().stream()
                            .map(ProtocolConfig::getName)
                            .filter(StringUtils::isNotEmpty)
                            .findFirst()
                            .orElse("""");
                    }
                })
                .filter(StringUtils::isNotEmpty)
                .filter(p -> !UNACCEPTABLE_PROTOCOL.contains(p))
                .findFirst()
                .orElse("""");
        }
        // <dubbo:protocol/>
        if (StringUtils.isEmpty(protocol)) {
            Collection<ProtocolConfig> protocols = applicationModel.getApplicationConfigManager().getProtocols();
            if (CollectionUtils.isNotEmpty(protocols)) {
                protocol = protocols.stream()
                    .map(ProtocolConfig::getName)
                    .filter(StringUtils::isNotEmpty)
                    .filter(p -> !UNACCEPTABLE_PROTOCOL.contains(p))
                    .findFirst()
                    .orElse("""");
            }
        }
        // <dubbo:application/>
        if (StringUtils.isEmpty(protocol)) {
            protocol = getApplicationConfig().getProtocol();
            if (StringUtils.isEmpty(protocol)) {
                Map<String, String> params = getApplicationConfig().getParameters();
                if (CollectionUtils.isNotEmptyMap(params)) {
                    protocol = params.get(APPLICATION_PROTOCOL_KEY);
                }
            }
        }
        return StringUtils.isNotEmpty(protocol) && !UNACCEPTABLE_PROTOCOL.contains(protocol) ? protocol : DUBBO_PROTOCOL;
    }",0
dubbo-3.2,NULL_DEREFERENCE,dubbo-common/src/main/java/org/apache/dubbo/common/config/ConfigurationUtils.java,"org.apache.dubbo.common.config.ConfigurationUtils.getCachedDynamicProperty(org.apache.dubbo.rpc.model.ApplicationModel,java.lang.String,java.lang.String):java.lang.String",142,object `configurationCache` last assigned on line 141 could be null and is dereferenced at line 142.,"139: public static String getCachedDynamicProperty(ScopeModel realScopeModel, String key, String defaultValue) {
 140: ScopeModel scopeModel = getScopeModelOrDefaultApplicationModel(realScopeModel);
 141: ConfigurationCache configurationCache = scopeModel.getBeanFactory().getBean(ConfigurationCache.class);
 142: String value = configurationCache.computeIfAbsent(key, _k -> ConfigurationUtils.getDynamicProperty(scopeModel, _k, """"));
 143: return StringUtils.isEmpty(value) ? defaultValue : value;","public static int getServerShutdownTimeout(ScopeModel scopeModel) {
        if (expectedShutdownTime < System.currentTimeMillis()) {
            return 1;
        }
        int timeout = DEFAULT_SERVER_SHUTDOWN_TIMEOUT;
        Configuration configuration = getGlobalConfiguration(scopeModel);
        String value = StringUtils.trim(configuration.getString(SHUTDOWN_WAIT_KEY));

        if (StringUtils.isNotEmpty(value)) {
            try {
                timeout = Integer.parseInt(value);
            } catch (Exception e) {
                // ignore
            }
        } else {
            value = StringUtils.trim(configuration.getString(SHUTDOWN_WAIT_SECONDS_KEY));
            if (StringUtils.isNotEmpty(value)) {
                try {
                    timeout = Integer.parseInt(value) * 1000;
                } catch (Exception e) {
                    // ignore
                }
            }
        }

        if (expectedShutdownTime - System.currentTimeMillis() < timeout) {
            return (int) Math.max(1, expectedShutdownTime - System.currentTimeMillis());
        }

        return timeout;
    }
",0
dubbo-3.2,NULL_DEREFERENCE,dubbo-common/src/main/java/org/apache/dubbo/common/utils/LFUCache.java,org.apache.dubbo.common.utils.LFUCache.proceedEviction():int,148,object `node` last assigned on line 147 could be null and is dereferenced at line 148.,"139: private int proceedEviction() {
 140: int targetSize = capacity - evictionCount;
 141: int evictedElements = 0;
 142: 
 143: FREQ_TABLE_ITER_LOOP:
 144: for (int i = 0; i <= capacity; i++) {
 145: CacheNode<K, V> node;
 146: while (!freqTable[i].isEmpty()) {
 147: node = freqTable[i].pollFirst();
 148: remove(node.key);
 149: if (targetSize >= curSize) {
 150: break FREQ_TABLE_ITER_LOOP;
 151: }
 152: evictedElements++;
 153: }
 154: }
 155: return evictedElements;","private int proceedEviction() {
        int targetSize = capacity - evictionCount;
        int evictedElements = 0;

        FREQ_TABLE_ITER_LOOP:
        for (int i = 0; i <= capacity; i++) {
            CacheNode<K, V> node;
            while (!freqTable[i].isEmpty()) {
                node = freqTable[i].pollFirst();
                remove(node.key);
                if (targetSize >= curSize) {
                    break FREQ_TABLE_ITER_LOOP;
                }
                evictedElements++;
            }
        }
        return evictedElements;
    }",0
dubbo-3.2,NULL_DEREFERENCE,dubbo-registry/dubbo-registry-nacos/src/main/java/org/apache/dubbo/registry/nacos/NacosServiceDiscovery.java,org.apache.dubbo.registry.nacos.NacosServiceDiscovery.lambda$getServices$3(org.apache.dubbo.registry.nacos.NacosNamingServiceWrapper):java.util.LinkedHashSet,141,object `view` last assigned on line 140 could be null and is dereferenced at line 141.,https://github.com/apache/dubbo/blob/3.2/dubbo-registry/dubbo-registry-nacos/src/main/java/org/apache/dubbo/registry/nacos/NacosServiceDiscovery.java,"public Set<String> getServices() {
        return ThrowableFunction.execute(namingService, service -> {
            ListView<String> view = service.getServicesOfServer(0, Integer.MAX_VALUE, group);
            return new LinkedHashSet<>(view.getData());
        });
    }",0
dubbo-3.2,NULL_DEREFERENCE,dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/filter/GenericImplFilter.java,"org.apache.dubbo.rpc.filter.GenericImplFilter.onResponse(org.apache.dubbo.rpc.Result,org.apache.dubbo.rpc.Invoker,org.apache.dubbo.rpc.Invocation):void",185,object `classChecker` last assigned on line 184 could be null and is dereferenced at line 185.,https://github.com/apache/dubbo/blob/3.2/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/filter/GenericImplFilter.java,"public void onResponse(Result appResponse, Invoker<?> invoker, Invocation invocation) {
        String generic = invoker.getUrl().getParameter(GENERIC_KEY);
        String methodName = invocation.getMethodName();
        Class<?>[] parameterTypes = invocation.getParameterTypes();
        Object genericImplMarker = invocation.get(GENERIC_IMPL_MARKER);
        if (genericImplMarker != null && (boolean) invocation.get(GENERIC_IMPL_MARKER)) {
            if (!appResponse.hasException()) {
                Object value = appResponse.getValue();
                try {
                    Class<?> invokerInterface = invoker.getInterface();
                    if (!$INVOKE.equals(methodName) && !$INVOKE_ASYNC.equals(methodName)
                        && invokerInterface.isAssignableFrom(GenericService.class)) {
                        try {
                            // find the real interface from url
                            String realInterface = invoker.getUrl().getParameter(Constants.INTERFACE);
                            invokerInterface = ReflectUtils.forName(realInterface);
                        } catch (Exception e) {
                            // ignore
                        }
                    }

                    Method method = invokerInterface.getMethod(methodName, parameterTypes);
                    if (ProtocolUtils.isBeanGenericSerialization(generic)) {
                        if (value == null) {
                            appResponse.setValue(value);
                        } else if (value instanceof JavaBeanDescriptor) {
                            appResponse.setValue(JavaBeanSerializeUtil.deserialize((JavaBeanDescriptor) value));
                        } else {
                            throw new RpcException(""The type of result value is "" + value.getClass().getName() + "" other than "" + JavaBeanDescriptor.class.getName() + "", and the result is "" + value);
                        }
                    } else {
                        Type[] types = ReflectUtils.getReturnTypes(method);
                        appResponse.setValue(PojoUtils.realize(value, (Class<?>) types[0], types[1]));
                    }
                } catch (NoSuchMethodException e) {
                    throw new RpcException(e.getMessage(), e);
                }
            } else if (appResponse.getException() instanceof com.alibaba.dubbo.rpc.service.GenericException) {
                com.alibaba.dubbo.rpc.service.GenericException exception = (com.alibaba.dubbo.rpc.service.GenericException) appResponse.getException();
                try {
                    String className = exception.getExceptionClass();
                    DefaultSerializeClassChecker classChecker = moduleModel.getApplicationModel()
                        .getFrameworkModel().getBeanFactory().getBean(DefaultSerializeClassChecker.class);
                    Class<?> clazz = classChecker.loadClass(Thread.currentThread().getContextClassLoader(), className);
                    Throwable targetException = null;
                    Throwable lastException = null;
                    try {
                        targetException = (Throwable) clazz.getDeclaredConstructor().newInstance();
                    } catch (Throwable e) {
                        lastException = e;
                        for (Constructor<?> constructor : clazz.getConstructors()) {
                            try {
                                targetException = (Throwable) constructor.newInstance(new Object[constructor.getParameterTypes().length]);
                                break;
                            } catch (Throwable e1) {
                                lastException = e1;
                            }
                        }
                    }
                    if (targetException != null) {
                        try {
                            Field field = Throwable.class.getDeclaredField(""detailMessage"");
                            if (!field.isAccessible()) {
                                field.setAccessible(true);
                            }
                            field.set(targetException, exception.getExceptionMessage());
                        } catch (Throwable e) {
                            logger.warn(COMMON_REFLECTIVE_OPERATION_FAILED, """", """", e.getMessage(), e);
                        }
                        appResponse.setException(targetException);
                    } else if (lastException != null) {
                        throw lastException;
                    }
                } catch (Throwable e) {
                    throw new RpcException(""Can not deserialize exception "" + exception.getExceptionClass() + "", message: "" + exception.getExceptionMessage(), e);
                }
            }
        }
    }",0
dubbo-3.2,NULL_DEREFERENCE,dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/protocol/QosProtocolWrapper.java,org.apache.dubbo.qos.protocol.QosProtocolWrapper.stopServer():void,146,object `server` last assigned on line 145 could be null and is dereferenced at line 146.,https://github.com/apache/dubbo/blob/3.2/dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/protocol/QosProtocolWrapper.java,"private void startQosServer(URL url) {
        try {
            if (!hasStarted.compareAndSet(false, true)) {
                return;
            }

            boolean qosEnable = url.getParameter(QOS_ENABLE, true);
            if (!qosEnable) {
                logger.info(""qos won't be started because it is disabled. "" +
                    ""Please check dubbo.application.qos.enable is configured either in system property, "" +
                    ""dubbo.properties or XML/spring-boot configuration."");
                return;
            }

            String host = url.getParameter(QOS_HOST);
            int port = url.getParameter(QOS_PORT, QosConstants.DEFAULT_PORT);
            boolean acceptForeignIp = Boolean.parseBoolean(url.getParameter(ACCEPT_FOREIGN_IP, ""false""));
            String acceptForeignIpWhitelist = url.getParameter(ACCEPT_FOREIGN_IP_WHITELIST, StringUtils.EMPTY_STRING);
            String anonymousAccessPermissionLevel = url.getParameter(ANONYMOUS_ACCESS_PERMISSION_LEVEL, PermissionLevel.PUBLIC.name());
            String anonymousAllowCommands = url.getParameter(ANONYMOUS_ACCESS_ALLOW_COMMANDS, StringUtils.EMPTY_STRING);
            Server server = frameworkModel.getBeanFactory().getBean(Server.class);

            if (server.isStarted()) {
                return;
            }

            server.setHost(host);
            server.setPort(port);
            server.setAcceptForeignIp(acceptForeignIp);
            server.setAcceptForeignIpWhitelist(acceptForeignIpWhitelist);
            server.setAnonymousAccessPermissionLevel(anonymousAccessPermissionLevel);
            server.setAnonymousAllowCommands(anonymousAllowCommands);
            server.start();

        } catch (Throwable throwable) {
            logger.warn(QOS_FAILED_START_SERVER, """", """", ""Fail to start qos server: "", throwable);
            boolean qosCheck = url.getParameter(QOS_CHECK, false);
            if (qosCheck) {
                throw new IllegalStateException(""Fail to start qos server: "" + throwable.getMessage(), throwable);
            }
        }
    }

    /*package*/ void stopServer() {
        if (hasStarted.compareAndSet(true, false)) {
            Server server = frameworkModel.getBeanFactory().getBean(Server.class);
            server.stop();
        }
    }",0
dubbo-3.2,NULL_DEREFERENCE,dubbo-metadata/dubbo-metadata-processor/src/main/java/org/apache/dubbo/metadata/annotation/processing/rest/DefaultServiceRestMetadataResolver.java,org.apache.dubbo.metadata.annotation.processing.rest.DefaultServiceRestMetadataResolver.supportsPathVariableType(javax.lang.model.type.TypeMirror):boolean,150,object returned by `defaultModel().getBeanFactory().getBean(org.apache.dubbo.common.convert.ConverterUtil)` could be null and is dereferenced at line 150.,"144: private boolean supportsPathVariableType(TypeMirror parameterType) {
 145: String className = parameterType.toString();
 146: ClassLoader classLoader = getClass().getClassLoader();
 147: boolean supported;
 148: try {
 149: Class<?> targetType = forName(className, classLoader);
 150: supported = FrameworkModel.defaultModel().getBeanFactory().getBean(ConverterUtil.class).getConverter(String.class, targetType) != null;
 151: } catch (ClassNotFoundException e) {
 152: supported = false;
 153: }
 154: return supported;","private boolean supportsPathVariableType(TypeMirror parameterType) {
        String className = parameterType.toString();
        ClassLoader classLoader = getClass().getClassLoader();
        boolean supported;
        try {
            Class<?> targetType = forName(className, classLoader);
            supported = FrameworkModel.defaultModel().getBeanFactory().getBean(ConverterUtil.class).getConverter(String.class, targetType) != null;
        } catch (ClassNotFoundException e) {
            supported = false;
        }
        return supported;
    }",0
dubbo-3.2,NULL_DEREFERENCE,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/directory/AbstractDirectory.java,"org.apache.dubbo.rpc.cluster.directory.AbstractDirectory.<init>(org.apache.dubbo.common.URL,org.apache.dubbo.rpc.cluster.RouterChain,boolean)",163,object returned by `AbstractDirectory.applicationModel.getBeanFactory().getBean(org.apache.dubbo.rpc.cluster.support.ClusterUtils)` could be null and is dereferenced at line 163.,https://github.com/apache/dubbo/blob/3.2/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/directory/AbstractDirectory.java,"public AbstractDirectory(URL url, RouterChain<T> routerChain, boolean isUrlFromRegistry) {
        if (url == null) {
            throw new IllegalArgumentException(""url == null"");
        }

        this.url = url.removeAttribute(REFER_KEY).removeAttribute(MONITOR_KEY);

        Map<String, String> queryMap;
        Object referParams = url.getAttribute(REFER_KEY);
        if (referParams instanceof Map) {
            queryMap = (Map<String, String>) referParams;
            this.consumerUrl = (URL) url.getAttribute(CONSUMER_URL_KEY);
        } else {
            queryMap = StringUtils.parseQueryString(url.getParameterAndDecoded(REFER_KEY));
        }

        // remove some local only parameters
        applicationModel = url.getOrDefaultApplicationModel();
        this.queryMap = applicationModel.getBeanFactory().getBean(ClusterUtils.class).mergeLocalParams(queryMap);

        if (consumerUrl == null) {
            String host = isNotEmpty(queryMap.get(REGISTER_IP_KEY)) ? queryMap.get(REGISTER_IP_KEY) : this.url.getHost();
            String path = isNotEmpty(queryMap.get(PATH_KEY)) ? queryMap.get(PATH_KEY) : queryMap.get(INTERFACE_KEY);
            String consumedProtocol = isNotEmpty(queryMap.get(PROTOCOL_KEY)) ? queryMap.get(PROTOCOL_KEY) : CONSUMER;

            URL consumerUrlFrom = this.url
                .setHost(host)
                .setPort(0)
                .setProtocol(consumedProtocol)
                .setPath(path);
            if (isUrlFromRegistry) {
                // reserve parameters if url is already a consumer url
                consumerUrlFrom = consumerUrlFrom.clearParameters();
            }
            this.consumerUrl = consumerUrlFrom.addParameters(queryMap);
        }

        this.connectivityExecutor = applicationModel.getFrameworkModel().getBeanFactory()
            .getBean(FrameworkExecutorRepository.class).getConnectivityScheduledExecutor();
        Configuration configuration = ConfigurationUtils.getGlobalConfiguration(url.getOrDefaultModuleModel());
        this.reconnectTaskTryCount = configuration.getInt(RECONNECT_TASK_TRY_COUNT, DEFAULT_RECONNECT_TASK_TRY_COUNT);
        this.reconnectTaskPeriod = configuration.getInt(RECONNECT_TASK_PERIOD, DEFAULT_RECONNECT_TASK_PERIOD);
        setRouterChain(routerChain);

    }
",0
dubbo-3.2,NULL_DEREFERENCE,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/directory/AbstractDirectory.java,"org.apache.dubbo.rpc.cluster.directory.AbstractDirectory.<init>(org.apache.dubbo.common.URL,org.apache.dubbo.rpc.cluster.RouterChain,boolean)",183,object returned by `AbstractDirectory.applicationModel.getFrameworkModel().getBeanFactory().getBean(org.apache.dubbo.common.threadpool.manager.FrameworkExecutorRepository)` could be null and is dereferenced at line 183.,https://github.com/apache/dubbo/blob/3.2/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/directory/AbstractDirectory.java,"public AbstractDirectory(URL url, RouterChain<T> routerChain, boolean isUrlFromRegistry) {
        if (url == null) {
            throw new IllegalArgumentException(""url == null"");
        }

        this.url = url.removeAttribute(REFER_KEY).removeAttribute(MONITOR_KEY);

        Map<String, String> queryMap;
        Object referParams = url.getAttribute(REFER_KEY);
        if (referParams instanceof Map) {
            queryMap = (Map<String, String>) referParams;
            this.consumerUrl = (URL) url.getAttribute(CONSUMER_URL_KEY);
        } else {
            queryMap = StringUtils.parseQueryString(url.getParameterAndDecoded(REFER_KEY));
        }

        // remove some local only parameters
        applicationModel = url.getOrDefaultApplicationModel();
        this.queryMap = applicationModel.getBeanFactory().getBean(ClusterUtils.class).mergeLocalParams(queryMap);

        if (consumerUrl == null) {
            String host = isNotEmpty(queryMap.get(REGISTER_IP_KEY)) ? queryMap.get(REGISTER_IP_KEY) : this.url.getHost();
            String path = isNotEmpty(queryMap.get(PATH_KEY)) ? queryMap.get(PATH_KEY) : queryMap.get(INTERFACE_KEY);
            String consumedProtocol = isNotEmpty(queryMap.get(PROTOCOL_KEY)) ? queryMap.get(PROTOCOL_KEY) : CONSUMER;

            URL consumerUrlFrom = this.url
                .setHost(host)
                .setPort(0)
                .setProtocol(consumedProtocol)
                .setPath(path);
            if (isUrlFromRegistry) {
                // reserve parameters if url is already a consumer url
                consumerUrlFrom = consumerUrlFrom.clearParameters();
            }
            this.consumerUrl = consumerUrlFrom.addParameters(queryMap);
        }

        this.connectivityExecutor = applicationModel.getFrameworkModel().getBeanFactory()
            .getBean(FrameworkExecutorRepository.class).getConnectivityScheduledExecutor();
        Configuration configuration = ConfigurationUtils.getGlobalConfiguration(url.getOrDefaultModuleModel());
        this.reconnectTaskTryCount = configuration.getInt(RECONNECT_TASK_TRY_COUNT, DEFAULT_RECONNECT_TASK_TRY_COUNT);
        this.reconnectTaskPeriod = configuration.getInt(RECONNECT_TASK_PERIOD, DEFAULT_RECONNECT_TASK_PERIOD);
        setRouterChain(routerChain);

    }
",0
dubbo-3.2,NULL_DEREFERENCE,dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/context/DubboBootstrapApplicationListener.java,org.apache.dubbo.config.spring.context.DubboBootstrapApplicationListener.setApplicationContext(org.springframework.context.ApplicationContext):void,151,object `DubboBootstrapApplicationListener.moduleModel` last assigned on line 150 could be null and is dereferenced at line 151.,"148: public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
 149: this.applicationContext = applicationContext;
 150: moduleModel = DubboBeanUtils.getModuleModel(applicationContext);
 151: this.setBootstrap(DubboBootstrap.getInstance(moduleModel.getApplicationModel()));
 152: if (shouldInitConfigBeans) {","public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
        this.applicationContext = applicationContext;
        moduleModel = DubboBeanUtils.getModuleModel(applicationContext);
        this.setBootstrap(DubboBootstrap.getInstance(moduleModel.getApplicationModel()));
        if (shouldInitConfigBeans) {
            checkCallStackAndInit();
        }
    }",1
dubbo-3.2,NULL_DEREFERENCE,dubbo-registry/dubbo-registry-nacos/src/main/java/org/apache/dubbo/registry/nacos/NacosServiceDiscovery.java,"org.apache.dubbo.registry.nacos.NacosServiceDiscovery.lambda$getInstances$5(java.lang.String,org.apache.dubbo.registry.nacos.NacosNamingServiceWrapper):java.util.List",149,"object returned by `service.selectInstances(serviceName,NacosServiceDiscovery.group,1)` could be null and is dereferenced at line 149.",https://github.com/apache/dubbo/blob/3.2/dubbo-registry/dubbo-registry-nacos/src/main/java/org/apache/dubbo/registry/nacos/NacosServiceDiscovery.java,"public List<ServiceInstance> getInstances(String serviceName) throws NullPointerException {
        return ThrowableFunction.execute(namingService, service ->
                service.selectInstances(serviceName, group, true)
                        .stream().map((i) -> NacosNamingServiceUtils.toServiceInstance(registryURL, i))
                        .collect(Collectors.toList())
        );
    }",1
dubbo-3.2,NULL_DEREFERENCE,dubbo-common/src/main/java/org/apache/dubbo/common/threadpool/support/AbortPolicyWithReport.java,org.apache.dubbo.common.threadpool.support.AbortPolicyWithReport.lambda$dumpJStack$2():void,155,"object returned by `getProperty(""os.name"")` could be null and is dereferenced at line 155.","137: private void dumpJStack() {
 138: long now = System.currentTimeMillis();
 139: 
 140: //dump every 10 minutes
 141: if (now - lastPrintTime < TEN_MINUTES_MILLS) {
 142: return;
 143: }
 144: 
 145: if (!guard.tryAcquire()) {
 146: return;
 147: }
 148: 
 149: ExecutorService pool = Executors.newSingleThreadExecutor();
 150: pool.execute(() -> {
 151: String dumpPath = getDumpPath();
 152: 
 153: SimpleDateFormat sdf;
 154: 
 155: String os = System.getProperty(OS_NAME_KEY).toLowerCase();
 156: 
 157: // window system don't support "":"" in file name
 158: if (os.contains(OS_WIN_PREFIX)) {
 159: sdf = new SimpleDateFormat(WIN_DATETIME_FORMAT);
 160: } else {
 161: sdf = new SimpleDateFormat(DEFAULT_DATETIME_FORMAT);
 162: }
 163: 
 164: String dateStr = sdf.format(new Date());
 165: //try-with-resources
 166: try (FileOutputStream jStackStream = new FileOutputStream(
 167: new File(dumpPath, ""Dubbo_JStack.log"" + ""."" + dateStr))) {
 168: jstack(jStackStream);
 169: } catch (Exception t) {
 170: logger.error(COMMON_UNEXPECTED_CREATE_DUMP, """", """", ""dump jStack error"", t);
 171: } finally {
 172: guard.release();
 173: }
 174: lastPrintTime = System.currentTimeMillis();
 175: });
 176: //must shutdown thread pool ,if not will lead to OOM
 177: pool.shutdown();","private void dumpJStack() {
        long now = System.currentTimeMillis();

        //dump every 10 minutes
        if (now - lastPrintTime < TEN_MINUTES_MILLS) {
            return;
        }

        if (!guard.tryAcquire()) {
            return;
        }

        ExecutorService pool = Executors.newSingleThreadExecutor();
        pool.execute(() -> {
            String dumpPath = getDumpPath();

            SimpleDateFormat sdf;

            String os = System.getProperty(OS_NAME_KEY).toLowerCase();

            // window system don't support "":"" in file name
            if (os.contains(OS_WIN_PREFIX)) {
                sdf = new SimpleDateFormat(WIN_DATETIME_FORMAT);
            } else {
                sdf = new SimpleDateFormat(DEFAULT_DATETIME_FORMAT);
            }

            String dateStr = sdf.format(new Date());
            //try-with-resources
            try (FileOutputStream jStackStream = new FileOutputStream(
                new File(dumpPath, ""Dubbo_JStack.log"" + ""."" + dateStr))) {
                jstack(jStackStream);
            } catch (Exception t) {
                logger.error(COMMON_UNEXPECTED_CREATE_DUMP, """", """", ""dump jStack error"", t);
            } finally {
                guard.release();
            }
            lastPrintTime = System.currentTimeMillis();
        });
        //must shutdown thread pool ,if not will lead to OOM
        pool.shutdown();

    }
",0
dubbo-3.2,NULL_DEREFERENCE,dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/transport/dispatcher/WrappedChannelHandler.java,org.apache.dubbo.remoting.transport.dispatcher.WrappedChannelHandler.getSharedExecutorService():java.util.concurrent.ExecutorService,164,object `executorRepository` last assigned on line 162 could be null and is dereferenced at line 164.,"152: public ExecutorService getSharedExecutorService() {
 153: // Application may be destroyed before channel disconnected, avoid create new application model
 154: // see https://github.com/apache/dubbo/issues/9127
 155: if (url.getApplicationModel() == null || url.getApplicationModel().isDestroyed()) {
 156: return GlobalResourcesRepository.getGlobalExecutorService();
 157: }
 158: 
 159: // note: url.getOrDefaultApplicationModel() may create new application model
 160: ApplicationModel applicationModel = url.getOrDefaultApplicationModel();
 161: 
 162: ExecutorRepository executorRepository = ExecutorRepository.getInstance(applicationModel);
 163: 
 164: ExecutorService executor = executorRepository.getExecutor(url);
 165: 
 166: if (executor == null) {
 167: executor = executorRepository.createExecutorIfAbsent(url);
 168: }
 169: 
 170: return executor;","public ExecutorService getSharedExecutorService() {
        // Application may be destroyed before channel disconnected, avoid create new application model
        // see https://github.com/apache/dubbo/issues/9127
        if (url.getApplicationModel() == null || url.getApplicationModel().isDestroyed()) {
            return GlobalResourcesRepository.getGlobalExecutorService();
        }

        // note: url.getOrDefaultApplicationModel() may create new application model
        ApplicationModel applicationModel = url.getOrDefaultApplicationModel();

        ExecutorRepository executorRepository = ExecutorRepository.getInstance(applicationModel);

        ExecutorService executor = executorRepository.getExecutor(url);

        if (executor == null) {
            executor = executorRepository.createExecutorIfAbsent(url);
        }

        return executor;
    }",1
dubbo-3.2,NULL_DEREFERENCE,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/call/ReflectionAbstractServerCall.java,org.apache.dubbo.rpc.protocol.tri.call.ReflectionAbstractServerCall.parseSingleMessage(byte[]):java.lang.Object,165,object returned by `AbstractServerCall.invoker.getUrl().getServiceModel()` could be null and is dereferenced at line 165.,"158: protected Object parseSingleMessage(byte[] data) throws Exception {
 159: trySetMethodDescriptor(data);
 160: trySetListener();
 161: if (isClosed()) {
 162: return null;
 163: }
 164: ClassLoadUtil.switchContextLoader(
 165: invoker.getUrl().getServiceModel().getClassLoader());
 166: return packableMethod.getRequestUnpack().unpack(data);","protected Object parseSingleMessage(byte[] data) throws Exception {
        trySetMethodDescriptor(data);
        trySetListener();
        if (isClosed()) {
            return null;
        }
        ClassLoadUtil.switchContextLoader(
            invoker.getUrl().getServiceModel().getClassLoader());
        return packableMethod.getRequestUnpack().unpack(data);
    }",1
dubbo-3.2,NULL_DEREFERENCE,dubbo-rpc/dubbo-rpc-rest/src/main/java/org/apache/dubbo/rpc/protocol/rest/netty/NettyHttpResponse.java,org.apache.dubbo.rpc.protocol.rest.netty.NettyHttpResponse.finish():void,175,object returned by `getOutputStream()` could be null and is dereferenced at line 175.,"160: public void finish() throws IOException {
 161: if (os != null)
 162: os.flush();
 163: ChannelFuture future;
 164: if (isCommitted()) {
 165: // if committed this means the output stream was used.
 166: future = ctx.writeAndFlush(LastHttpContent.EMPTY_LAST_CONTENT);
 167: } else {
 168: future = ctx.writeAndFlush(getEmptyHttpResponse());
 169: }
 170: 
 171: if (!isKeepAlive()) {
 172: future.addListener(ChannelFutureListener.CLOSE);
 173: }
 174: 
 175: getOutputStream().close();","public void finish() throws IOException {
        if (os != null)
            os.flush();
        ChannelFuture future;
        if (isCommitted()) {
            // if committed this means the output stream was used.
            future = ctx.writeAndFlush(LastHttpContent.EMPTY_LAST_CONTENT);
        } else {
            future = ctx.writeAndFlush(getEmptyHttpResponse());
        }

        if (!isKeepAlive()) {
            future.addListener(ChannelFutureListener.CLOSE);
        }

        getOutputStream().close();
    }",0
dubbo-3.2,NULL_DEREFERENCE,dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/context/DubboSpringInitializer.java,"org.apache.dubbo.config.spring.context.DubboSpringInitializer.registerContextBeans(org.springframework.beans.factory.config.ConfigurableListableBeanFactory,org.apache.dubbo.config.spring.context.DubboSpringInitContext):void",167,object returned by `context.getApplicationModel()` could be null and is dereferenced by call to `registerSingleton(...)` at line 167.,"164: private static void registerContextBeans(ConfigurableListableBeanFactory beanFactory, DubboSpringInitContext context) {
 165: // register singleton
 166: registerSingleton(beanFactory, context);
 167: registerSingleton(beanFactory, context.getApplicationModel());
 168: registerSingleton(beanFactory, context.getModuleModel());","private static void registerContextBeans(ConfigurableListableBeanFactory beanFactory, DubboSpringInitContext context) {
        // register singleton
        registerSingleton(beanFactory, context);
        registerSingleton(beanFactory, context.getApplicationModel());
        registerSingleton(beanFactory, context.getModuleModel());
    }",1
dubbo-3.2,NULL_DEREFERENCE,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleProtocol.java,"org.apache.dubbo.rpc.protocol.tri.TripleProtocol.getOrCreateStreamExecutor(org.apache.dubbo.rpc.model.ApplicationModel,org.apache.dubbo.common.URL):java.util.concurrent.ExecutorService",167,object returned by `getInstance(applicationModel)` could be null and is dereferenced at line 167.,"166: private ExecutorService getOrCreateStreamExecutor(ApplicationModel applicationModel, URL url) {
 167: ExecutorService executor = ExecutorRepository.getInstance(applicationModel).createExecutorIfAbsent(ExecutorUtil.setThreadName(url, SERVER_THREAD_POOL_NAME));
 168: Objects.requireNonNull(executor,
 169: String.format(""No available executor found in %s"", url));
 170: return executor;","private ExecutorService getOrCreateStreamExecutor(ApplicationModel applicationModel, URL url) {
        ExecutorService executor = ExecutorRepository.getInstance(applicationModel).createExecutorIfAbsent(ExecutorUtil.setThreadName(url, SERVER_THREAD_POOL_NAME));
        Objects.requireNonNull(executor,
            String.format(""No available executor found in %s"", url));
        return executor;
    }",1
dubbo-3.2,NULL_DEREFERENCE,dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/support/MockInvoker.java,"org.apache.dubbo.rpc.support.MockInvoker.getMockObject(org.apache.dubbo.common.extension.ExtensionDirector,java.lang.String,java.lang.Class):java.lang.Object",198,object `mockClass` last assigned on line 182 could be null and is dereferenced at line 198.,"174: public static Object getMockObject(ExtensionDirector extensionDirector, String mockService, Class serviceType) {
 175: boolean isDefault = ConfigUtils.isDefault(mockService);
 176: if (isDefault) {
 177: mockService = serviceType.getName() + ""Mock"";
 178: }
 179: 
 180: Class<?> mockClass;
 181: try {
 182: mockClass = ReflectUtils.forName(mockService);
 183: } catch (Exception e) {
 184: if (!isDefault) {// does not check Spring bean if it is default config.
 185: ExtensionInjector extensionFactory =
 186: extensionDirector.getExtensionLoader(ExtensionInjector.class).getAdaptiveExtension();
 187: Object obj = extensionFactory.getInstance(serviceType, mockService);
 188: if (obj != null) {
 189: return obj;
 190: }
 191: }
 192: throw new IllegalStateException(""Did not find mock class or instance ""
 193: + mockService
 194: + "", please check if there's mock class or instance implementing interface ""
 195: + serviceType.getName(), e);
 196: }
 197: if (mockClass == null || !serviceType.isAssignableFrom(mockClass)) {
 198: throw new IllegalStateException(""The mock class "" + mockClass.getName() +
 199: "" not implement interface "" + serviceType.getName());
 200: }
 201: 
 202: try {","public static Object getMockObject(ExtensionDirector extensionDirector, String mockService, Class serviceType) {
        boolean isDefault = ConfigUtils.isDefault(mockService);
        if (isDefault) {
            mockService = serviceType.getName() + ""Mock"";
        }

        Class<?> mockClass;
        try {
            mockClass = ReflectUtils.forName(mockService);
        } catch (Exception e) {
            if (!isDefault) {// does not check Spring bean if it is default config.
                ExtensionInjector extensionFactory =
                    extensionDirector.getExtensionLoader(ExtensionInjector.class).getAdaptiveExtension();
                Object obj = extensionFactory.getInstance(serviceType, mockService);
                if (obj != null) {
                    return obj;
                }
            }
            throw new IllegalStateException(""Did not find mock class or instance ""
                + mockService
                + "", please check if there's mock class or instance implementing interface ""
                + serviceType.getName(), e);
        }
        if (mockClass == null || !serviceType.isAssignableFrom(mockClass)) {
            throw new IllegalStateException(""The mock class "" + mockClass.getName() +
                "" not implement interface "" + serviceType.getName());
        }

        try {
            return mockClass.newInstance();
        } catch (InstantiationException e) {
            throw new IllegalStateException(""No default constructor from mock class "" + mockClass.getName(), e);
        } catch (IllegalAccessException e) {
            throw new IllegalStateException(e);
        }
    }",1
dubbo-3.2,NULL_DEREFERENCE,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/wrapper/ScopeClusterInvoker.java,org.apache.dubbo.rpc.cluster.support.wrapper.ScopeClusterInvoker.onExporterChangeExport(org.apache.dubbo.rpc.Exporter):void,181,object returned by `getUrl().getServiceKey()` could be null and is dereferenced at line 181.,"177: public void onExporterChangeExport(Exporter<?> exporter) {
 178: if (isExported.get()) {
 179: return;
 180: }
 181: if (getUrl().getServiceKey().equals(exporter.getInvoker().getUrl().getServiceKey())","public void onExporterChangeExport(Exporter<?> exporter) {
        if (isExported.get()) {
            return;
        }
        if (getUrl().getServiceKey().equals(exporter.getInvoker().getUrl().getServiceKey())
            && exporter.getInvoker().getUrl().getProtocol().equalsIgnoreCase(LOCAL_PROTOCOL)) {
            createInjvmInvoker(exporter);
            isExported.compareAndSet(false, true);
        }
    }",1
dubbo-3.2,NULL_DEREFERENCE,dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/migration/model/MigrationRule.java,"org.apache.dubbo.registry.client.migration.model.MigrationRule.getDefaultStep(org.apache.dubbo.common.URL,java.lang.String):java.lang.String",178,object returned by `consumerURL.getScopeModel()` could be null and is dereferenced by call to `getCachedDynamicProperty(...)` at line 178.,"177: private String getDefaultStep(URL consumerURL, String defaultStep) {
 178: String globalDefaultStep = ConfigurationUtils.getCachedDynamicProperty(consumerURL.getScopeModel(), DUBBO_SERVICEDISCOVERY_MIGRATION, null);
 179: if (StringUtils.isEmpty(globalDefaultStep)) {
 180: // check 'dubbo.application.service-discovery.migration' for compatibility
 181: globalDefaultStep = ConfigurationUtils.getCachedDynamicProperty(consumerURL.getScopeModel(), ""dubbo.application.service-discovery.migration"", defaultStep);
 182: }
 183: return globalDefaultStep;","private String getDefaultStep(URL consumerURL, String defaultStep) {
        String globalDefaultStep = ConfigurationUtils.getCachedDynamicProperty(consumerURL.getScopeModel(), DUBBO_SERVICEDISCOVERY_MIGRATION, null);
        if (StringUtils.isEmpty(globalDefaultStep)) {
            // check 'dubbo.application.service-discovery.migration' for compatibility
            globalDefaultStep = ConfigurationUtils.getCachedDynamicProperty(consumerURL.getScopeModel(), ""dubbo.application.service-discovery.migration"", defaultStep);
        }
        return globalDefaultStep;
    }",1
dubbo-3.2,NULL_DEREFERENCE,dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/reference/ReferenceBeanSupport.java,"org.apache.dubbo.config.spring.reference.ReferenceBeanSupport.convertToString(java.lang.String,java.lang.Object):java.lang.String",190,object `attributes` last assigned on line 189 could be null and is dereferenced at line 190.,https://github.com/apache/dubbo/blob/3.2/dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/reference/ReferenceBeanSupport.java,"private static String convertToString(String key, Object obj) {
        if (obj == null) {
            return null;
        }
        if (ReferenceAttributes.PARAMETERS.equals(key) && obj instanceof String[]) {
            //convert parameters array pairs to map
            obj = DubboAnnotationUtils.convertParameters((String[]) obj);
        }

        //to string
        if (obj instanceof Annotation) {
            AnnotationAttributes attributes = AnnotationUtils.getAnnotationAttributes((Annotation) obj, true);
            for (Map.Entry<String, Object> entry : attributes.entrySet()) {
                entry.setValue(convertToString(entry.getKey(), entry.getValue()));
            }
            return String.valueOf(attributes);
        } else if (obj.getClass().isArray()) {
            Object[] array = ObjectUtils.toObjectArray(obj);
            String[] newArray = new String[array.length];
            for (int i = 0; i < array.length; i++) {
                newArray[i] = convertToString(null, array[i]);
            }
            Arrays.sort(newArray);
            return Arrays.toString(newArray);
        } else if (obj instanceof Map) {
            Map<String, Object> map = (Map<String, Object>) obj;
            TreeMap newMap = new TreeMap();
            for (Map.Entry<String, Object> entry : map.entrySet()) {
                newMap.put(entry.getKey(), convertToString(entry.getKey(), entry.getValue()));
            }
            return String.valueOf(newMap);
        } else {
            return String.valueOf(obj);
        }
    }",0
dubbo-3.2,NULL_DEREFERENCE,dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/bootstrap/builders/InternalServiceConfigBuilder.java,"org.apache.dubbo.config.bootstrap.builders.InternalServiceConfigBuilder.port(java.lang.Integer,java.lang.String):org.apache.dubbo.config.bootstrap.builders.InternalServiceConfigBuilder",216,object returned by `server.getUrl()` could be null and is dereferenced at line 216.,"187: public InternalServiceConfigBuilder<T> port(Integer specPort, String key) {
 188: Assert.notEmptyString(this.protocol,""export protocol is null"");
 189: Assert.notNull(this.interfaceClass,""export interfaceClass is null"");
 190: 
 191: if (specPort != null) {
 192: this.port = specPort;
 193: return getThis();
 194: }
 195: Map<String, String> params = getApplicationConfig().getParameters();
 196: if (CollectionUtils.isNotEmptyMap(params) && StringUtils.isNotBlank(key)) {
 197: String rawPort = getApplicationConfig().getParameters().get(key);
 198: if (StringUtils.isNotEmpty(rawPort)) {
 199: specPort = Integer.parseInt(rawPort);
 200: }
 201: }
 202: 
 203: if (specPort == null || specPort < -1) {
 204: try {
 205: if (logger.isInfoEnabled()) {
 206: logger.info(interfaceClass.getName()+""Service Port hasn't been set will use default protocol defined in protocols."");
 207: }
 208: 
 209: Protocol protocol = applicationModel.getExtensionLoader(Protocol.class).getExtension(this.protocol);
 210: if (protocol != null && protocol.getServers() != null) {
 211: Iterator<ProtocolServer> it = protocol.getServers().iterator();
 212: // export service may export before normal service export, it.hasNext() will return false.
 213: // so need use specified protocol port.
 214: if (it.hasNext()) {
 215: ProtocolServer server = it.next();
 216: String rawPort = server.getUrl().getParameter(BIND_PORT_KEY);
 217: if (rawPort == null) {
 218: String addr = server.getAddress();
 219: rawPort = addr.substring(addr.indexOf("":"") + 1);
 220: }
 221: this.port = Integer.parseInt(rawPort);
 222: } else {
 223: ProtocolConfig specifiedProtocolConfig = getProtocolConfig();
 224: if (specifiedProtocolConfig != null) {
 225: Integer protocolPort = specifiedProtocolConfig.getPort();
 226: if (null != protocolPort && protocolPort != -1) {
 227: this.port = protocolPort;
 228: }
 229: }
 230: }
 231: }
 232: } catch (Exception e) {
 233: logger.error(INTERNAL_ERROR, ""invalid specified "" + port + "" port, error ""+e.getMessage(),
 234: """", ""Failed to find any valid protocol, will use random port to export service."",e);
 235: }
 236: }
 237: if (this.port == null) {
 238: this.port = -1;
 239: }
 240: return getThis();","public InternalServiceConfigBuilder<T> port(Integer specPort, String key) {
        Assert.notEmptyString(this.protocol,""export protocol is null"");
        Assert.notNull(this.interfaceClass,""export interfaceClass is null"");

        if (specPort != null) {
            this.port = specPort;
            return getThis();
        }
        Map<String, String> params = getApplicationConfig().getParameters();
        if (CollectionUtils.isNotEmptyMap(params) && StringUtils.isNotBlank(key)) {
            String rawPort = getApplicationConfig().getParameters().get(key);
            if (StringUtils.isNotEmpty(rawPort)) {
                specPort = Integer.parseInt(rawPort);
            }
        }

        if (specPort == null || specPort < -1) {
            try {
                if (logger.isInfoEnabled()) {
                    logger.info(interfaceClass.getName()+""Service Port hasn't been set will use default protocol defined in protocols."");
                }

                Protocol protocol = applicationModel.getExtensionLoader(Protocol.class).getExtension(this.protocol);
                if (protocol != null && protocol.getServers() != null) {
                    Iterator<ProtocolServer> it = protocol.getServers().iterator();
                    // export service may export before normal service export, it.hasNext() will return false.
                    // so need use specified protocol port.
                    if (it.hasNext()) {
                        ProtocolServer server = it.next();
                        String rawPort = server.getUrl().getParameter(BIND_PORT_KEY);
                        if (rawPort == null) {
                            String addr = server.getAddress();
                            rawPort = addr.substring(addr.indexOf("":"") + 1);
                        }
                        this.port = Integer.parseInt(rawPort);
                    } else {
                        ProtocolConfig specifiedProtocolConfig = getProtocolConfig();
                        if (specifiedProtocolConfig != null) {
                            Integer protocolPort = specifiedProtocolConfig.getPort();
                            if (null != protocolPort && protocolPort != -1) {
                                this.port = protocolPort;
                            }
                        }
                    }
                }
            } catch (Exception e) {
                logger.error(INTERNAL_ERROR, ""invalid specified "" + port + ""  port, error ""+e.getMessage(),
                    """", ""Failed to find any valid protocol, will use random port to export  service."",e);
            }
        }
        if (this.port == null) {
            this.port = -1;
        }
        return getThis();
    }
",1
dubbo-3.2,NULL_DEREFERENCE,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/wrapper/ScopeClusterInvoker.java,org.apache.dubbo.rpc.cluster.support.wrapper.ScopeClusterInvoker.onExporterChangeUnExport(org.apache.dubbo.rpc.Exporter):void,190,object returned by `getUrl().getServiceKey()` could be null and is dereferenced at line 190.,"189: public void onExporterChangeUnExport(Exporter<?> exporter) {
 190: if (getUrl().getServiceKey().equals(exporter.getInvoker().getUrl().getServiceKey())","public void onExporterChangeUnExport(Exporter<?> exporter) {
        if (getUrl().getServiceKey().equals(exporter.getInvoker().getUrl().getServiceKey())
            && exporter.getInvoker().getUrl().getProtocol().equalsIgnoreCase(LOCAL_PROTOCOL)) {
            destroyInjvmInvoker();
            isExported.compareAndSet(true, false);
        }
    }
",1
dubbo-3.2,NULL_DEREFERENCE,dubbo-metrics/dubbo-metrics-default/src/main/java/org/apache/dubbo/metrics/report/AbstractMetricsReporter.java,org.apache.dubbo.metrics.report.AbstractMetricsReporter.registerDubboShutdownHook():void,201,object returned by `AbstractMetricsReporter.applicationModel.getBeanFactory().getBean(org.apache.dubbo.common.lang.ShutdownHookCallbacks)` could be null and is dereferenced at line 201.,"200: private void registerDubboShutdownHook() {
 201: applicationModel.getBeanFactory().getBean(ShutdownHookCallbacks.class).addCallback(this::destroy);","public void destroy() {
        if (collectorSyncJobExecutor != null) {
            collectorSyncJobExecutor.shutdownNow();
        }
        doDestroy();
    }",0
dubbo-3.2,NULL_DEREFERENCE,dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/metadata/ServiceInstanceMetadataUtils.java,org.apache.dubbo.registry.client.metadata.ServiceInstanceMetadataUtils.registerMetadataAndInstance(org.apache.dubbo.rpc.model.ApplicationModel):void,204,object `registryManager` last assigned on line 202 could be null and is dereferenced at line 204.,"200: public static void registerMetadataAndInstance(ApplicationModel applicationModel) {
 201: LOGGER.info(""Start registering instance address to registry."");
 202: RegistryManager registryManager = applicationModel.getBeanFactory().getBean(RegistryManager.class);
 203: // register service instance
 204: registryManager.getServiceDiscoveries().forEach(ServiceDiscovery::register);","public static Endpoint getEndpoint(ServiceInstance serviceInstance, String protocol) {
        List<Endpoint> endpoints = ((DefaultServiceInstance) serviceInstance).getEndpoints();
        if (endpoints != null) {
            for (Endpoint endpoint : endpoints) {
                if (endpoint.getProtocol().equals(protocol)) {
                    return endpoint;
                }
            }
        }
        return null;
    }",0
dubbo-3.2,NULL_DEREFERENCE,dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/metadata/ServiceInstanceMetadataUtils.java,org.apache.dubbo.registry.client.metadata.ServiceInstanceMetadataUtils.refreshMetadataAndInstance(org.apache.dubbo.rpc.model.ApplicationModel):void,210,object `registryManager` last assigned on line 208 could be null and is dereferenced at line 210.,"207: public static void refreshMetadataAndInstance(ApplicationModel applicationModel) {
 208: RegistryManager registryManager = applicationModel.getBeanFactory().getBean(RegistryManager.class);
 209: // update service instance revision
 210: registryManager.getServiceDiscoveries().forEach(ServiceDiscovery::update);","public static void registerMetadataAndInstance(ApplicationModel applicationModel) {
        LOGGER.info(""Start registering instance address to registry."");
        RegistryManager registryManager = applicationModel.getBeanFactory().getBean(RegistryManager.class);
        // register service instance
        List<ServiceDiscovery> serviceDiscoveries = registryManager.getServiceDiscoveries();
        for (ServiceDiscovery serviceDiscovery : serviceDiscoveries) {
            MetricsEventBus.post(RegistryEvent.toRegisterEvent(applicationModel,
                    Collections.singletonList(getServiceDiscoveryName(serviceDiscovery))),
                () -> {
                    // register service instance
                    serviceDiscoveries.forEach(ServiceDiscovery::register);
                    return null;
                }
            );
        }
    }",0
dubbo-3.2,NULL_DEREFERENCE,dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryProtocol.java,org.apache.dubbo.registry.integration.RegistryProtocol.getOverrideListeners():java.util.Map,217,object returned by `applicationModel.getBeanFactory().getBean(org.apache.dubbo.registry.integration.RegistryProtocol$ProviderConfigurationListener)` could be null and is dereferenced at line 217.,https://github.com/apache/dubbo/blob/3.2/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryProtocol.java,"public Map<URL, Set<NotifyListener>> getOverrideListeners() {
        Map<URL, Set<NotifyListener>> map = new HashMap<>();
        List<ApplicationModel> applicationModels = frameworkModel.getApplicationModels();
        if (applicationModels.size() == 1) {
            return applicationModels.get(0).getBeanFactory().getBean(ProviderConfigurationListener.class).getOverrideListeners();
        } else {
            for (ApplicationModel applicationModel : applicationModels) {
                map.putAll(applicationModel.getBeanFactory().getBean(ProviderConfigurationListener.class).getOverrideListeners());
            }
        }
        return map;
    }",0
dubbo-3.2,NULL_DEREFERENCE,dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryProtocol.java,org.apache.dubbo.registry.integration.RegistryProtocol.getOverrideListeners():java.util.Map,214,object returned by `applicationModels.get(0).getBeanFactory().getBean(org.apache.dubbo.registry.integration.RegistryProtocol$ProviderConfigurationListener)` could be null and is dereferenced at line 214.,https://github.com/apache/dubbo/blob/3.2/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryProtocol.java,"public Map<URL, Set<NotifyListener>> getOverrideListeners() {
        Map<URL, Set<NotifyListener>> map = new HashMap<>();
        List<ApplicationModel> applicationModels = frameworkModel.getApplicationModels();
        if (applicationModels.size() == 1) {
            return applicationModels.get(0).getBeanFactory().getBean(ProviderConfigurationListener.class).getOverrideListeners();
        } else {
            for (ApplicationModel applicationModel : applicationModels) {
                map.putAll(applicationModel.getBeanFactory().getBean(ProviderConfigurationListener.class).getOverrideListeners());
            }
        }
        return map;
    }",0
dubbo-3.2,NULL_DEREFERENCE,dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/metadata/MetadataUtils.java,org.apache.dubbo.registry.client.metadata.MetadataUtils.getMetadataReports(org.apache.dubbo.rpc.model.ApplicationModel):java.util.Map,212,object returned by `applicationModel.getBeanFactory().getBean(org.apache.dubbo.metadata.report.MetadataReportInstance)` could be null and is dereferenced at line 212.,"211: private static Map<String, MetadataReport> getMetadataReports(ApplicationModel applicationModel) {
 212: return applicationModel.getBeanFactory().getBean(MetadataReportInstance.class).getMetadataReports(false);","private static Map<String, MetadataReport> getMetadataReports(ApplicationModel applicationModel) {
        return applicationModel.getBeanFactory().getBean(MetadataReportInstance.class).getMetadataReports(false);
    }",0
dubbo-3.2,NULL_DEREFERENCE,dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/metadata/ServiceInstanceMetadataUtils.java,org.apache.dubbo.registry.client.metadata.ServiceInstanceMetadataUtils.unregisterMetadataAndInstance(org.apache.dubbo.rpc.model.ApplicationModel):void,215,object `registryManager` last assigned on line 214 could be null and is dereferenced at line 215.,"213: public static void unregisterMetadataAndInstance(ApplicationModel applicationModel) {
 214: RegistryManager registryManager = applicationModel.getBeanFactory().getBean(RegistryManager.class);
 215: registryManager.getServiceDiscoveries().forEach(serviceDiscovery -> {","public static void registerMetadataAndInstance(ApplicationModel applicationModel) {
        LOGGER.info(""Start registering instance address to registry."");
        RegistryManager registryManager = applicationModel.getBeanFactory().getBean(RegistryManager.class);
        // register service instance
        List<ServiceDiscovery> serviceDiscoveries = registryManager.getServiceDiscoveries();
        for (ServiceDiscovery serviceDiscovery : serviceDiscoveries) {
            MetricsEventBus.post(RegistryEvent.toRegisterEvent(applicationModel,
                    Collections.singletonList(getServiceDiscoveryName(serviceDiscovery))),
                () -> {
                    // register service instance
                    serviceDiscoveries.forEach(ServiceDiscovery::register);
                    return null;
                }
            );
        }
    }",1
dubbo-3.2,NULL_DEREFERENCE,dubbo-config/dubbo-config-spring/src/main/java/org/apache/dubbo/config/spring/beans/factory/annotation/ReferenceAnnotationBeanPostProcessor.java,"org.apache.dubbo.config.spring.beans.factory.annotation.ReferenceAnnotationBeanPostProcessor.processReferenceAnnotatedBeanDefinition(java.lang.String,org.springframework.beans.factory.annotation.AnnotatedBeanDefinition):void",240,object `factoryMethodMetadata` last assigned on line 216 could be null and is dereferenced at line 240.,"214: private void processReferenceAnnotatedBeanDefinition(String beanName, AnnotatedBeanDefinition beanDefinition) {
 215: 
 216: MethodMetadata factoryMethodMetadata = SpringCompatUtils.getFactoryMethodMetadata(beanDefinition);
 217: 
 218: // Extract beanClass from generic return type of java-config bean method: ReferenceBean<DemoService>
 219: // see org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.getTypeForFactoryBeanFromMethod
 220: Class beanClass = getBeanFactory().getType(beanName);
 221: if (beanClass == Object.class) {
 222: beanClass = SpringCompatUtils.getGenericTypeOfReturnType(factoryMethodMetadata);
 223: }
 224: if (beanClass == Object.class) {
 225: // bean class is invalid, ignore it
 226: return;
 227: }
 228: 
 229: if (beanClass == null) {
 230: String beanMethodSignature = factoryMethodMetadata.getDeclaringClassName() + ""#"" + factoryMethodMetadata.getMethodName() + ""()"";
 231: throw new BeanCreationException(""The ReferenceBean is missing necessary generic type, which returned by the @Bean method of Java-config class. "" +
 232: ""The generic type of the returned ReferenceBean must be specified as the referenced interface type, "" +
 233: ""such as ReferenceBean<DemoService>. Please check bean method: "" + beanMethodSignature);
 234: }
 235: 
 236: // get dubbo reference annotation attributes
 237: Map<String, Object> annotationAttributes = null;
 238: // try all dubbo reference annotation types
 239: for (Class<? extends Annotation> annotationType : getAnnotationTypes()) {
 240: if (factoryMethodMetadata.isAnnotated(annotationType.getName())) {
 241: // Since Spring 5.2
 242: // return factoryMethodMetadata.getAnnotations().get(annotationType).filterDefaultValues().asMap();
 243: // Compatible with Spring 4.x
 244: annotationAttributes = factoryMethodMetadata.getAnnotationAttributes(annotationType.getName());
 245: annotationAttributes = filterDefaultValues(annotationType, annotationAttributes);
 246: break;
 247: }
 248: }
 249: 
 250: if (annotationAttributes != null) {
 251: // @DubboReference on @Bean method
 252: LinkedHashMap<String, Object> attributes = new LinkedHashMap<>(annotationAttributes);
 253: // reset id attribute
 254: attributes.put(ReferenceAttributes.ID, beanName);
 255: // convert annotation props
 256: ReferenceBeanSupport.convertReferenceProps(attributes, beanClass);
 257: 
 258: // get interface
 259: String interfaceName = (String) attributes.get(ReferenceAttributes.INTERFACE);
 260: 
 261: // check beanClass and reference interface class
 262: if (!StringUtils.isEquals(interfaceName, beanClass.getName()) && beanClass != GenericService.class) {
 263: String beanMethodSignature = factoryMethodMetadata.getDeclaringClassName() + ""#"" + factoryMethodMetadata.getMethodName() + ""()"";
 264: throw new BeanCreationException(""The 'interfaceClass' or 'interfaceName' attribute value of @DubboReference annotation "" +
 265: ""is inconsistent with the generic type of the ReferenceBean returned by the bean method. "" +
 266: ""The interface class of @DubboReference is: "" + interfaceName + "", but return ReferenceBean<"" + beanClass.getName() + "">. "" +
 267: ""Please remove the 'interfaceClass' and 'interfaceName' attributes from @DubboReference annotation. "" +
 268: ""Please check bean method: "" + beanMethodSignature);
 269: }
 270: 
 271: Class interfaceClass = beanClass;
 272: 
 273: // set attribute instead of property values
 274: beanDefinition.setAttribute(Constants.REFERENCE_PROPS, attributes);
 275: beanDefinition.setAttribute(ReferenceAttributes.INTERFACE_CLASS, interfaceClass);
 276: beanDefinition.setAttribute(ReferenceAttributes.INTERFACE_NAME, interfaceName);
 277: } else {
 278: // raw reference bean
 279: // the ReferenceBean is not yet initialized
 280: beanDefinition.setAttribute(ReferenceAttributes.INTERFACE_CLASS, beanClass);
 281: if (beanClass != GenericService.class) {
 282: beanDefinition.setAttribute(ReferenceAttributes.INTERFACE_NAME, beanClass.getName());
 283: }
 284: }
 285: 
 286: // set id
 287: beanDefinition.getPropertyValues().add(ReferenceAttributes.ID, beanName);","private void processReferenceAnnotatedBeanDefinition(String beanName, AnnotatedBeanDefinition beanDefinition) {

        MethodMetadata factoryMethodMetadata = SpringCompatUtils.getFactoryMethodMetadata(beanDefinition);

        // Extract beanClass from generic return type of java-config bean method: ReferenceBean<DemoService>
        // see org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.getTypeForFactoryBeanFromMethod
        Class beanClass = getBeanFactory().getType(beanName);
        if (beanClass == Object.class) {
            beanClass = SpringCompatUtils.getGenericTypeOfReturnType(factoryMethodMetadata);
        }
        if (beanClass == Object.class) {
            // bean class is invalid, ignore it
            return;
        }

        if (beanClass == null) {
            String beanMethodSignature = factoryMethodMetadata.getDeclaringClassName() + ""#"" + factoryMethodMetadata.getMethodName() + ""()"";
            throw new BeanCreationException(""The ReferenceBean is missing necessary generic type, which returned by the @Bean method of Java-config class. "" +
                ""The generic type of the returned ReferenceBean must be specified as the referenced interface type, "" +
                ""such as ReferenceBean<DemoService>. Please check bean method: "" + beanMethodSignature);
        }

        // get dubbo reference annotation attributes
        Map<String, Object> annotationAttributes = null;
        // try all dubbo reference annotation types
        for (Class<? extends Annotation> annotationType : getAnnotationTypes()) {
            if (factoryMethodMetadata.isAnnotated(annotationType.getName())) {
                // Since Spring 5.2
                // return factoryMethodMetadata.getAnnotations().get(annotationType).filterDefaultValues().asMap();
                // Compatible with Spring 4.x
                annotationAttributes = factoryMethodMetadata.getAnnotationAttributes(annotationType.getName());
                annotationAttributes = filterDefaultValues(annotationType, annotationAttributes);
                break;
            }
        }

        if (annotationAttributes != null) {
            // @DubboReference on @Bean method
            LinkedHashMap<String, Object> attributes = new LinkedHashMap<>(annotationAttributes);
            // reset id attribute
            attributes.put(ReferenceAttributes.ID, beanName);
            // convert annotation props
            ReferenceBeanSupport.convertReferenceProps(attributes, beanClass);

            // get interface
            String interfaceName = (String) attributes.get(ReferenceAttributes.INTERFACE);

            // check beanClass and reference interface class
            if (!StringUtils.isEquals(interfaceName, beanClass.getName()) && beanClass != GenericService.class) {
                String beanMethodSignature = factoryMethodMetadata.getDeclaringClassName() + ""#"" + factoryMethodMetadata.getMethodName() + ""()"";
                throw new BeanCreationException(""The 'interfaceClass' or 'interfaceName' attribute value of @DubboReference annotation "" +
                    ""is inconsistent with the generic type of the ReferenceBean returned by the bean method. "" +
                    ""The interface class of @DubboReference is: "" + interfaceName + "", but return ReferenceBean<"" + beanClass.getName() + "">. "" +
                    ""Please remove the 'interfaceClass' and 'interfaceName' attributes from @DubboReference annotation. "" +
                    ""Please check bean method: "" + beanMethodSignature);
            }

            Class interfaceClass = beanClass;

            // set attribute instead of property values
            beanDefinition.setAttribute(Constants.REFERENCE_PROPS, attributes);
            beanDefinition.setAttribute(ReferenceAttributes.INTERFACE_CLASS, interfaceClass);
            beanDefinition.setAttribute(ReferenceAttributes.INTERFACE_NAME, interfaceName);
        } else {
            // raw reference bean
            // the ReferenceBean is not yet initialized
            beanDefinition.setAttribute(ReferenceAttributes.INTERFACE_CLASS, beanClass);
            if (beanClass != GenericService.class) {
                beanDefinition.setAttribute(ReferenceAttributes.INTERFACE_NAME, beanClass.getName());
            }
        }

        // set id
        beanDefinition.getPropertyValues().add(ReferenceAttributes.ID, beanName);
    }",1
dubbo-3.2,NULL_DEREFERENCE,dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TripleInvoker.java,"org.apache.dubbo.rpc.protocol.tri.TripleInvoker.invokeUnary(org.apache.dubbo.rpc.model.MethodDescriptor,org.apache.dubbo.rpc.Invocation,org.apache.dubbo.rpc.protocol.tri.call.ClientCall,java.util.concurrent.Executor):org.apache.dubbo.rpc.AsyncRpcResult",231,object returned by `getUrl()` could be null and is dereferenced at line 231.,"219: AsyncRpcResult invokeUnary(MethodDescriptor methodDescriptor, Invocation invocation,
 220: ClientCall call, Executor callbackExecutor) {
 221: 
 222: int timeout = RpcUtils.calculateTimeout(getUrl(), invocation, RpcUtils.getMethodName(invocation), 3000);
 223: if (timeout <= 0) {
 224: return AsyncRpcResult.newDefaultAsyncResult(new RpcException(RpcException.TIMEOUT_TERMINATE,
 225: ""No time left for making the following call: "" + invocation.getServiceName() + "".""
 226: + RpcUtils.getMethodName(invocation)+ "", terminate directly.""), invocation);
 227: }
 228: invocation.setAttachment(TIMEOUT_KEY, String.valueOf(timeout));
 229: 
 230: final AsyncRpcResult result;
 231: DeadlineFuture future = DeadlineFuture.newFuture(getUrl().getPath(),
 232: methodDescriptor.getMethodName(), getUrl().getAddress(), timeout, callbackExecutor);
 233: 
 234: RequestMetadata request = createRequest(methodDescriptor, invocation, timeout);
 235: 
 236: final Object pureArgument;
 237: 
 238: if (methodDescriptor instanceof StubMethodDescriptor) {
 239: pureArgument = invocation.getArguments()[0];
 240: } else {
 241: pureArgument = invocation.getArguments();
 242: }
 243: result = new AsyncRpcResult(future, invocation);
 244: FutureContext.getContext().setCompatibleFuture(future);
 245: 
 246: result.setExecutor(callbackExecutor);
 247: ClientCall.Listener callListener = new UnaryClientCallListener(future);
 248: 
 249: final StreamObserver<Object> requestObserver = call.start(request, callListener);
 250: requestObserver.onNext(pureArgument);
 251: requestObserver.onCompleted();
 252: return result;","AsyncRpcResult invokeUnary(MethodDescriptor methodDescriptor, Invocation invocation,
                               ClientCall call, ExecutorService callbackExecutor) {

        int timeout = RpcUtils.calculateTimeout(getUrl(), invocation, RpcUtils.getMethodName(invocation), 3000);
        if (timeout <= 0) {
            return AsyncRpcResult.newDefaultAsyncResult(new RpcException(RpcException.TIMEOUT_TERMINATE,
                ""No time left for making the following call: "" + invocation.getServiceName() + "".""
                    + RpcUtils.getMethodName(invocation)+ "", terminate directly.""), invocation);
        }
        invocation.setAttachment(TIMEOUT_KEY, String.valueOf(timeout));

        final AsyncRpcResult result;
        DeadlineFuture future = DeadlineFuture.newFuture(getUrl().getPath(),
            methodDescriptor.getMethodName(), getUrl().getAddress(), timeout, callbackExecutor);

        RequestMetadata request = createRequest(methodDescriptor, invocation, timeout);

        final Object pureArgument;

        if (methodDescriptor instanceof StubMethodDescriptor) {
            pureArgument = invocation.getArguments()[0];
        } else {
            if (methodDescriptor.isGeneric()) {
                Object[] args = new Object[3];
                args[0] = RpcUtils.getMethodName(invocation);
                args[1] = Arrays.stream(RpcUtils.getParameterTypes(invocation)).map(Class::getName).collect(Collectors.toList());
                args[2] = RpcUtils.getArguments(invocation);
                pureArgument = args;
            } else {
                pureArgument = invocation.getArguments();
            }
        }
        result = new AsyncRpcResult(future, invocation);
        if (setFutureWhenSync || ((RpcInvocation) invocation).getInvokeMode() != InvokeMode.SYNC) {
            FutureContext.getContext().setCompatibleFuture(future);
        }

        result.setExecutor(callbackExecutor);
        ClientCall.Listener callListener = new UnaryClientCallListener(future);

        final StreamObserver<Object> requestObserver = call.start(request, callListener);
        requestObserver.onNext(pureArgument);
        requestObserver.onCompleted();
        return result;
    }",1
dubbo-3.2,NULL_DEREFERENCE,dubbo-compatible/src/main/java/com/alibaba/dubbo/common/URL.java,com.alibaba.dubbo.common.URL.getUrlParameter(java.lang.String):com.alibaba.dubbo.common.URL,227,object `result` last assigned on line 226 could be null and is dereferenced by call to `URL(...)` at line 227.,"225: public URL getUrlParameter(String key) {
 226: org.apache.dubbo.common.URL result = super.getUrlParameter(key);
 227: return new URL(result);","public URL getUrlParameter(String key) {
        org.apache.dubbo.common.URL result = super.getUrlParameter(key);
        return new URL(result);
    }",0
dubbo-3.2,NULL_DEREFERENCE,dubbo-metrics/dubbo-metrics-default/src/main/java/org/apache/dubbo/metrics/collector/AggregateMetricsCollector.java,org.apache.dubbo.metrics.collector.AggregateMetricsCollector.registerListener():void,227,object returned by `AggregateMetricsCollector.applicationModel.getBeanFactory().getBean(org.apache.dubbo.metrics.collector.DefaultMetricsCollector)` could be null and is dereferenced at line 227.,"226: private void registerListener() {
 227: applicationModel.getBeanFactory().getBean(DefaultMetricsCollector.class).getEventMulticaster().addListener(this);","private void collectMethod(List<MetricSample> list, String side, MetricsKey metricsKey) {
        MetricsKeyWrapper metricsKeyWrapper = new MetricsKeyWrapper(metricsKey, MetricsPlaceValue.of(side, MetricsLevel.SERVICE));
        ConcurrentHashMap<MethodMetric, TimeWindowCounter> windowCounter = methodTypeCounter.get(metricsKeyWrapper);
        if (windowCounter != null) {
            windowCounter.forEach((k, v) -> list.add(new GaugeMetricSample<>(metricsKey.getNameByType(k.getSide()),
                metricsKey.getDescription(), k.getTags(), REQUESTS, v, TimeWindowCounter::get)));
        }
    }",0
dubbo-3.2,NULL_DEREFERENCE,dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/event/listener/ServiceInstancesChangedListener.java,"org.apache.dubbo.registry.client.event.listener.ServiceInstancesChangedListener.addListenerAndNotify(org.apache.dubbo.common.URL,org.apache.dubbo.registry.NotifyListener):void",232,object returned by `listener.getConsumerUrl()` could be null and is dereferenced at line 232.,"226: public synchronized void addListenerAndNotify(URL url, NotifyListener listener) {
 227: if (destroyed.get()) {
 228: return;
 229: }
 230: 
 231: Set<NotifyListenerWithKey> notifyListeners = this.listeners.computeIfAbsent(url.getServiceKey(), _k -> new ConcurrentHashSet<>());
 232: String protocol = listener.getConsumerUrl().getParameter(PROTOCOL_KEY, url.getProtocol());
 233: ProtocolServiceKey protocolServiceKey = new ProtocolServiceKey(url.getServiceInterface(), url.getVersion(), url.getGroup(),
 234: !CommonConstants.CONSUMER.equals(protocol) ? protocol : null);
 235: NotifyListenerWithKey listenerWithKey = new NotifyListenerWithKey(protocolServiceKey, listener);
 236: notifyListeners.add(listenerWithKey);
 237: 
 238: // Aggregate address and notify on subscription.
 239: List<URL> urls = getAddresses(protocolServiceKey, listener.getConsumerUrl());
 240: 
 241: if (CollectionUtils.isNotEmpty(urls)) {","public synchronized void addListenerAndNotify(URL url, NotifyListener listener) {
        if (destroyed.get()) {
            return;
        }

        Set<NotifyListenerWithKey> notifyListeners = this.listeners.computeIfAbsent(url.getServiceKey(), _k -> new ConcurrentHashSet<>());
        String protocol = listener.getConsumerUrl().getParameter(PROTOCOL_KEY, url.getProtocol());
        ProtocolServiceKey protocolServiceKey = new ProtocolServiceKey(url.getServiceInterface(), url.getVersion(), url.getGroup(),
            !CommonConstants.CONSUMER.equals(protocol) ? protocol : null);
        NotifyListenerWithKey listenerWithKey = new NotifyListenerWithKey(protocolServiceKey, listener);
        notifyListeners.add(listenerWithKey);

        // Aggregate address and notify on subscription.
        List<URL> urls = getAddresses(protocolServiceKey, listener.getConsumerUrl());

        if (CollectionUtils.isNotEmpty(urls)) {
            logger.info(String.format(""Notify serviceKey: %s, listener: %s with %s urls on subscription"", protocolServiceKey, listener, urls.size()));
            listener.notify(urls);
        }
    }",0
dubbo-3.2,NULL_DEREFERENCE,dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryProtocol.java,"org.apache.dubbo.registry.integration.RegistryProtocol.registerStatedUrl(org.apache.dubbo.common.URL,org.apache.dubbo.common.URL,boolean):void",235,object `model` last assigned on line 234 could be null and is dereferenced at line 235.,https://github.com/apache/dubbo/blob/3.2/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryProtocol.java,"private static void register(Registry registry, URL registeredProviderUrl) {
        ApplicationDeployer deployer = registeredProviderUrl.getOrDefaultApplicationModel().getDeployer();
        try {
            deployer.increaseServiceRefreshCount();
            String registryName = Optional.ofNullable(registry.getUrl())
                .map(u -> u.getParameter(RegistryConstants.REGISTRY_CLUSTER_KEY,
                    UrlUtils.isServiceDiscoveryURL(u) ? u.getParameter(REGISTRY_KEY) : u.getProtocol()))
                .filter(StringUtils::isNotEmpty)
                .orElse(""unknown"");
            MetricsEventBus.post(RegistryEvent.toRsEvent(registeredProviderUrl.getApplicationModel(), registeredProviderUrl.getServiceKey(), 1, Collections.singletonList(registryName)),
                () -> {
                    registry.register(registeredProviderUrl);
                    return null;
                });
        } finally {
            deployer.decreaseServiceRefreshCount();
        }
    }",1
dubbo-3.2,NULL_DEREFERENCE,dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/ServiceDiscoveryRegistry.java,org.apache.dubbo.registry.client.ServiceDiscoveryRegistry.addRegistryClusterKey(org.apache.dubbo.common.URL):org.apache.dubbo.common.URL,238,object returned by `ServiceDiscoveryRegistry.serviceDiscovery.getUrl()` could be null and is dereferenced at line 238.,"237: private URL addRegistryClusterKey(URL url) {
 238: String registryCluster = serviceDiscovery.getUrl().getParameter(REGISTRY_CLUSTER_KEY);
 239: if (registryCluster != null && url.getParameter(REGISTRY_CLUSTER_KEY) == null) {
 240: url = url.addParameter(REGISTRY_CLUSTER_KEY, registryCluster);
 241: }
 242: return url;","private URL addRegistryClusterKey(URL url) {
        String registryCluster = serviceDiscovery.getUrl().getParameter(REGISTRY_CLUSTER_KEY);
        if (registryCluster != null && url.getParameter(REGISTRY_CLUSTER_KEY) == null) {
            url = url.addParameter(REGISTRY_CLUSTER_KEY, registryCluster);
        }
        return url;
    }",1
dubbo-3.2,NULL_DEREFERENCE,dubbo-common/src/main/java/org/apache/dubbo/common/config/configcenter/file/FileSystemDynamicConfiguration.java,org.apache.dubbo.common.config.configcenter.file.FileSystemDynamicConfiguration.registerDubboShutdownHook():void,264,object `shutdownHookCallbacks` last assigned on line 263 could be null and is dereferenced at line 264.,"259: private void registerDubboShutdownHook() {
 260: if (!hasRegisteredShutdownHook.compareAndSet(false, true)) {
 261: return;
 262: }
 263: ShutdownHookCallbacks shutdownHookCallbacks = ScopeModelUtil.getApplicationModel(scopeModel).getBeanFactory().getBean(ShutdownHookCallbacks.class);
 264: shutdownHookCallbacks.addCallback(() -> {","private void registerDubboShutdownHook() {
        if (!hasRegisteredShutdownHook.compareAndSet(false, true)) {
            return;
        }
        ShutdownHookCallbacks shutdownHookCallbacks = ScopeModelUtil.getApplicationModel(scopeModel).getBeanFactory().getBean(ShutdownHookCallbacks.class);
        shutdownHookCallbacks.addCallback(() -> {
            watchService.ifPresent(w -> {
                try {
                    w.close();
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            });
            getWatchEventsLoopThreadPool().shutdown();
        });
    }",0
dubbo-3.2,NULL_DEREFERENCE,dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/migration/MigrationInvoker.java,org.apache.dubbo.registry.client.migration.MigrationInvoker.invoke(org.apache.dubbo.rpc.Invocation):org.apache.dubbo.rpc.Result,301,object `MigrationInvoker.currentAvailableInvoker` last assigned on line 291 could be null and is dereferenced at line 301.,"275: public Result invoke(Invocation invocation) throws RpcException {
 276: if (currentAvailableInvoker != null) {
 277: if (step == APPLICATION_FIRST) {
 278: // call ratio calculation based on random value
 279: if (promotion < 100 && ThreadLocalRandom.current().nextDouble(100) > promotion) {
 280: // fall back to interface mode
 281: return invoker.invoke(invocation);
 282: }
 283: // check if invoker available for each time
 284: return decideInvoker().invoke(invocation);
 285: }
 286: return currentAvailableInvoker.invoke(invocation);
 287: }
 288: 
 289: switch (step) {
 290: case APPLICATION_FIRST:
 291: currentAvailableInvoker = decideInvoker();
 292: break;
 293: case FORCE_APPLICATION:
 294: currentAvailableInvoker = serviceDiscoveryInvoker;
 295: break;
 296: case FORCE_INTERFACE:
 297: default:
 298: currentAvailableInvoker = invoker;
 299: }
 300: 
 301: return currentAvailableInvoker.invoke(invocation);","public Result invoke(Invocation invocation) throws RpcException {
        if (currentAvailableInvoker != null) {
            if (step == APPLICATION_FIRST) {
                // call ratio calculation based on random value
                if (promotion < 100 && ThreadLocalRandom.current().nextDouble(100) > promotion) {
                    // fall back to interface mode
                    return invoker.invoke(invocation);
                }
                // check if invoker available for each time
                return decideInvoker().invoke(invocation);
            }
            return currentAvailableInvoker.invoke(invocation);
        }

        switch (step) {
            case APPLICATION_FIRST:
                currentAvailableInvoker = decideInvoker();
                break;
            case FORCE_APPLICATION:
                currentAvailableInvoker = serviceDiscoveryInvoker;
                break;
            case FORCE_INTERFACE:
            default:
                currentAvailableInvoker = invoker;
        }

        return currentAvailableInvoker.invoke(invocation);
    }",0
dubbo-3.2,NULL_DEREFERENCE,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/mesh/route/MeshRuleRouter.java,"org.apache.dubbo.rpc.cluster.router.mesh.route.MeshRuleRouter.onRuleChange(java.lang.String,java.util.LinkedList):void",302,object returned by `getDestinationRuleList(vsDestinationGroup)` could be null and is dereferenced at line 302.,"292: public synchronized void onRuleChange(String appName, List<Map<String, Object>> rules) {
 293: // only update specified app's rule
 294: Map<String, VsDestinationGroup> appToVDGroup = new ConcurrentHashMap<>(this.meshRuleCache.getAppToVDGroup());
 295: try {
 296: VsDestinationGroup vsDestinationGroup = new VsDestinationGroup();
 297: vsDestinationGroup.setAppName(appName);
 298: 
 299: for (Map<String, Object> rule : rules) {
 300: if (DESTINATION_RULE_KEY.equals(rule.get(KIND_KEY))) {
 301: DestinationRule destinationRule = PojoUtils.mapToPojo(rule, DestinationRule.class);
 302: vsDestinationGroup.getDestinationRuleList().add(destinationRule);
 303: } else if (VIRTUAL_SERVICE_KEY.equals(rule.get(KIND_KEY))) {
 304: VirtualServiceRule virtualServiceRule = PojoUtils.mapToPojo(rule, VirtualServiceRule.class);
 305: vsDestinationGroup.getVirtualServiceRuleList().add(virtualServiceRule);
 306: }
 307: }
 308: if (vsDestinationGroup.isValid()) {
 309: appToVDGroup.put(appName, vsDestinationGroup);
 310: }
 311: } catch (Throwable t) {
 312: logger.error(CLUSTER_FAILED_RECEIVE_RULE,""failed to parse mesh route rule"","""",""Error occurred when parsing rule component."",t);
 313: }
 314: 
 315: computeSubset(appToVDGroup);","public synchronized void onRuleChange(String appName, List<Map<String, Object>> rules) {
        // only update specified app's rule
        Map<String, VsDestinationGroup> appToVDGroup = new ConcurrentHashMap<>(this.meshRuleCache.getAppToVDGroup());
        try {
            VsDestinationGroup vsDestinationGroup = new VsDestinationGroup();
            vsDestinationGroup.setAppName(appName);

            for (Map<String, Object> rule : rules) {
                if (DESTINATION_RULE_KEY.equals(rule.get(KIND_KEY))) {
                    DestinationRule destinationRule = PojoUtils.mapToPojo(rule, DestinationRule.class);
                    vsDestinationGroup.getDestinationRuleList().add(destinationRule);
                } else if (VIRTUAL_SERVICE_KEY.equals(rule.get(KIND_KEY))) {
                    VirtualServiceRule virtualServiceRule = PojoUtils.mapToPojo(rule, VirtualServiceRule.class);
                    vsDestinationGroup.getVirtualServiceRuleList().add(virtualServiceRule);
                }
            }
            if (vsDestinationGroup.isValid()) {
                appToVDGroup.put(appName, vsDestinationGroup);
            }
        } catch (Throwable t) {
            logger.error(CLUSTER_FAILED_RECEIVE_RULE,""failed to parse mesh route rule"","""",""Error occurred when parsing rule component."",t);
        }

        computeSubset(appToVDGroup);
    }",1
dubbo-3.2,NULL_DEREFERENCE,dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/mesh/route/MeshRuleRouter.java,"org.apache.dubbo.rpc.cluster.router.mesh.route.MeshRuleRouter.onRuleChange(java.lang.String,java.util.LinkedList):void",305,object returned by `getVirtualServiceRuleList(vsDestinationGroup)` could be null and is dereferenced at line 305.,"292: public synchronized void onRuleChange(String appName, List<Map<String, Object>> rules) {
 293: // only update specified app's rule
 294: Map<String, VsDestinationGroup> appToVDGroup = new ConcurrentHashMap<>(this.meshRuleCache.getAppToVDGroup());
 295: try {
 296: VsDestinationGroup vsDestinationGroup = new VsDestinationGroup();
 297: vsDestinationGroup.setAppName(appName);
 298: 
 299: for (Map<String, Object> rule : rules) {
 300: if (DESTINATION_RULE_KEY.equals(rule.get(KIND_KEY))) {
 301: DestinationRule destinationRule = PojoUtils.mapToPojo(rule, DestinationRule.class);
 302: vsDestinationGroup.getDestinationRuleList().add(destinationRule);
 303: } else if (VIRTUAL_SERVICE_KEY.equals(rule.get(KIND_KEY))) {
 304: VirtualServiceRule virtualServiceRule = PojoUtils.mapToPojo(rule, VirtualServiceRule.class);
 305: vsDestinationGroup.getVirtualServiceRuleList().add(virtualServiceRule);
 306: }
 307: }
 308: if (vsDestinationGroup.isValid()) {
 309: appToVDGroup.put(appName, vsDestinationGroup);
 310: }
 311: } catch (Throwable t) {
 312: logger.error(CLUSTER_FAILED_RECEIVE_RULE,""failed to parse mesh route rule"","""",""Error occurred when parsing rule component."",t);
 313: }
 314: 
 315: computeSubset(appToVDGroup);","public synchronized void onRuleChange(String appName, List<Map<String, Object>> rules) {
        // only update specified app's rule
        Map<String, VsDestinationGroup> appToVDGroup = new ConcurrentHashMap<>(this.meshRuleCache.getAppToVDGroup());
        try {
            VsDestinationGroup vsDestinationGroup = new VsDestinationGroup();
            vsDestinationGroup.setAppName(appName);

            for (Map<String, Object> rule : rules) {
                if (DESTINATION_RULE_KEY.equals(rule.get(KIND_KEY))) {
                    DestinationRule destinationRule = PojoUtils.mapToPojo(rule, DestinationRule.class);
                    vsDestinationGroup.getDestinationRuleList().add(destinationRule);
                } else if (VIRTUAL_SERVICE_KEY.equals(rule.get(KIND_KEY))) {
                    VirtualServiceRule virtualServiceRule = PojoUtils.mapToPojo(rule, VirtualServiceRule.class);
                    vsDestinationGroup.getVirtualServiceRuleList().add(virtualServiceRule);
                }
            }
            if (vsDestinationGroup.isValid()) {
                appToVDGroup.put(appName, vsDestinationGroup);
            }
        } catch (Throwable t) {
            logger.error(CLUSTER_FAILED_RECEIVE_RULE,""failed to parse mesh route rule"","""",""Error occurred when parsing rule component."",t);
        }

        computeSubset(appToVDGroup);
    }",1
dubbo-3.2,NULL_DEREFERENCE,dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/deploy/DefaultApplicationDeployer.java,org.apache.dubbo.config.deploy.DefaultApplicationDeployer.startMetadataCenter():void,328,object `metadataReportInstance` last assigned on line 320 could be null and is dereferenced at line 328.,"304: private void startMetadataCenter() {
 305: 
 306: useRegistryAsMetadataCenterIfNecessary();
 307: 
 308: ApplicationConfig applicationConfig = getApplication();
 309: 
 310: String metadataType = applicationConfig.getMetadataType();
 311: // FIXME, multiple metadata config support.
 312: Collection<MetadataReportConfig> metadataReportConfigs = configManager.getMetadataConfigs();
 313: if (CollectionUtils.isEmpty(metadataReportConfigs)) {
 314: if (REMOTE_METADATA_STORAGE_TYPE.equals(metadataType)) {
 315: throw new IllegalStateException(""No MetadataConfig found, Metadata Center address is required when 'metadata=remote' is enabled."");
 316: }
 317: return;
 318: }
 319: 
 320: MetadataReportInstance metadataReportInstance = applicationModel.getBeanFactory().getBean(MetadataReportInstance.class);
 321: List<MetadataReportConfig> validMetadataReportConfigs = new ArrayList<>(metadataReportConfigs.size());
 322: for (MetadataReportConfig metadataReportConfig : metadataReportConfigs) {
 323: if (ConfigValidationUtils.isValidMetadataConfig(metadataReportConfig)) {
 324: ConfigValidationUtils.validateMetadataConfig(metadataReportConfig);
 325: validMetadataReportConfigs.add(metadataReportConfig);
 326: }
 327: }
 328: metadataReportInstance.init(validMetadataReportConfigs);
 329: if (!metadataReportInstance.inited()) {","private void startMetadataCenter() {

        useRegistryAsMetadataCenterIfNecessary();

        ApplicationConfig applicationConfig = getApplication();

        String metadataType = applicationConfig.getMetadataType();
        // FIXME, multiple metadata config support.
        Collection<MetadataReportConfig> metadataReportConfigs = configManager.getMetadataConfigs();
        if (CollectionUtils.isEmpty(metadataReportConfigs)) {
            if (REMOTE_METADATA_STORAGE_TYPE.equals(metadataType)) {
                throw new IllegalStateException(""No MetadataConfig found, Metadata Center address is required when 'metadata=remote' is enabled."");
            }
            return;
        }

        MetadataReportInstance metadataReportInstance = applicationModel.getBeanFactory().getBean(MetadataReportInstance.class);
        List<MetadataReportConfig> validMetadataReportConfigs = new ArrayList<>(metadataReportConfigs.size());
        for (MetadataReportConfig metadataReportConfig : metadataReportConfigs) {
            if (ConfigValidationUtils.isValidMetadataConfig(metadataReportConfig)) {
                ConfigValidationUtils.validateMetadataConfig(metadataReportConfig);
                validMetadataReportConfigs.add(metadataReportConfig);
            }
        }
        metadataReportInstance.init(validMetadataReportConfigs);
        if (!metadataReportInstance.inited()) {
            throw new IllegalStateException(String.format(""%s MetadataConfigs found, but none of them is valid."", metadataReportConfigs.size()));
        }
    }",1
dubbo-3.2,NULL_DEREFERENCE,dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/CallbackServiceCodec.java,"org.apache.dubbo.rpc.protocol.dubbo.CallbackServiceCodec.encodeInvocationArgument(org.apache.dubbo.remoting.Channel,org.apache.dubbo.rpc.RpcInvocation,int):java.lang.Object",316,object `args` last assigned on line 312 could be null and is dereferenced at line 316.,https://github.com/apache/dubbo/blob/3.2/dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/CallbackServiceCodec.java,"private static void decreaseInstanceCount(Channel channel, String countkey) {
        try {
            Integer count = (Integer) channel.getAttribute(countkey);
            if (count == null || count <= 0) {
                return;
            } else {
                count--;
            }
            channel.setAttribute(countkey, count);
        } catch (Exception e) {
            logger.error(COMMON_PROPERTY_TYPE_MISMATCH, """", """", e.getMessage(), e);
        }
    }",0
dubbo-3.2,NULL_DEREFERENCE,dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/protocol/AbstractInvoker.java,"org.apache.dubbo.rpc.protocol.AbstractInvoker.getCallbackExecutor(org.apache.dubbo.common.URL,org.apache.dubbo.rpc.Invocation):java.util.concurrent.ExecutorService",316,object returned by `getInstance(url.getOrDefaultApplicationModel())` could be null and is dereferenced at line 316.,"312: protected ExecutorService getCallbackExecutor(URL url, Invocation inv) {
 313: if (InvokeMode.SYNC == RpcUtils.getInvokeMode(getUrl(), inv)) {
 314: return new ThreadlessExecutor();
 315: }
 316: return ExecutorRepository.getInstance(url.getOrDefaultApplicationModel()).getExecutor(url);","protected ExecutorService getCallbackExecutor(URL url, Invocation inv) {
        if (InvokeMode.SYNC == RpcUtils.getInvokeMode(getUrl(), inv)) {
            return new ThreadlessExecutor();
        }
        return ExecutorRepository.getInstance(url.getOrDefaultApplicationModel()).getExecutor(url);
    }",1
dubbo-3.2,NULL_DEREFERENCE,dubbo-common/src/main/java/org/apache/dubbo/common/utils/ClassUtils.java,"org.apache.dubbo.common.utils.ClassUtils.convertPrimitive(org.apache.dubbo.rpc.model.FrameworkModel,java.lang.Class,java.lang.String):java.lang.Object",342,object returned by `frameworkModel.getBeanFactory().getBean(org.apache.dubbo.common.convert.ConverterUtil)` could be null and is dereferenced at line 342.,"335: public static Object convertPrimitive(FrameworkModel frameworkModel, Class<?> type, String value) {
 336: if (isEmpty(value)) {
 337: return null;
 338: }
 339: Class<?> wrapperType = WRAPPER_PRIMITIVE_TYPE_MAP.getOrDefault(type, type);
 340: Object result = null;
 341: try {
 342: result = frameworkModel.getBeanFactory().getBean(ConverterUtil.class).convertIfPossible(value, wrapperType);
 343: } catch (Exception e) {
 344: // ignore exception
 345: }
 346: return result;","public static Object convertPrimitive(FrameworkModel frameworkModel, Class<?> type, String value) {
        if (isEmpty(value)) {
            return null;
        }
        Class<?> wrapperType = WRAPPER_PRIMITIVE_TYPE_MAP.getOrDefault(type, type);
        Object result = null;
        try {
            result = frameworkModel.getBeanFactory().getBean(ConverterUtil.class).convertIfPossible(value, wrapperType);
        } catch (Exception e) {
            // ignore exception
        }
        return result;
    }",1
dubbo-3.2,NULL_DEREFERENCE,dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java,org.apache.dubbo.config.ServiceConfig.doDelayExport():void,354,object returned by `getDelay()` could be null and is dereferenced at line 354.,https://github.com/apache/dubbo/blob/3.2/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java,"protected void doDelayExport() {
        ExecutorRepository.getInstance(getScopeModel().getApplicationModel()).getServiceExportExecutor()
            .schedule(() -> {
                try {
                    doExport(RegisterTypeEnum.AUTO_REGISTER);
                } catch (Exception e) {
                    logger.error(CONFIG_FAILED_EXPORT_SERVICE, ""configuration server disconnected"", """", ""Failed to (async)export service config: "" + interfaceName, e);
                }
            }, getDelay(), TimeUnit.MILLISECONDS);
    }",0
dubbo-3.2,NULL_DEREFERENCE,dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java,org.apache.dubbo.config.ServiceConfig.doDelayExport():void,347,object returned by `getInstance(getScopeModel().getApplicationModel())` could be null and is dereferenced at line 347.,"346: protected void doDelayExport() {
 347: ExecutorRepository.getInstance(getScopeModel().getApplicationModel()).getServiceExportExecutor()","public void register(boolean byDeployer) {
        if (!this.exported) {
            return;
        }

        synchronized (this) {
            if (!this.exported) {
                return;
            }

            for (Exporter<?> exporter : exporters.getOrDefault(RegisterTypeEnum.AUTO_REGISTER, Collections.emptyList())) {
                exporter.register();
            }

            if (byDeployer) {
                for (Exporter<?> exporter : exporters.getOrDefault(RegisterTypeEnum.AUTO_REGISTER_BY_DEPLOYER, Collections.emptyList())) {
                    exporter.register();
                }
            }
        }
    }",1
dubbo-3.2,NULL_DEREFERENCE,dubbo-registry/dubbo-registry-nacos/src/main/java/org/apache/dubbo/registry/nacos/NacosRegistry.java,org.apache.dubbo.registry.nacos.NacosRegistry.filterServiceNames(org.apache.dubbo.registry.nacos.NacosServiceName):java.util.Set,350,"object returned by `NacosRegistry.namingService.getServicesOfServer(1,2147483647,getUrl().getGroup(""DEFAULT_GROUP""))` could be null and is dereferenced at line 350.",https://github.com/apache/dubbo/blob/3.2/dubbo-registry/dubbo-registry-nacos/src/main/java/org/apache/dubbo/registry/nacos/NacosRegistry.java,"private Set<String> getServiceNames0(URL url) {
        NacosServiceName serviceName = createServiceName(url);

        final Set<String> serviceNames;

        if (serviceName.isConcrete()) { // is the concrete service name
            serviceNames = new LinkedHashSet<>();
            serviceNames.add(serviceName.toString());
            if (supportLegacyServiceName) {
                // Add the legacy service name since 2.7.6
                String legacySubscribedServiceName = getLegacySubscribedServiceName(url);
                if (!serviceName.toString().equals(legacySubscribedServiceName)) {
                    //avoid duplicated service names
                    serviceNames.add(legacySubscribedServiceName);
                }
            }
        } else {
            serviceNames = filterServiceNames(serviceName);
        }

        return serviceNames;
    }",1
dubbo-3.2,NULL_DEREFERENCE,dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java,org.apache.dubbo.config.ServiceConfig.lambda$exported$1(org.apache.dubbo.common.URL):void,364,object returned by `getScopeModel().getBeanFactory().getBean(org.apache.dubbo.common.threadpool.manager.FrameworkExecutorRepository)` could be null and is dereferenced at line 364.,"357: protected void exported() {
 358: exported = true;
 359: List<URL> exportedURLs = this.getExportedUrls();
 360: exportedURLs.forEach(url -> {
 361: if (url.getParameters().containsKey(SERVICE_NAME_MAPPING_KEY)) {
 362: ServiceNameMapping serviceNameMapping = ServiceNameMapping.getDefaultExtension(getScopeModel());
 363: ScheduledExecutorService scheduledExecutor = getScopeModel().getBeanFactory()
 364: .getBean(FrameworkExecutorRepository.class).getSharedScheduledExecutor();
 365: mapServiceName(url, serviceNameMapping, scheduledExecutor);
 366: }
 367: });
 368: onExported();","protected void exported() {
        exported = true;
        List<URL> exportedURLs = this.getExportedUrls();
        exportedURLs.forEach(url -> {
            if (url.getParameters().containsKey(SERVICE_NAME_MAPPING_KEY)) {
                ServiceNameMapping serviceNameMapping = ServiceNameMapping.getDefaultExtension(getScopeModel());
                ScheduledExecutorService scheduledExecutor = getScopeModel().getBeanFactory()
                    .getBean(FrameworkExecutorRepository.class).getSharedScheduledExecutor();
                mapServiceName(url, serviceNameMapping, scheduledExecutor);
            }
        });
        onExported();
    }",0
dubbo-3.2,NULL_DEREFERENCE,dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/deploy/DefaultApplicationDeployer.java,org.apache.dubbo.config.deploy.DefaultApplicationDeployer.initMetricsService():void,371,object `DefaultApplicationDeployer.metricsServiceExporter` last assigned on line 370 could be null and is dereferenced at line 371.,"369: private void initMetricsService() {
 370: this.metricsServiceExporter = getExtensionLoader(MetricsServiceExporter.class).getDefaultExtension();
 371: metricsServiceExporter.init();","private void initMetricsService() {
        this.metricsServiceExporter = getExtensionLoader(MetricsServiceExporter.class).getDefaultExtension();
        metricsServiceExporter.init();
    }",1
dubbo-3.2,NULL_DEREFERENCE,dubbo-common/src/main/java/org/apache/dubbo/common/utils/NetUtils.java,org.apache.dubbo.common.utils.NetUtils.getLocalAddress0():java.net.InetAddress,376,object `networkInterface` last assigned on line 375 could be null and is dereferenced at line 376.,"370: private static InetAddress getLocalAddress0() {
 371: InetAddress localAddress = null;
 372: 
 373: // @since 2.7.6, choose the {@link NetworkInterface} first
 374: try {
 375: NetworkInterface networkInterface = findNetworkInterface();
 376: Enumeration<InetAddress> addresses = networkInterface.getInetAddresses();
 377: while (addresses.hasMoreElements()) {
 378: Optional<InetAddress> addressOp = toValidAddress(addresses.nextElement());
 379: if (addressOp.isPresent()) {
 380: try {
 381: if (addressOp.get().isReachable(100)) {
 382: return addressOp.get();
 383: }
 384: } catch (IOException e) {
 385: // ignore
 386: }
 387: }
 388: }
 389: } catch (Throwable e) {
 390: logger.warn(e);
 391: }
 392: 
 393: try {
 394: localAddress = InetAddress.getLocalHost();
 395: Optional<InetAddress> addressOp = toValidAddress(localAddress);
 396: if (addressOp.isPresent()) {
 397: return addressOp.get();
 398: }
 399: } catch (Throwable e) {
 400: logger.warn(e);
 401: }
 402: 
 403: localAddress = getLocalAddressV6();
 404: 
 405: return localAddress;","private static InetAddress getLocalAddress0() {
        InetAddress localAddress = null;

        // @since 2.7.6, choose the {@link NetworkInterface} first
        try {
            NetworkInterface networkInterface = findNetworkInterface();
            Enumeration<InetAddress> addresses = networkInterface.getInetAddresses();
            while (addresses.hasMoreElements()) {
                Optional<InetAddress> addressOp = toValidAddress(addresses.nextElement());
                if (addressOp.isPresent()) {
                    try {
                        if (addressOp.get().isReachable(100)) {
                            return addressOp.get();
                        }
                    } catch (IOException e) {
                        // ignore
                    }
                }
            }
        } catch (Throwable e) {
            logger.warn(e);
        }

        try {
            localAddress = InetAddress.getLocalHost();
            Optional<InetAddress> addressOp = toValidAddress(localAddress);
            if (addressOp.isPresent()) {
                return addressOp.get();
            }
        } catch (Throwable e) {
            logger.warn(e);
        }

        localAddress = getLocalAddressV6();

        return localAddress;
    }
",0
dubbo-3.2,NULL_DEREFERENCE,dubbo-common/src/main/java/org/apache/dubbo/rpc/model/ApplicationModel.java,org.apache.dubbo.rpc.model.ApplicationModel.getProviderModel(java.lang.String):org.apache.dubbo.rpc.model.ProviderModel,381,object returned by `defaultModel().getDefaultModule().getServiceRepository()` could be null and is dereferenced at line 381.,"380: public static ProviderModel getProviderModel(String serviceKey) {
 381: return defaultModel().getDefaultModule().getServiceRepository().lookupExportedService(serviceKey);","public static ProviderModel getProviderModel(String serviceKey) {
        return defaultModel().getDefaultModule().getServiceRepository().lookupExportedService(serviceKey);
    }
",1
dubbo-3.2,NULL_DEREFERENCE,dubbo-common/src/main/java/org/apache/dubbo/rpc/model/ApplicationModel.java,org.apache.dubbo.rpc.model.ApplicationModel.getConsumerModel(java.lang.String):org.apache.dubbo.rpc.model.ConsumerModel,389,object returned by `defaultModel().getDefaultModule().getServiceRepository()` could be null and is dereferenced at line 389.,"388: public static ConsumerModel getConsumerModel(String serviceKey) {
 389: return defaultModel().getDefaultModule().getServiceRepository().lookupReferredService(serviceKey);","public static ConsumerModel getConsumerModel(String serviceKey) {
        return defaultModel().getDefaultModule().getServiceRepository().lookupReferredService(serviceKey);
    }",1
dubbo-3.2,NULL_DEREFERENCE,dubbo-common/src/main/java/org/apache/dubbo/common/utils/NetUtils.java,org.apache.dubbo.common.utils.NetUtils.getLocalAddress0V6():java.net.Inet6Address,412,object `networkInterface` last assigned on line 411 could be null and is dereferenced at line 412.,"408: private static Inet6Address getLocalAddress0V6() {
 409: // @since 2.7.6, choose the {@link NetworkInterface} first
 410: try {
 411: NetworkInterface networkInterface = findNetworkInterface();
 412: Enumeration<InetAddress> addresses = networkInterface.getInetAddresses();
 413: while (addresses.hasMoreElements()) {
 414: InetAddress address = addresses.nextElement();
 415: if (address instanceof Inet6Address) {
 416: if (!address.isLoopbackAddress() //filter ::1
 417: && !address.isAnyLocalAddress() // filter ::/128
 418: && !address.isLinkLocalAddress() //filter fe80::/10
 419: && !address.isSiteLocalAddress()// filter fec0::/10
 420: && !isUniqueLocalAddress(address) //filter fd00::/8
 421: && address.getHostAddress().contains("":"")) {//filter IPv6
 422: return (Inet6Address) address;
 423: }
 424: }
 425: }
 426: } catch (Throwable e) {
 427: logger.warn(e);
 428: }
 429: 
 430: return null;","private static Inet6Address getLocalAddress0V6() {
        // @since 2.7.6, choose the {@link NetworkInterface} first
        try {
            NetworkInterface networkInterface = findNetworkInterface();
            Enumeration<InetAddress> addresses = networkInterface.getInetAddresses();
            while (addresses.hasMoreElements()) {
                InetAddress address = addresses.nextElement();
                if (address instanceof Inet6Address) {
                    if (!address.isLoopbackAddress() //filter ::1
                        && !address.isAnyLocalAddress() // filter ::/128
                        && !address.isLinkLocalAddress() //filter fe80::/10
                        && !address.isSiteLocalAddress()// filter fec0::/10
                        && !isUniqueLocalAddress(address) //filter fd00::/8
                        && address.getHostAddress().contains("":"")) {//filter IPv6
                        return (Inet6Address) address;
                    }
                }
            }
        } catch (Throwable e) {
            logger.warn(e);
        }

        return null;
    }",0
dubbo-3.2,NULL_DEREFERENCE,dubbo-kubernetes/src/main/java/org/apache/dubbo/registry/kubernetes/KubernetesServiceDiscovery.java,"org.apache.dubbo.registry.kubernetes.KubernetesServiceDiscovery.lambda$toServiceInstance$9(java.lang.String,java.lang.String,io.fabric8.kubernetes.api.model.Pod,java.util.List,io.fabric8.kubernetes.api.model.EndpointAddress,java.lang.Integer):void",419,object returned by `getMetadata(serviceInstance)` could be null and is dereferenced at line 419.,"378: private List<ServiceInstance> toServiceInstance(Endpoints endpoints, String serviceName) {
 379: Map<String, String> serviceSelector = getServiceSelector(serviceName);
 380: if (serviceSelector == null) {
 381: return new LinkedList<>();
 382: }
 383: Map<String, Pod> pods = kubernetesClient
 384: .pods()
 385: .inNamespace(namespace)
 386: .withLabels(serviceSelector)
 387: .list()
 388: .getItems()
 389: .stream()
 390: .collect(
 391: Collectors.toMap(
 392: pod -> pod.getMetadata().getName(),
 393: pod -> pod));
 394: 
 395: List<ServiceInstance> instances = new LinkedList<>();
 396: Set<Integer> instancePorts = new HashSet<>();
 397: 
 398: for (EndpointSubset endpointSubset : endpoints.getSubsets()) {
 399: instancePorts.addAll(
 400: endpointSubset.getPorts()
 401: .stream().map(EndpointPort::getPort)
 402: .collect(Collectors.toSet()));
 403: }
 404: 
 405: for (EndpointSubset endpointSubset : endpoints.getSubsets()) {
 406: for (EndpointAddress address : endpointSubset.getAddresses()) {
 407: Pod pod = pods.get(address.getTargetRef().getName());
 408: String ip = address.getIp();
 409: if (pod == null) {
 410: logger.warn(REGISTRY_UNABLE_MATCH_KUBERNETES, """", """", ""Unable to match Kubernetes Endpoint address with Pod. "" +
 411: ""EndpointAddress Hostname: "" + address.getTargetRef().getName());
 412: continue;
 413: }
 414: instancePorts.forEach(port -> {
 415: ServiceInstance serviceInstance = new DefaultServiceInstance(serviceName, ip, port, ScopeModelUtil.getApplicationModel(getUrl().getScopeModel()));
 416: 
 417: String properties = pod.getMetadata().getAnnotations().get(KUBERNETES_PROPERTIES_KEY);
 418: if (StringUtils.isNotEmpty(properties)) {
 419: serviceInstance.getMetadata().putAll(JsonUtils.toJavaObject(properties, Map.class));
 420: instances.add(serviceInstance);
 421: } else {
 422: logger.warn(REGISTRY_UNABLE_FIND_SERVICE_KUBERNETES, """", """", ""Unable to find Service Instance metadata in Pod Annotations. "" +
 423: ""Possibly cause: provider has not been initialized successfully. "" +
 424: ""EndpointAddress Hostname: "" + address.getTargetRef().getName());
 425: }
 426: });
 427: }
 428: }
 429: 
 430: return instances;","private List<ServiceInstance> toServiceInstance(Endpoints endpoints, String serviceName) {
        Map<String, String> serviceSelector = getServiceSelector(serviceName);
        if (serviceSelector == null) {
            return new LinkedList<>();
        }
        Map<String, Pod> pods = kubernetesClient
                .pods()
                .inNamespace(namespace)
                .withLabels(serviceSelector)
                .list()
                .getItems()
                .stream()
                .collect(
                        Collectors.toMap(
                                pod -> pod.getMetadata().getName(),
                                pod -> pod));

        List<ServiceInstance> instances = new LinkedList<>();
        Set<Integer> instancePorts = new HashSet<>();

        for (EndpointSubset endpointSubset : endpoints.getSubsets()) {
            instancePorts.addAll(
                    endpointSubset.getPorts()
                            .stream().map(EndpointPort::getPort)
                            .collect(Collectors.toSet()));
        }

        for (EndpointSubset endpointSubset : endpoints.getSubsets()) {
            for (EndpointAddress address : endpointSubset.getAddresses()) {
                Pod pod = pods.get(address.getTargetRef().getName());
                String ip = address.getIp();
                if (pod == null) {
                    logger.warn(REGISTRY_UNABLE_MATCH_KUBERNETES, """", """", ""Unable to match Kubernetes Endpoint address with Pod. "" +
                        ""EndpointAddress Hostname: "" + address.getTargetRef().getName());
                    continue;
                }
                instancePorts.forEach(port -> {
                    ServiceInstance serviceInstance = new DefaultServiceInstance(serviceName, ip, port, ScopeModelUtil.getApplicationModel(getUrl().getScopeModel()));

                    String properties = pod.getMetadata().getAnnotations().get(KUBERNETES_PROPERTIES_KEY);
                    if (StringUtils.isNotEmpty(properties)) {
                        serviceInstance.getMetadata().putAll(JsonUtils.toJavaObject(properties, Map.class));
                        instances.add(serviceInstance);
                    } else {
                        logger.warn(REGISTRY_UNABLE_FIND_SERVICE_KUBERNETES, """", """", ""Unable to find Service Instance metadata in Pod Annotations. "" +
                                ""Possibly cause: provider has not been initialized successfully. "" +
                                ""EndpointAddress Hostname: "" + address.getTargetRef().getName());
                    }
                });
            }
        }

        return instances;
    }",0
dubbo-3.2,NULL_DEREFERENCE,dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryProtocol.java,"org.apache.dubbo.registry.integration.RegistryProtocol.lambda$getStatedUrl$7(org.apache.dubbo.common.URL,org.apache.dubbo.common.URL,org.apache.dubbo.rpc.model.ProviderModel$RegisterStatedURL):boolean",420,object returned by `u.getProviderUrl().getProtocol()` could be null and is dereferenced at line 420.,https://github.com/apache/dubbo/blob/3.2/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryProtocol.java,"private <T> void doReExport(final Invoker<T> originInvoker, ExporterChangeableWrapper<T> exporter,
                                URL registryUrl, URL oldProviderUrl, URL newProviderUrl) {
        if (exporter.isRegistered()) {
            Registry registry;
            try {
                registry = getRegistry(getRegistryUrl(originInvoker));
            } catch (Exception e) {
                throw new SkipFailbackWrapperException(e);
            }

            logger.info(""Try to unregister old url: "" + oldProviderUrl);
            registry.reExportUnregister(oldProviderUrl);

            logger.info(""Try to register new url: "" + newProviderUrl);
            registry.reExportRegister(newProviderUrl);
        }
        try {
            ProviderModel.RegisterStatedURL statedUrl = getStatedUrl(registryUrl, newProviderUrl);
            statedUrl.setProviderUrl(newProviderUrl);
            exporter.setRegisterUrl(newProviderUrl);
        } catch (Exception e) {
            throw new SkipFailbackWrapperException(e);
        }
    }",0
dubbo-3.2,NULL_DEREFERENCE,dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/client/event/listener/ServiceInstancesChangedListener.java,org.apache.dubbo.registry.client.event.listener.ServiceInstancesChangedListener.toUrlsWithEmpty(java.util.List):java.util.List,430,object returned by `ServiceInstancesChangedListener.serviceDiscovery.getUrl()` could be null and is dereferenced at line 430.,"429: protected List<URL> toUrlsWithEmpty(List<URL> urls) {
 430: boolean emptyProtectionEnabled = serviceDiscovery.getUrl().getParameter(ENABLE_EMPTY_PROTECTION_KEY, DEFAULT_ENABLE_EMPTY_PROTECTION);
 431: if (!emptyProtectionEnabled && urls == null) {
 432: urls = new ArrayList<>();
 433: } else if (emptyProtectionEnabled && urls == null) {
 434: urls = Collections.emptyList();
 435: }
 436: 
 437: if (CollectionUtils.isEmpty(urls) && !emptyProtectionEnabled) {
 438: // notice that the service of this.url may not be the same as notify listener.
 439: URL empty = URLBuilder.from(serviceDiscovery.getUrl()).setProtocol(EMPTY_PROTOCOL).build();
 440: urls.add(empty);
 441: }
 442: return urls;","protected List<URL> toUrlsWithEmpty(List<URL> urls) {
        boolean emptyProtectionEnabled = serviceDiscovery.getUrl().getParameter(ENABLE_EMPTY_PROTECTION_KEY, DEFAULT_ENABLE_EMPTY_PROTECTION);
        if (!emptyProtectionEnabled && urls == null) {
            urls = new ArrayList<>();
        } else if (emptyProtectionEnabled && urls == null) {
            urls = Collections.emptyList();
        }

        if (CollectionUtils.isEmpty(urls) && !emptyProtectionEnabled) {
            // notice that the service of this.url may not be the same as notify listener.
            URL empty = URLBuilder.from(serviceDiscovery.getUrl()).setProtocol(EMPTY_PROTOCOL).build();
            urls.add(empty);
        }
        return urls;
    }",0
dubbo-3.2,NULL_DEREFERENCE,dubbo-registry/dubbo-registry-nacos/src/main/java/org/apache/dubbo/registry/nacos/NacosRegistry.java,org.apache.dubbo.registry.nacos.NacosRegistry.getAllServiceNames():java.util.Set,442,object `listView` last assigned on line 439 could be null and is dereferenced at line 442.,https://github.com/apache/dubbo/blob/3.2/dubbo-registry/dubbo-registry-nacos/src/main/java/org/apache/dubbo/registry/nacos/NacosRegistry.java,"private Set<String> getServiceNamesForOps(URL url) {
        Set<String> serviceNames = getAllServiceNames();
        filterServiceNames(serviceNames, url);
        return serviceNames;
    }",0
dubbo-3.2,NULL_DEREFERENCE,dubbo-common/src/main/java/org/apache/dubbo/common/beanutil/JavaBeanSerializeUtil.java,"org.apache.dubbo.common.beanutil.JavaBeanSerializeUtil.name2Class(java.lang.ClassLoader,java.lang.String):java.lang.Class",468,object returned by `getInstance()` could be null and is dereferenced at line 468.,"448: public static Class<?> name2Class(ClassLoader loader, String name) throws ClassNotFoundException {
 449: if (TYPES.containsKey(name)) {
 450: return TYPES.get(name);
 451: }
 452: if (isArray(name)) {
 453: int dimension = 0;
 454: while (isArray(name)) {
 455: ++dimension;
 456: name = name.substring(1);
 457: }
 458: Class type = name2Class(loader, name);
 459: int[] dimensions = new int[dimension];
 460: for (int i = 0; i < dimension; i++) {
 461: dimensions[i] = 0;
 462: }
 463: return Array.newInstance(type, dimensions).getClass();
 464: }
 465: if (isReferenceType(name)) {
 466: name = name.substring(1, name.length() - 1);
 467: }
 468: return DefaultSerializeClassChecker.getInstance().loadClass(loader, name);","public static Class<?> name2Class(ClassLoader loader, String name) throws ClassNotFoundException {
        if (TYPES.containsKey(name)) {
            return TYPES.get(name);
        }
        if (isArray(name)) {
            int dimension = 0;
            while (isArray(name)) {
                ++dimension;
                name = name.substring(1);
            }
            Class type = name2Class(loader, name);
            int[] dimensions = new int[dimension];
            for (int i = 0; i < dimension; i++) {
                dimensions[i] = 0;
            }
            return Array.newInstance(type, dimensions).getClass();
        }
        if (isReferenceType(name)) {
            name = name.substring(1, name.length() - 1);
        }
        return DefaultSerializeClassChecker.getInstance().loadClass(loader, name);
    }",0
dubbo-3.2,NULL_DEREFERENCE,dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryDirectory.java,"org.apache.dubbo.registry.integration.RegistryDirectory.checkProtocolValid(java.lang.String,org.apache.dubbo.common.URL):boolean",459,object returned by `providerUrl.getProtocol()` could be null and is dereferenced at line 459.,"452: private boolean checkProtocolValid(String queryProtocols, URL providerUrl) {
 453: // If protocol is configured at the reference side, only the matching protocol is selected
 454: if (queryProtocols != null && queryProtocols.length() > 0) {
 455: boolean accept = false;
 456: 
 457: String[] acceptProtocols = queryProtocols.split("","");
 458: for (String acceptProtocol : acceptProtocols) {
 459: if (providerUrl.getProtocol().equals(acceptProtocol)) {
 460: accept = true;
 461: break;
 462: }
 463: }
 464: 
 465: if (!accept) {
 466: return false;
 467: }
 468: }
 469: 
 470: if (EMPTY_PROTOCOL.equals(providerUrl.getProtocol())) {
 471: return false;
 472: }
 473: 
 474: if (!getUrl().getOrDefaultFrameworkModel().getExtensionLoader(Protocol.class).hasExtension(providerUrl.getProtocol())) {
 475: 
 476: // 4-1 - Unsupported protocol
 477: 
 478: logger.error(PROTOCOL_UNSUPPORTED, ""protocol extension does not installed"", """", ""Unsupported protocol."",
 479: new IllegalStateException(""Unsupported protocol "" + providerUrl.getProtocol() +
 480: "" in notified url: "" + providerUrl + "" from registry "" + getUrl().getAddress() +
 481: "" to consumer "" + NetUtils.getLocalHost() + "", supported protocol: "" +
 482: getUrl().getOrDefaultFrameworkModel().getExtensionLoader(Protocol.class).getSupportedExtensions()));
 483: 
 484: return false;
 485: }
 486: 
 487: return true;","private boolean checkProtocolValid(String queryProtocols, URL providerUrl) {
        // If protocol is configured at the reference side, only the matching protocol is selected
        if (queryProtocols != null && queryProtocols.length() > 0) {
            boolean accept = false;

            String[] acceptProtocols = queryProtocols.split("","");
            for (String acceptProtocol : acceptProtocols) {
                if (providerUrl.getProtocol().equals(acceptProtocol)) {
                    accept = true;
                    break;
                }
            }

            if (!accept) {
                return false;
            }
        }

        if (EMPTY_PROTOCOL.equals(providerUrl.getProtocol())) {
            return false;
        }

        if (!getUrl().getOrDefaultFrameworkModel().getExtensionLoader(Protocol.class).hasExtension(providerUrl.getProtocol())) {

            // 4-1 - Unsupported protocol

            logger.error(PROTOCOL_UNSUPPORTED, ""protocol extension does not installed"", """", ""Unsupported protocol."",
                new IllegalStateException(""Unsupported protocol "" + providerUrl.getProtocol() +
                    "" in notified url: "" + providerUrl + "" from registry "" + getUrl().getAddress() +
                    "" to consumer "" + NetUtils.getLocalHost() + "", supported protocol: "" +
                    getUrl().getOrDefaultFrameworkModel().getExtensionLoader(Protocol.class).getSupportedExtensions()));

            return false;
        }

        return true;
    }",1
dubbo-3.2,NULL_DEREFERENCE,dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryProtocol.java,"org.apache.dubbo.registry.integration.RegistryProtocol.getUrlToRegistry(org.apache.dubbo.common.URL,org.apache.dubbo.common.URL):org.apache.dubbo.common.URL",463,object returned by `providerUrl.getPath()` could be null and is dereferenced at line 463.,https://github.com/apache/dubbo/blob/3.2/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryProtocol.java,"private URL getUrlToRegistry(final URL providerUrl, final URL registryUrl) {
        //The address you see at the registry
        if (!registryUrl.getParameter(SIMPLIFIED_KEY, false)) {
            return providerUrl.removeParameters(getFilteredKeys(providerUrl)).removeParameters(
                MONITOR_KEY, BIND_IP_KEY, BIND_PORT_KEY, QOS_ENABLE, QOS_HOST, QOS_PORT, ACCEPT_FOREIGN_IP, VALIDATION_KEY,
                INTERFACES, REGISTER_MODE_KEY, PID_KEY, REGISTRY_LOCAL_FILE_CACHE_ENABLED, EXECUTOR_MANAGEMENT_MODE, BACKGROUND_KEY, ANYHOST_KEY);
        } else {
            String extraKeys = registryUrl.getParameter(EXTRA_KEYS_KEY, """");
            // if path is not the same as interface name then we should keep INTERFACE_KEY,
            // otherwise, the registry structure of zookeeper would be '/dubbo/path/providers',
            // but what we expect is '/dubbo/interface/providers'
            if (!providerUrl.getPath().equals(providerUrl.getParameter(INTERFACE_KEY))) {
                if (StringUtils.isNotEmpty(extraKeys)) {
                    extraKeys += "","";
                }
                extraKeys += INTERFACE_KEY;
            }
            String[] paramsToRegistry = getParamsToRegistry(DEFAULT_REGISTER_PROVIDER_KEYS
                , COMMA_SPLIT_PATTERN.split(extraKeys));
            return URL.valueOf(providerUrl, paramsToRegistry, providerUrl.getParameter(METHODS_KEY, (String[]) null));
        }

    }",1
dubbo-3.2,NULL_DEREFERENCE,dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/DubboProtocol.java,"org.apache.dubbo.rpc.protocol.dubbo.DubboProtocol.scheduleRemoveSharedClient(java.lang.String,org.apache.dubbo.rpc.protocol.dubbo.SharedClientsProvider):void",462,object returned by `AbstractProtocol.frameworkModel.getBeanFactory().getBean(org.apache.dubbo.common.threadpool.manager.FrameworkExecutorRepository)` could be null and is dereferenced at line 462.,https://github.com/apache/dubbo/blob/3.2/dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/DubboProtocol.java,"protected void scheduleRemoveSharedClient(String key, SharedClientsProvider sharedClient) {
        this.frameworkModel.getBeanFactory().getBean(FrameworkExecutorRepository.class)
            .getSharedExecutor()
            .submit(() -> referenceClientMap.remove(key, sharedClient));
    }",0
dubbo-3.2,NULL_DEREFERENCE,dubbo-common/src/main/java/org/apache/dubbo/common/utils/UrlUtils.java,"org.apache.dubbo.common.utils.UrlUtils.isServiceKeyMatch(org.apache.dubbo.common.URL,org.apache.dubbo.common.URL):boolean",484,"object returned by `pattern.getParameter(""interface"")` could be null and is dereferenced at line 484.","483: public static boolean isServiceKeyMatch(URL pattern, URL value) {
 484: return pattern.getParameter(INTERFACE_KEY).equals(","public static boolean isServiceKeyMatch(URL pattern, URL value) {
        return pattern.getParameter(INTERFACE_KEY).equals(
            value.getParameter(INTERFACE_KEY))
            && isItemMatch(pattern.getGroup(),
            value.getGroup())
            && isItemMatch(pattern.getVersion(),
            value.getVersion());
    }",1
dubbo-3.2,NULL_DEREFERENCE,dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ServiceConfig.java,org.apache.dubbo.config.ServiceConfig.doExportUrls(org.apache.dubbo.common.constants.RegisterTypeEnum):void,501,object returned by `getInterfaceClass()` could be null and is dereferenced by call to `registerService(...)` at line 501.,"493: private void doExportUrls(RegisterTypeEnum registerType) {
 494: ModuleServiceRepository repository = getScopeModel().getServiceRepository();
 495: ServiceDescriptor serviceDescriptor;
 496: final boolean serverService = ref instanceof ServerService;
 497: if (serverService) {
 498: serviceDescriptor = ((ServerService) ref).getServiceDescriptor();
 499: repository.registerService(serviceDescriptor);
 500: } else {
 501: serviceDescriptor = repository.registerService(getInterfaceClass());
 502: }
 503: providerModel = new ProviderModel(serviceMetadata.getServiceKey(),
 504: ref,
 505: serviceDescriptor,
 506: getScopeModel(),
 507: serviceMetadata, interfaceClassLoader);
 508: 
 509: // Compatible with dependencies on ServiceModel#getServiceConfig(), and will be removed in a future version
 510: providerModel.setConfig(this);
 511: 
 512: providerModel.setDestroyRunner(getDestroyRunner());
 513: repository.registerProvider(providerModel);
 514: 
 515: List<URL> registryURLs = ConfigValidationUtils.loadRegistries(this, true);
 516: 
 517: MetricsEventBus.post(RegistryEvent.toRsEvent(module.getApplicationModel(), getUniqueServiceName(), protocols.size() * registryURLs.size()),
 518: () -> {
 519: for (ProtocolConfig protocolConfig : protocols) {
 520: String pathKey = URL.buildKey(getContextPath(protocolConfig)
 521: .map(p -> p + ""/"" + path)
 522: .orElse(path), group, version);
 523: // stub service will use generated service name
 524: if (!serverService) {
 525: // In case user specified path, registerImmediately service one more time to map it to path.
 526: repository.registerService(pathKey, interfaceClass);
 527: }
 528: doExportUrlsFor1Protocol(protocolConfig, registryURLs, registerType);
 529: }
 530: return null;
 531: }
 532: );
 533: 
 534: providerModel.setServiceUrls(urls);","private void doExportUrls(RegisterTypeEnum registerType) {
        ModuleServiceRepository repository = getScopeModel().getServiceRepository();
        ServiceDescriptor serviceDescriptor;
        final boolean serverService = ref instanceof ServerService;
        if (serverService) {
            serviceDescriptor = ((ServerService) ref).getServiceDescriptor();
            repository.registerService(serviceDescriptor);
        } else {
            serviceDescriptor = repository.registerService(getInterfaceClass());
        }
        providerModel = new ProviderModel(serviceMetadata.getServiceKey(),
            ref,
            serviceDescriptor,
            getScopeModel(),
            serviceMetadata, interfaceClassLoader);

        // Compatible with dependencies on ServiceModel#getServiceConfig(), and will be removed in a future version
        providerModel.setConfig(this);

        providerModel.setDestroyRunner(getDestroyRunner());
        repository.registerProvider(providerModel);

        List<URL> registryURLs = ConfigValidationUtils.loadRegistries(this, true);

        for (ProtocolConfig protocolConfig : protocols) {
            String pathKey = URL.buildKey(getContextPath(protocolConfig)
                .map(p -> p + ""/"" + path)
                .orElse(path), group, version);
            // stub service will use generated service name
            if (!serverService) {
                // In case user specified path, register service one more time to map it to path.
                repository.registerService(pathKey, interfaceClass);
            }
            doExportUrlsFor1Protocol(protocolConfig, registryURLs, registerType);
        }

        providerModel.setServiceUrls(urls);
    }
",0
dubbo-3.2,NULL_DEREFERENCE,dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryDirectory.java,org.apache.dubbo.registry.integration.RegistryDirectory.mergeUrl(org.apache.dubbo.common.URL):org.apache.dubbo.common.URL,500,object returned by `RegistryDirectory.moduleModel.getApplicationModel().getBeanFactory().getBean(org.apache.dubbo.rpc.cluster.support.ClusterUtils)` could be null and is dereferenced at line 500.,"496: private URL mergeUrl(URL providerUrl) {
 497: if (providerUrl instanceof ServiceAddressURL) {
 498: providerUrl = overrideWithConfigurator(providerUrl);
 499: } else {
 500: providerUrl = moduleModel.getApplicationModel().getBeanFactory().getBean(ClusterUtils.class).mergeUrl(providerUrl, queryMap); // Merge the consumer side parameters
 501: providerUrl = overrideWithConfigurator(providerUrl);
 502: providerUrl = providerUrl.addParameter(Constants.CHECK_KEY, String.valueOf(false)); // Do not check whether the connection is successful or not, always create Invoker!
 503: }
 504: 
 505: // FIXME, kept for mock
 506: if (providerUrl.hasParameter(MOCK_KEY) || providerUrl.getAnyMethodParameter(MOCK_KEY) != null) {
 507: providerUrl = providerUrl.removeParameter(TAG_KEY);
 508: }
 509: 
 510: if ((providerUrl.getPath() == null || providerUrl.getPath()
 511: .length() == 0) && DUBBO_PROTOCOL.equals(providerUrl.getProtocol())) { // Compatible version 1.0
 512: //fix by tony.chenl DUBBO-44
 513: String path = directoryUrl.getServiceInterface();
 514: if (path != null) {
 515: int i = path.indexOf('/');
 516: if (i >= 0) {
 517: path = path.substring(i + 1);
 518: }
 519: i = path.lastIndexOf(':');
 520: if (i >= 0) {
 521: path = path.substring(0, i);
 522: }
 523: providerUrl = providerUrl.setPath(path);
 524: }
 525: }
 526: return providerUrl;","private URL mergeUrl(URL providerUrl) {
        if (providerUrl instanceof ServiceAddressURL) {
            providerUrl = overrideWithConfigurator(providerUrl);
        } else {
            providerUrl = moduleModel.getApplicationModel().getBeanFactory().getBean(ClusterUtils.class).mergeUrl(providerUrl, queryMap); // Merge the consumer side parameters
            providerUrl = overrideWithConfigurator(providerUrl);
            providerUrl = providerUrl.addParameter(Constants.CHECK_KEY, String.valueOf(false)); // Do not check whether the connection is successful or not, always create Invoker!
        }

        // FIXME, kept for mock
        if (providerUrl.hasParameter(MOCK_KEY) || providerUrl.getAnyMethodParameter(MOCK_KEY) != null) {
            providerUrl = providerUrl.removeParameter(MOCK_KEY);
        }

        if ((providerUrl.getPath() == null || providerUrl.getPath()
            .length() == 0) && DUBBO_PROTOCOL.equals(providerUrl.getProtocol())) { // Compatible version 1.0
            //fix by tony.chenl DUBBO-44
            String path = directoryUrl.getServiceInterface();
            if (path != null) {
                int i = path.indexOf('/');
                if (i >= 0) {
                    path = path.substring(i + 1);
                }
                i = path.lastIndexOf(':');
                if (i >= 0) {
                    path = path.substring(0, i);
                }
                providerUrl = providerUrl.setPath(path);
            }
        }
        return providerUrl;
    }",0
dubbo-3.2,NULL_DEREFERENCE,dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryProtocol.java,"org.apache.dubbo.registry.integration.RegistryProtocol.refer(java.lang.Class,org.apache.dubbo.common.URL):org.apache.dubbo.rpc.Invoker",524,object `qs` last assigned on line 523 could be null and is dereferenced at line 524.,https://github.com/apache/dubbo/blob/3.2/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryProtocol.java,"private String getRegistryUrlKey(final Invoker<?> originInvoker) {
        URL registryUrl = getRegistryUrl(originInvoker);
        String key = registryUrl.removeParameters(DYNAMIC_KEY, ENABLED_KEY).toFullString();
        return key;
    }",0
dubbo-3.2,NULL_DEREFERENCE,dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/DubboProtocol.java,org.apache.dubbo.rpc.protocol.dubbo.DubboProtocol.destroy():void,552,object `server` last assigned on line 548 could be null and is dereferenced at line 552.,"534: public void destroy() {
 535: if (!destroyed.compareAndSet(false, true)) {
 536: return;
 537: }
 538: if (logger.isInfoEnabled()) {
 539: logger.info(""Destroying protocol ["" + this.getClass().getSimpleName() + ""] ..."");
 540: }
 541: for (String key : new ArrayList<>(serverMap.keySet())) {
 542: ProtocolServer protocolServer = serverMap.remove(key);
 543: 
 544: if (protocolServer == null) {
 545: continue;
 546: }
 547: 
 548: RemotingServer server = protocolServer.getRemotingServer();
 549: 
 550: try {
 551: if (logger.isInfoEnabled()) {
 552: logger.info(""Closing dubbo server: "" + server.getLocalAddress());
 553: }
 554: 
 555: server.close(getServerShutdownTimeout(protocolServer));
 556: 
 557: } catch (Throwable t) {
 558: logger.warn(PROTOCOL_ERROR_CLOSE_SERVER, """", """", ""Close dubbo server ["" + server.getLocalAddress() + ""] failed: "" + t.getMessage(), t);
 559: }
 560: }
 561: serverMap.clear();
 562: 
 563: for (String key : new ArrayList<>(referenceClientMap.keySet())) {
 564: SharedClientsProvider clients = referenceClientMap.remove(key);
 565: clients.forceClose();
 566: }
 567: 
 568: PortUnificationExchanger.close();
 569: referenceClientMap.clear();
 570: 
 571: super.destroy();","public void destroy() {
        if (!destroyed.compareAndSet(false, true)) {
            return;
        }
        if (logger.isInfoEnabled()) {
            logger.info(""Destroying protocol ["" + this.getClass().getSimpleName() + ""] ..."");
        }
        for (String key : new ArrayList<>(serverMap.keySet())) {
            ProtocolServer protocolServer = serverMap.remove(key);

            if (protocolServer == null) {
                continue;
            }

            RemotingServer server = protocolServer.getRemotingServer();

            try {
                if (logger.isInfoEnabled()) {
                    logger.info(""Closing dubbo server: "" + server.getLocalAddress());
                }

                server.close(ConfigurationUtils.reCalShutdownTime(getServerShutdownTimeout(protocolServer)));

            } catch (Throwable t) {
                logger.warn(PROTOCOL_ERROR_CLOSE_SERVER, """", """", ""Close dubbo server ["" + server.getLocalAddress() + ""] failed: "" + t.getMessage(), t);
            }
        }
        serverMap.clear();

        for (String key : new ArrayList<>(referenceClientMap.keySet())) {
            SharedClientsProvider clients = referenceClientMap.remove(key);
            clients.forceClose();
        }

        PortUnificationExchanger.close();
        referenceClientMap.clear();

        super.destroy();
    }",0
dubbo-3.2,NULL_DEREFERENCE,dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/DubboProtocol.java,org.apache.dubbo.rpc.protocol.dubbo.DubboProtocol.destroy():void,555,object `server` last assigned on line 548 could be null and is dereferenced at line 555.,"534: public void destroy() {
 535: if (!destroyed.compareAndSet(false, true)) {
 536: return;
 537: }
 538: if (logger.isInfoEnabled()) {
 539: logger.info(""Destroying protocol ["" + this.getClass().getSimpleName() + ""] ..."");
 540: }
 541: for (String key : new ArrayList<>(serverMap.keySet())) {
 542: ProtocolServer protocolServer = serverMap.remove(key);
 543: 
 544: if (protocolServer == null) {
 545: continue;
 546: }
 547: 
 548: RemotingServer server = protocolServer.getRemotingServer();
 549: 
 550: try {
 551: if (logger.isInfoEnabled()) {
 552: logger.info(""Closing dubbo server: "" + server.getLocalAddress());
 553: }
 554: 
 555: server.close(getServerShutdownTimeout(protocolServer));
 556: 
 557: } catch (Throwable t) {
 558: logger.warn(PROTOCOL_ERROR_CLOSE_SERVER, """", """", ""Close dubbo server ["" + server.getLocalAddress() + ""] failed: "" + t.getMessage(), t);
 559: }
 560: }
 561: serverMap.clear();
 562: 
 563: for (String key : new ArrayList<>(referenceClientMap.keySet())) {
 564: SharedClientsProvider clients = referenceClientMap.remove(key);
 565: clients.forceClose();
 566: }
 567: 
 568: PortUnificationExchanger.close();
 569: referenceClientMap.clear();
 570: 
 571: super.destroy();","public void destroy() {
        if (!destroyed.compareAndSet(false, true)) {
            return;
        }
        if (logger.isInfoEnabled()) {
            logger.info(""Destroying protocol ["" + this.getClass().getSimpleName() + ""] ..."");
        }
        for (String key : new ArrayList<>(serverMap.keySet())) {
            ProtocolServer protocolServer = serverMap.remove(key);

            if (protocolServer == null) {
                continue;
            }

            RemotingServer server = protocolServer.getRemotingServer();

            try {
                if (logger.isInfoEnabled()) {
                    logger.info(""Closing dubbo server: "" + server.getLocalAddress());
                }

                server.close(ConfigurationUtils.reCalShutdownTime(getServerShutdownTimeout(protocolServer)));

            } catch (Throwable t) {
                logger.warn(PROTOCOL_ERROR_CLOSE_SERVER, """", """", ""Close dubbo server ["" + server.getLocalAddress() + ""] failed: "" + t.getMessage(), t);
            }
        }
        serverMap.clear();

        for (String key : new ArrayList<>(referenceClientMap.keySet())) {
            SharedClientsProvider clients = referenceClientMap.remove(key);
            clients.forceClose();
        }

        PortUnificationExchanger.close();
        referenceClientMap.clear();

        super.destroy();
    }

   ",0
dubbo-3.2,NULL_DEREFERENCE,dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ReferenceConfig.java,org.apache.dubbo.config.ReferenceConfig.parseUrl(java.util.Map):void,565,object returned by `getScopeModel().getApplicationModel().getBeanFactory().getBean(org.apache.dubbo.rpc.cluster.support.ClusterUtils)` could be null and is dereferenced at line 565.,https://github.com/apache/dubbo/blob/3.2/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/ReferenceConfig.java,"rivate void parseUrl(Map<String, String> referenceParameters) {
        String[] us = SEMICOLON_SPLIT_PATTERN.split(url);
        if (ArrayUtils.isNotEmpty(us)) {
            for (String u : us) {
                URL url = URL.valueOf(u);
                if (StringUtils.isEmpty(url.getPath())) {
                    url = url.setPath(interfaceName);
                }
                url = url.setScopeModel(getScopeModel());
                url = url.setServiceModel(consumerModel);
                if (UrlUtils.isRegistry(url)) {
                    urls.add(url.putAttribute(REFER_KEY, referenceParameters));
                } else {
                    URL peerUrl = getScopeModel().getApplicationModel().getBeanFactory().getBean(ClusterUtils.class).mergeUrl(url, referenceParameters);
                    peerUrl = peerUrl.putAttribute(PEER_KEY, true);
                    urls.add(peerUrl);
                }
            }
        }
    }",0
dubbo-3.2,NULL_DEREFERENCE,dubbo-common/src/main/java/org/apache/dubbo/common/config/configcenter/file/FileSystemDynamicConfiguration.java,org.apache.dubbo.common.config.configcenter.file.FileSystemDynamicConfiguration.initDirectory(org.apache.dubbo.common.URL):java.io.File,617,object `rootDirectory` last assigned on line 612 could be null and is dereferenced at line 617.,"610: protected static File initDirectory(URL url) {
 611: String directoryPath = getParameter(url, CONFIG_CENTER_DIR_PARAM_NAME, url == null ? null : url.getPath());
 612: File rootDirectory = null;
 613: if (!StringUtils.isBlank(directoryPath)) {
 614: rootDirectory = new File(""/"" + directoryPath);
 615: }
 616: 
 617: if (directoryPath == null || !rootDirectory.exists()) { // If the directory does not exist
 618: rootDirectory = new File(DEFAULT_CONFIG_CENTER_DIR_PATH);
 619: }
 620: 
 621: if (!rootDirectory.exists() && !rootDirectory.mkdirs()) {
 622: throw new IllegalStateException(format(""Dubbo config center rootDirectory[%s] can't be created!"",
 623: rootDirectory.getAbsolutePath()));
 624: }
 625: return rootDirectory;","protected static File initDirectory(URL url) {
        String directoryPath = getParameter(url, CONFIG_CENTER_DIR_PARAM_NAME, url == null ? null : url.getPath());
        File rootDirectory = null;
        if (!StringUtils.isBlank(directoryPath)) {
            rootDirectory = new File(""/"" + directoryPath);
        }

        if (directoryPath == null || !rootDirectory.exists()) { // If the directory does not exist
            rootDirectory = new File(DEFAULT_CONFIG_CENTER_DIR_PATH);
        }

        if (!rootDirectory.exists() && !rootDirectory.mkdirs()) {
            throw new IllegalStateException(format(""Dubbo config center rootDirectory[%s] can't be created!"",
                rootDirectory.getAbsolutePath()));
        }
        return rootDirectory;
    }",0
dubbo-3.2,NULL_DEREFERENCE,dubbo-compatible/src/main/java/com/alibaba/dubbo/common/URL.java,"org.apache.dubbo.common.URL.getParameter(java.lang.String,java.lang.Class,java.lang.Object):java.lang.Object",628,object returned by `getOrDefaultFrameworkModel().getBeanFactory().getBean(org.apache.dubbo.common.convert.ConverterUtil)` could be null and is dereferenced at line 628.,"628: public org.apache.dubbo.common.URL getOriginalURL() {
 629: return new org.apache.dubbo.common.URL(super.getProtocol(), super.getUsername(), super.getPassword(),","public org.apache.dubbo.common.URL getOriginalURL() {
        return new org.apache.dubbo.common.URL(super.getProtocol(), super.getUsername(), super.getPassword(),
            super.getHost(), super.getPort(), super.getPath(), super.getParameters());
    }",0
dubbo-3.2,NULL_DEREFERENCE,dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/utils/ConfigValidationUtils.java,"org.apache.dubbo.config.utils.ConfigValidationUtils.checkMultiExtension(org.apache.dubbo.rpc.model.ModuleModel,java.util.List,java.lang.String,java.lang.String):void",674,object `v` last assigned on line 673 could be null and is dereferenced at line 674.,https://github.com/apache/dubbo/blob/3.2/dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/utils/ConfigValidationUtils.java,"public static void checkMultiExtension(ScopeModel scopeModel, List<Class<?>> types, String property, String value) {
        checkMultiName(property, value);
        if (isNotEmpty(value)) {
            String[] values = value.split(""\\s*[,]+\\s*"");
            for (String v : values) {
                v = StringUtils.trim(v);
                if (v.startsWith(REMOVE_VALUE_PREFIX)) {
                    continue;
                }
                if (DEFAULT_KEY.equals(v)) {
                    continue;
                }
                boolean match = false;
                for (Class<?> type : types) {
                    if (scopeModel.getExtensionLoader(type).hasExtension(v)) {
                        match = true;
                    }
                }
                if (!match) {
                    throw new IllegalStateException(""No such extension "" + v + "" for "" + property + ""/"" +
                        types.stream().map(Class::getName).collect(Collectors.joining("","")));
                }
            }
        }
    }
",0
dubbo-3.2,NULL_DEREFERENCE,dubbo-common/src/main/java/org/apache/dubbo/common/utils/UrlUtils.java,org.apache.dubbo.common.utils.UrlUtils.isConsumer(org.apache.dubbo.common.URL):boolean,684,object returned by `url.getProtocol()` could be null and is dereferenced at line 684.,"683: public static boolean isConsumer(URL url) {
 684: return url.getProtocol().equalsIgnoreCase(CONSUMER) || url.getPort() == 0;","public static boolean isConsumer(URL url) {
        return url.getProtocol().equalsIgnoreCase(CONSUMER) || url.getPort() == 0;
    }",1
dubbo-3.2,NULL_DEREFERENCE,dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryProtocol.java,"org.apache.dubbo.registry.integration.RegistryProtocol$ExporterChangeableWrapper.<init>(org.apache.dubbo.registry.integration.RegistryProtocol,org.apache.dubbo.registry.integration.ReferenceCountExporter,org.apache.dubbo.rpc.Invoker)",966,object `frameworkExecutorRepository` last assigned on line 965 could be null and is dereferenced at line 966.,https://github.com/apache/dubbo/blob/3.2/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryProtocol.java,"public ExporterChangeableWrapper(ReferenceCountExporter<T> exporter, Invoker<T> originInvoker) {
            this.exporter = exporter;
            exporter.increaseCount();
            this.originInvoker = originInvoker;
            FrameworkExecutorRepository frameworkExecutorRepository = originInvoker.getUrl().getOrDefaultFrameworkModel().getBeanFactory()
                .getBean(FrameworkExecutorRepository.class);
            this.executor = frameworkExecutorRepository.getSharedScheduledExecutor();
        }",0
dubbo-3.2,NULL_DEREFERENCE,dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryProtocol.java,"org.apache.dubbo.registry.integration.RegistryProtocol$ExporterChangeableWrapper.lambda$register$0(org.apache.dubbo.common.URL,org.apache.dubbo.rpc.model.ProviderModel$RegisterStatedURL):boolean",995,object returned by `u.getProviderUrl().getProtocol()` could be null and is dereferenced at line 995.,https://github.com/apache/dubbo/blob/3.2/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/RegistryProtocol.java,"public void register() {
            if (registered.compareAndSet(false, true)) {
                URL registryUrl = getRegistryUrl(originInvoker);
                Registry registry = getRegistry(registryUrl);
                RegistryProtocol.register(registry, getRegisterUrl());

                ProviderModel providerModel = frameworkModel.getServiceRepository()
                    .lookupExportedService(getRegisterUrl().getServiceKey());

                List<ProviderModel.RegisterStatedURL> statedUrls = providerModel.getStatedUrl();
                statedUrls.stream()
                    .filter(u -> u.getRegistryUrl().equals(registryUrl)
                        && u.getProviderUrl().getProtocol().equals(getRegisterUrl().getProtocol()))
                    .forEach(u -> u.setRegistered(true));
                logger.info(""Registered dubbo service "" + getRegisterUrl().getServiceKey() + "" url "" + getRegisterUrl() + "" to registry "" + registryUrl);
            }
        }",1
dubbo-3.2,NULL_DEREFERENCE,dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/deploy/DefaultApplicationDeployer.java,org.apache.dubbo.config.deploy.DefaultApplicationDeployer.executeShutdownCallbacks():void,1057,object `shutdownHookCallbacks` last assigned on line 1056 could be null and is dereferenced at line 1057.,"1055: private void executeShutdownCallbacks() {
1056: ShutdownHookCallbacks shutdownHookCallbacks = applicationModel.getBeanFactory().getBean(ShutdownHookCallbacks.class);
1057: shutdownHookCallbacks.callback();","public void notifyModuleChanged(ModuleModel moduleModel, DeployState state) {
        checkState(moduleModel, state);

        // notify module state changed or module changed
        synchronized (stateLock) {
            stateLock.notifyAll();
        }
    }",0
dubbo-3.2,NULL_DEREFERENCE,dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/deploy/DefaultApplicationDeployer.java,org.apache.dubbo.config.deploy.DefaultApplicationDeployer.startMetricsCollector():void,1231,object `collector` last assigned on line 1230 could be null and is dereferenced at line 1231.,"1229: private void startMetricsCollector() {
1230: DefaultMetricsCollector collector = applicationModel.getBeanFactory().getBean(DefaultMetricsCollector.class);
1231: if (Objects.nonNull(collector) && collector.isThreadpoolCollectEnabled()) {","private void completeStartFuture(boolean success) {
        if (startFuture != null) {
            startFuture.complete(success);
        }
    }",0
dubbo-3.2,NULL_DEREFERENCE,dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/deploy/DefaultApplicationDeployer.java,org.apache.dubbo.config.deploy.DefaultApplicationDeployer.destroyExecutorRepository():void,1283,object returned by `getInstance(DefaultApplicationDeployer.applicationModel)` could be null and is dereferenced at line 1283.,"1279: private void destroyExecutorRepository() {
1280: // shutdown export/refer executor
1281: executorRepository.shutdownServiceExportExecutor();
1282: executorRepository.shutdownServiceReferExecutor();
1283: ExecutorRepository.getInstance(applicationModel).destroyAll();","private void destroyServiceDiscoveries() {
        RegistryManager.getInstance(applicationModel).getServiceDiscoveries().forEach(serviceDiscovery -> {
            try {
                serviceDiscovery.destroy();
            } catch (Throwable ignored) {
                logger.warn(CONFIG_FAILED_EXECUTE_DESTROY, """", """", ignored.getMessage(), ignored);
            }
        });
        if (logger.isDebugEnabled()) {
            logger.debug(getIdentifier() + ""'s all ServiceDiscoveries have been destroyed."");
        }
    }",1
dubbo-3.2,NULL_DEREFERENCE,dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/deploy/DefaultApplicationDeployer.java,org.apache.dubbo.config.deploy.DefaultApplicationDeployer.destroyRegistries():void,1287,object returned by `getInstance(DefaultApplicationDeployer.applicationModel)` could be null and is dereferenced at line 1287.,"1286: private void destroyRegistries() {
1287: RegistryManager.getInstance(applicationModel).destroyAll();","private void destroyServiceDiscoveries() {
        RegistryManager.getInstance(applicationModel).getServiceDiscoveries().forEach(serviceDiscovery -> {
            try {
                serviceDiscovery.destroy();
            } catch (Throwable ignored) {
                logger.warn(CONFIG_FAILED_EXECUTE_DESTROY, """", """", ignored.getMessage(), ignored);
            }
        });
        if (logger.isDebugEnabled()) {
            logger.debug(getIdentifier() + ""'s all ServiceDiscoveries have been destroyed."");
        }
    }",1
dubbo-3.2,NULL_DEREFERENCE,dubbo-config/dubbo-config-api/src/main/java/org/apache/dubbo/config/deploy/DefaultApplicationDeployer.java,org.apache.dubbo.config.deploy.DefaultApplicationDeployer.destroyServiceDiscoveries():void,1291,object returned by `getInstance(DefaultApplicationDeployer.applicationModel)` could be null and is dereferenced at line 1291.,"1290: private void destroyServiceDiscoveries() {
1291: RegistryManager.getInstance(applicationModel).getServiceDiscoveries().forEach(serviceDiscovery -> {
1292: try {
1293: serviceDiscovery.destroy();
1294: } catch (Throwable ignored) {
1295: logger.warn(CONFIG_FAILED_EXECUTE_DESTROY, """", """", ignored.getMessage(), ignored);
1296: }
1297: });
1298: if (logger.isDebugEnabled()) {","private void destroyServiceDiscoveries() {
        RegistryManager.getInstance(applicationModel).getServiceDiscoveries().forEach(serviceDiscovery -> {
            try {
                serviceDiscovery.destroy();
            } catch (Throwable ignored) {
                logger.warn(CONFIG_FAILED_EXECUTE_DESTROY, """", """", ignored.getMessage(), ignored);
            }
        });
        if (logger.isDebugEnabled()) {
            logger.debug(getIdentifier() + ""'s all ServiceDiscoveries have been destroyed."");
        }
    }",1
guava-32.1.1,NULL_DEREFERENCE,guava/src/com/google/common/io/CharSink.java,com.google.common.io.CharSink.write(java.lang.CharSequence):void,100,object `out` last assigned on line 99 could be null and is dereferenced at line 100.,https://github.com/google/guava/blob/v32.1.1/guava/src/com/google/common/io/CharSink.java,"public void write(CharSequence charSequence) throws IOException {
    checkNotNull(charSequence);

    Closer closer = Closer.create();
    try {
      Writer out = closer.register(openStream());
      out.append(charSequence);
      out.flush(); // https://code.google.com/p/guava-libraries/issues/detail?id=1330
    } catch (Throwable e) {
      throw closer.rethrow(e);
    } finally {
      closer.close();
    }
  }",0
guava-32.1.1,NULL_DEREFERENCE,guava/src/com/google/common/io/ByteSink.java,com.google.common.io.ByteSink.write(byte[]):void,105,object `out` last assigned on line 104 could be null and is dereferenced at line 105.,https://github.com/google/guava/blob/v32.1.1/guava/src/com/google/common/io/ByteSink.java,"public void write(byte[] bytes) throws IOException {
    checkNotNull(bytes);

    Closer closer = Closer.create();
    try {
      OutputStream out = closer.register(openStream());
      out.write(bytes);
      out.flush(); // https://code.google.com/p/guava-libraries/issues/detail?id=1330
    } catch (Throwable e) {
      throw closer.rethrow(e);
    } finally {
      closer.close();
    }
  }",0
guava-32.1.1,NULL_DEREFERENCE,guava/src/com/google/common/io/ByteSource.java,com.google.common.io.ByteSource.isEmpty():boolean,160,object `in` last assigned on line 159 could be null and is dereferenced at line 160.,https://github.com/google/guava/blob/v32.1.1/guava/src/com/google/common/io/ByteSource.java,"public boolean isEmpty() throws IOException {
    Optional<Long> sizeIfKnown = sizeIfKnown();
    if (sizeIfKnown.isPresent()) {
      return sizeIfKnown.get() == 0L;
    }
    Closer closer = Closer.create();
    try {
      InputStream in = closer.register(openStream());
      return in.read() == -1;
    } catch (Throwable e) {
      throw closer.rethrow(e);
    } finally {
      closer.close();
    }
  }
",0
guava-32.1.1,NULL_DEREFERENCE,guava/src/com/google/common/io/CharSource.java,com.google.common.io.CharSource.length():long,219,object `reader` last assigned on line 218 could be null and is dereferenced by call to `countBySkipping(...)` at line 219.,https://github.com/google/guava/blob/v32.1.1/guava/src/com/google/common/io/CharSource.java,"public long length() throws IOException {
    Optional<Long> lengthIfKnown = lengthIfKnown();
    if (lengthIfKnown.isPresent()) {
      return lengthIfKnown.get();
    }

    Closer closer = Closer.create();
    try {
      Reader reader = closer.register(openStream());
      return countBySkipping(reader);
    } catch (Throwable e) {
      throw closer.rethrow(e);
    } finally {
      closer.close();
    }
  }",0
guava-32.1.1,NULL_DEREFERENCE,guava/src/com/google/common/collect/ImmutableList.java,com.google.common.collect.ImmutableList.copyOf(com.google.common.base.Converter$1$1):com.google.common.collect.ImmutableList,282,object `first` last assigned on line 278 could be null and is dereferenced by call to `add(...)` at line 282.,https://github.com/google/guava/blob/v32.1.1/guava/src/com/google/common/collect/ImmutableList.java,"public static <E> ImmutableList<E> copyOf(Iterator<? extends E> elements) {
    // We special-case for 0 or 1 elements, but going further is madness.
    if (!elements.hasNext()) {
      return of();
    }
    E first = elements.next();
    if (!elements.hasNext()) {
      return of(first);
    } else {
      return new ImmutableList.Builder<E>().add(first).addAll(elements).build();
    }
  }
",0
guava-32.1.1,NULL_DEREFERENCE,guava/src/com/google/common/io/ByteSource.java,com.google.common.io.ByteSource.read():byte[],299,object `in` last assigned on line 296 could be null and is dereferenced by call to `toByteArray(...)` at line 299.,https://github.com/google/guava/blob/v32.1.1/guava/src/com/google/common/io/ByteSource.java,"public byte[] read() throws IOException {
    Closer closer = Closer.create();
    try {
      InputStream in = closer.register(openStream());
      Optional<Long> size = sizeIfKnown();
      return size.isPresent()
          ? ByteStreams.toByteArray(in, size.get())
          : ByteStreams.toByteArray(in);
    } catch (Throwable e) {
      throw closer.rethrow(e);
    } finally {
      closer.close();
    }
  }",0
guava-32.1.1,NULL_DEREFERENCE,guava/src/com/google/common/io/CharSource.java,com.google.common.io.CharSource.isEmpty():boolean,422,object `reader` last assigned on line 421 could be null and is dereferenced at line 422.,https://github.com/google/guava/blob/v32.1.1/guava/src/com/google/common/io/CharSource.java,"public boolean isEmpty() throws IOException {
    Optional<Long> lengthIfKnown = lengthIfKnown();
    if (lengthIfKnown.isPresent()) {
      return lengthIfKnown.get() == 0L;
    }
    Closer closer = Closer.create();
    try {
      Reader reader = closer.register(openStream());
      return reader.read() == -1;
    } catch (Throwable e) {
      throw closer.rethrow(e);
    } finally {
      closer.close();
    }
  }",0
guava-32.1.1,NULL_DEREFERENCE,guava/src/com/google/common/reflect/Types.java,com.google.common.reflect.Types$WildcardTypeImpl.toString():java.lang.String,512,object `upperBound` last assigned on line 511 could be null and is dereferenced by call to `typeName(...)` at line 512.,https://github.com/google/guava/blob/v32.1.1/guava/src/com/google/common/reflect/Types.java,"public String toString() {
      StringBuilder builder = new StringBuilder(""?"");
      for (Type lowerBound : lowerBounds) {
        builder.append("" super "").append(JavaVersion.CURRENT.typeName(lowerBound));
      }
      for (Type upperBound : filterUpperBounds(upperBounds)) {
        builder.append("" extends "").append(JavaVersion.CURRENT.typeName(upperBound));
      }
      return builder.toString();
    }",0
guava-32.1.1,NULL_DEREFERENCE,guava/src/com/google/common/io/CharSource.java,com.google.common.io.CharSource$StringCharSource.copyTo(com.google.common.io.CharSink):long,663,object `writer` last assigned on line 662 could be null and is dereferenced at line 663.,https://github.com/google/guava/blob/v32.1.1/guava/src/com/google/common/io/CharSource.java,"public long copyTo(CharSink sink) throws IOException {
      checkNotNull(sink);
      Closer closer = Closer.create();
      try {
        Writer writer = closer.register(sink.openStream());
        writer.write((String) seq);
        return seq.length();
      } catch (Throwable e) {
        throw closer.rethrow(e);
      } finally {
        closer.close();
      }
    }
  }",0
guava-32.1.1,NULL_DEREFERENCE,guava/src/com/google/common/cache/LocalCache.java,"com.google.common.cache.LocalCache$Segment.loadSync(java.lang.Object,int,com.google.common.cache.LocalCache$LoadingValueReference,com.google.common.cache.CacheLoader):java.lang.Object",2314,object `loadingFuture` last assigned on line 2313 could be null and is dereferenced by call to `getAndRecordStats(...)` at line 2314.,https://github.com/google/guava/blob/v32.1.1/guava/src/com/google/common/cache/LocalCache.java,"V loadSync(
        K key,
        int hash,
        LoadingValueReference<K, V> loadingValueReference,
        CacheLoader<? super K, V> loader)
        throws ExecutionException {
      ListenableFuture<V> loadingFuture = loadingValueReference.loadFuture(key, loader);
      return getAndRecordStats(key, hash, loadingValueReference, loadingFuture);
    }",1
guava-32.1.1,NULL_DEREFERENCE,guava/src/com/google/common/cache/LocalCache.java,"com.google.common.cache.LocalCache$Segment.loadAsync(java.lang.Object,int,com.google.common.cache.LocalCache$LoadingValueReference,com.google.common.cache.CacheLoader):com.google.common.util.concurrent.ListenableFuture",2323,object `loadingFuture` last assigned on line 2322 could be null and is dereferenced at line 2323.,https://github.com/google/guava/blob/v32.1.1/guava/src/com/google/common/cache/LocalCache.java,"ListenableFuture<V> loadAsync(
        final K key,
        final int hash,
        final LoadingValueReference<K, V> loadingValueReference,
        CacheLoader<? super K, V> loader) {
      final ListenableFuture<V> loadingFuture = loadingValueReference.loadFuture(key, loader);
      loadingFuture.addListener(
          () -> {
            try {
              getAndRecordStats(key, hash, loadingValueReference, loadingFuture);
            } catch (Throwable t) {
              logger.log(Level.WARNING, ""Exception thrown during refresh"", t);
              loadingValueReference.setException(t);
            }
          },
          directExecutor());
      return loadingFuture;
    }",1
java-debug-0.47.0,NULL_DEREFERENCE,com.microsoft.java.debug.core/src/main/java/com/microsoft/java/debug/core/adapter/handler/StackTraceRequestHandler.java,"com.microsoft.java.debug.core.adapter.handler.StackTraceRequestHandler.resolveStackFrameInfos(com.sun.jdi.StackFrame[],boolean):java.util.List",181,object `enclosingType` last assigned on line 180 could be null and is dereferenced at line 181.,"128: private static List<StackFrameInfo> resolveStackFrameInfos(StackFrame[] frames, boolean async)
 129: throws AbsentInformationException, IncompatibleThreadStateException {
 130: List<StackFrameInfo> jdiFrames = new ArrayList<>();
 131: List<CompletableFuture<Void>> futures = new ArrayList<>();
 132: for (StackFrame frame : frames) {
 133: StackFrameInfo jdiFrame = new StackFrameInfo(frame);
 134: jdiFrame.location = jdiFrame.frame.location();
 135: jdiFrame.method = jdiFrame.location.method();
 136: jdiFrame.methodName = jdiFrame.method.name();
 137: jdiFrame.isNative = jdiFrame.method.isNative();
 138: jdiFrame.declaringType = jdiFrame.location.declaringType();
 139: if (async) {
 140: // JDWP Command: M_LINE_TABLE
 141: futures.add(AsyncJdwpUtils.runAsync(() -> {
 142: jdiFrame.lineNumber = jdiFrame.location.lineNumber();
 143: }));
 144: 
 145: // JDWP Commands: RT_SOURCE_DEBUG_EXTENSION, RT_SOURCE_FILE
 146: futures.add(AsyncJdwpUtils.runAsync(() -> {
 147: try {
 148: // When the .class file doesn't contain source information in meta data,
 149: // invoking Location#sourceName() would throw AbsentInformationException.
 150: jdiFrame.sourceName = jdiFrame.declaringType.sourceName();
 151: } catch (AbsentInformationException e) {
 152: jdiFrame.sourceName = null;
 153: }
 154: }));
 155: 
 156: // JDWP Command: RT_SIGNATURE
 157: futures.add(AsyncJdwpUtils.runAsync(() -> {
 158: jdiFrame.typeSignature = jdiFrame.declaringType.signature();
 159: }));
 160: } else {
 161: jdiFrame.lineNumber = jdiFrame.location.lineNumber();
 162: jdiFrame.typeSignature = jdiFrame.declaringType.signature();
 163: try {
 164: // When the .class file doesn't contain source information in meta data,
 165: // invoking Location#sourceName() would throw AbsentInformationException.
 166: jdiFrame.sourceName = jdiFrame.declaringType.sourceName();
 167: } catch (AbsentInformationException e) {
 168: jdiFrame.sourceName = null;
 169: }
 170: }
 171: 
 172: jdiFrames.add(jdiFrame);
 173: }
 174: 
 175: AsyncJdwpUtils.await(futures);
 176: for (StackFrameInfo jdiFrame : jdiFrames) {
 177: jdiFrame.typeName = jdiFrame.declaringType.name();
 178: jdiFrame.argumentTypeNames = jdiFrame.method.argumentTypeNames();
 179: if (jdiFrame.sourceName == null) {
 180: String enclosingType = AdapterUtils.parseEnclosingType(jdiFrame.typeName);
 181: jdiFrame.sourceName = enclosingType.substring(enclosingType.lastIndexOf('.') + 1) + "".java"";
 182: jdiFrame.sourcePath = enclosingType.replace('.', File.separatorChar) + "".java"";
 183: } else {
 184: jdiFrame.sourcePath = jdiFrame.declaringType.sourcePaths(null).get(0);
 185: }
 186: }
 187: 
 188: return jdiFrames;","private static List<StackFrameInfo> resolveStackFrameInfos(StackFrame[] frames, boolean async)
        throws AbsentInformationException, IncompatibleThreadStateException {
        List<StackFrameInfo> jdiFrames = new ArrayList<>();
        List<CompletableFuture<Void>> futures = new ArrayList<>();
        for (StackFrame frame : frames) {
            StackFrameInfo jdiFrame = new StackFrameInfo(frame);
            jdiFrame.location = jdiFrame.frame.location();
            jdiFrame.method = jdiFrame.location.method();
            jdiFrame.methodName = jdiFrame.method.name();
            jdiFrame.isNative = jdiFrame.method.isNative();
            jdiFrame.declaringType = jdiFrame.location.declaringType();
            if (async) {
                // JDWP Command: M_LINE_TABLE
                futures.add(AsyncJdwpUtils.runAsync(() -> {
                    jdiFrame.lineNumber = jdiFrame.location.lineNumber();
                }));

                // JDWP Commands: RT_SOURCE_DEBUG_EXTENSION, RT_SOURCE_FILE
                futures.add(AsyncJdwpUtils.runAsync(() -> {
                    try {
                        // When the .class file doesn't contain source information in meta data,
                        // invoking Location#sourceName() would throw AbsentInformationException.
                        jdiFrame.sourceName = jdiFrame.declaringType.sourceName();
                    } catch (AbsentInformationException e) {
                        jdiFrame.sourceName = null;
                    }
                }));

                // JDWP Command: RT_SIGNATURE
                futures.add(AsyncJdwpUtils.runAsync(() -> {
                    jdiFrame.typeSignature = jdiFrame.declaringType.signature();
                }));
            } else {
                jdiFrame.lineNumber = jdiFrame.location.lineNumber();
                jdiFrame.typeSignature = jdiFrame.declaringType.signature();
                try {
                    // When the .class file doesn't contain source information in meta data,
                    // invoking Location#sourceName() would throw AbsentInformationException.
                    jdiFrame.sourceName = jdiFrame.declaringType.sourceName();
                } catch (AbsentInformationException e) {
                    jdiFrame.sourceName = null;
                }
            }

            jdiFrames.add(jdiFrame);
        }

        AsyncJdwpUtils.await(futures);
        for (StackFrameInfo jdiFrame : jdiFrames) {
            jdiFrame.typeName = jdiFrame.declaringType.name();
            jdiFrame.argumentTypeNames = jdiFrame.method.argumentTypeNames();
            if (jdiFrame.sourceName == null) {
                String enclosingType = AdapterUtils.parseEnclosingType(jdiFrame.typeName);
                jdiFrame.sourceName = enclosingType.substring(enclosingType.lastIndexOf('.') + 1) + "".java"";
                jdiFrame.sourcePath = enclosingType.replace('.', File.separatorChar) + "".java"";
            } else {
                jdiFrame.sourcePath = jdiFrame.declaringType.sourcePaths(null).get(0);
            }
        }

        return jdiFrames;
    }",0
jreleaser-1.7.0,NULL_DEREFERENCE,core/jreleaser-model-impl/src/main/java/org/jreleaser/model/internal/common/AbstractActivatable.java,org.jreleaser.model.internal.common.AbstractActivatable.merge(org.jreleaser.model.internal.announce.AbstractAnnouncer):void,40,"object returned by `merge(valueOf(AbstractActivatable.enabled),valueOf(source.isEnabled()))` could be null and is dereferenced at line 40.","38: public void merge(S source) {
 39: this.active = merge(this.active, source.getActive());
 40: this.enabled = merge(this.enabled, source.isEnabled());","public void merge(S source) {
        this.active = merge(this.active, source.getActive());
        this.enabled = merge(this.enabled, source.isEnabled());
    }
",1
jreleaser-1.7.0,NULL_DEREFERENCE,sdks/jreleaser-git-java-sdk/src/main/java/org/jreleaser/sdk/git/release/AbstractReleaserBuilder.java,org.jreleaser.sdk.git.release.AbstractReleaserBuilder.addReleaseAssets(java.nio.file.Path):org.jreleaser.model.spi.release.ReleaserBuilder,70,object returned by `assets.toFile().listFiles()` could be null and is dereferenced at line 70.,"68: public ReleaserBuilder<R> addReleaseAssets(Path assets) {
 69: if (assets.toFile().exists()) {
 70: for (File asset : assets.toFile().listFiles()) {
 71: addReleaseAsset(Asset.file(Artifact.of(asset.toPath().toAbsolutePath())));
 72: }
 73: }
 74: 
 75: return this;","public ReleaserBuilder<R> addReleaseAssets(Path assets) {
        if (assets.toFile().exists()) {
            for (File asset : assets.toFile().listFiles()) {
                addReleaseAsset(Asset.file(Artifact.of(asset.toPath().toAbsolutePath())));
            }
        }

        return this;
    }",0
jreleaser-1.7.0,NULL_DEREFERENCE,core/jreleaser-model-impl/src/main/java/org/jreleaser/model/internal/checksum/Checksum.java,"org.jreleaser.model.internal.checksum.Checksum.getResolvedName(org.jreleaser.model.internal.JReleaserContext,org.jreleaser.util.Algorithm):java.lang.String",105,object `resolvedName` last assigned on line 104 could be null and is dereferenced at line 105.,"103: public String getResolvedName(JReleaserContext context, Algorithm algorithm) {
 104: String resolvedName = context.getModel().getChecksum().getResolvedName(context);
 105: int pos = resolvedName.lastIndexOf(""."");
 106: if (pos != -1) {
 107: resolvedName = resolvedName.substring(0, pos) + ""_"" + algorithm.formatted() + resolvedName.substring(pos);
 108: } else {
 109: resolvedName += ""."" + algorithm.formatted();
 110: }
 111: 
 112: return resolvedName;","public String getResolvedName(JReleaserContext context, Algorithm algorithm) {
        String resolvedName = context.getModel().getChecksum().getResolvedName(context);
        int pos = resolvedName.lastIndexOf(""."");
        if (pos != -1) {
            resolvedName = resolvedName.substring(0, pos) + ""_"" + algorithm.formatted() + resolvedName.substring(pos);
        } else {
            resolvedName += ""."" + algorithm.formatted();
        }

        return resolvedName;
    }
",1
jreleaser-1.7.0,NULL_DEREFERENCE,core/jreleaser-model-impl/src/main/java/org/jreleaser/model/internal/catalog/SlsaCataloger.java,org.jreleaser.model.internal.catalog.SlsaCataloger.getResolvedAttestationName(org.jreleaser.model.internal.JReleaserContext):java.lang.String,136,object `name` last assigned on line 135 could be null and is dereferenced at line 136.,"131: public String getResolvedAttestationName(JReleaserContext context) {
 132: TemplateContext props = context.fullProps();
 133: context.getChangelog().apply(props);
 134: applyTemplates(props, resolvedExtraProperties());
 135: String name = resolveTemplate(attestationName, props);
 136: if (!name.endsWith(ATTESTATION_INTOTO)) {
 137: name += ATTESTATION_INTOTO;
 138: }
 139: return name;","public String getResolvedAttestationName(JReleaserContext context) {
        TemplateContext props = context.fullProps();
        context.getChangelog().apply(props);
        applyTemplates(props, resolvedExtraProperties());
        String name = resolveTemplate(attestationName, props);
        if (!name.endsWith(ATTESTATION_INTOTO)) {
            name += ATTESTATION_INTOTO;
        }
        return name;
    }",1
jreleaser-1.7.0,NULL_DEREFERENCE,plugins/jreleaser-maven-plugin/src/main/java/org/jreleaser/maven/plugin/internal/JReleaserModelConfigurer.java,org.jreleaser.maven.plugin.internal.JReleaserModelConfigurer.resolveJavaVersion(org.apache.maven.project.MavenProject):java.lang.String,147,object `javaVersion` last assigned on line 134 could be null and is dereferenced by call to `resolveJavaVersion(...)` at line 147.,"133: private static String resolveJavaVersion(MavenProject mavenProject) {
 134: String javaVersion = System.getProperty(""java.version"");
 135: 
 136: Properties properties = mavenProject.getProperties();
 137: if (null != properties && !properties.isEmpty()) {
 138: if (properties.containsKey(""maven.compiler.release"")) {
 139: javaVersion = properties.getProperty(""maven.compiler.release"");
 140: } else if (properties.containsKey(""maven.compiler.target"")) {
 141: javaVersion = properties.getProperty(""maven.compiler.target"");
 142: } else if (properties.containsKey(""maven.compiler.source"")) {
 143: javaVersion = properties.getProperty(""maven.compiler.source"");
 144: }
 145: }
 146: 
 147: return resolveJavaVersion(javaVersion);","private static String resolveJavaVersion(MavenProject mavenProject) {
        String javaVersion = System.getProperty(""java.version"");

        Properties properties = mavenProject.getProperties();
        if (null != properties && !properties.isEmpty()) {
            if (properties.containsKey(""maven.compiler.release"")) {
                javaVersion = properties.getProperty(""maven.compiler.release"");
            } else if (properties.containsKey(""maven.compiler.target"")) {
                javaVersion = properties.getProperty(""maven.compiler.target"");
            } else if (properties.containsKey(""maven.compiler.source"")) {
                javaVersion = properties.getProperty(""maven.compiler.source"");
            }
        }

        return resolveJavaVersion(javaVersion);
    }",1
jreleaser-1.7.0,NULL_DEREFERENCE,api/jreleaser-model-api/src/main/java/org/jreleaser/version/SemanticVersion.java,org.jreleaser.version.SemanticVersion.javaMajorVersion():int,168,object `jv` last assigned on line 167 could be null and is dereferenced at line 168.,"166: public static int javaMajorVersion() {
 167: String jv = System.getProperty(""java.version"");
 168: if (jv.startsWith(""1."")) {
 169: // this can only be Java 8
 170: return 8;
 171: }
 172: return JavaRuntimeVersion.of(jv).feature();","public static int javaMajorVersion() {
        String jv = System.getProperty(""java.version"");
        if (jv.startsWith(""1."")) {
            // this can only be Java 8
            return 8;
        }
        return JavaRuntimeVersion.of(jv).feature();
    }",1
jreleaser-1.7.0,NULL_DEREFERENCE,plugins/jreleaser/src/main/java/org/jreleaser/cli/AbstractModelCommand.java,org.jreleaser.cli.AbstractModelCommand.resolveConfigurer(java.nio.file.Path):org.jreleaser.model.internal.JReleaserContext$Configurer,180,object returned by `getFilenameExtension(configFile.getFileName().toString())` could be null and is dereferenced at line 180.,https://github.com/jreleaser/jreleaser/blob/v1.7.0/plugins/jreleaser/src/main/java/org/jreleaser/cli/AbstractModelCommand.java,"protected JReleaserContext.Configurer resolveConfigurer(Path configFile) {
        switch (StringUtils.getFilenameExtension(configFile.getFileName().toString())) {
            case ""yml"":
            case ""yaml"":
                return JReleaserContext.Configurer.CLI_YAML;
            case ""toml"":
                return JReleaserContext.Configurer.CLI_TOML;
            case ""json"":
                return JReleaserContext.Configurer.CLI_JSON;
            default:
                // should not happen!
                throw new IllegalArgumentException($(""ERROR_invalid_config_format"", configFile.getFileName()));
        }
    }",1
jreleaser-1.7.0,NULL_DEREFERENCE,plugins/jreleaser-maven-plugin/src/main/java/org/jreleaser/maven/plugin/AbstractJReleaserMojo.java,org.jreleaser.maven.plugin.AbstractJReleaserMojo.resolveConfigurer(java.io.File):org.jreleaser.model.internal.JReleaserContext$Configurer,203,object returned by `getFilenameExtension(configFile.getName())` could be null and is dereferenced at line 203.,https://github.com/jreleaser/jreleaser/blob/v1.7.0/plugins/jreleaser-maven-plugin/src/main/java/org/jreleaser/maven/plugin/AbstractJReleaserMojo.java,"protected JReleaserContext.Configurer resolveConfigurer(File configFile) {
        if (null == configFile) return JReleaserContext.Configurer.MAVEN;

        switch (StringUtils.getFilenameExtension(configFile.getName())) {
            case ""yml"":
            case ""yaml"":
                return JReleaserContext.Configurer.CLI_YAML;
            case ""toml"":
                return JReleaserContext.Configurer.CLI_TOML;
            case ""json"":
                return JReleaserContext.Configurer.CLI_JSON;
            default:
                // should not happen!
                throw new IllegalArgumentException(""Invalid configuration format: "" + configFile.getName());
        }
    }",0
jreleaser-1.7.0,NULL_DEREFERENCE,plugins/jreleaser-ant-tasks/src/main/java/org/jreleaser/ant/tasks/AbstractJReleaserTask.java,org.jreleaser.ant.tasks.AbstractJReleaserTask.resolveConfigurer(java.nio.file.Path):org.jreleaser.model.internal.JReleaserContext$Configurer,202,object returned by `getFilenameExtension(configFile.getFileName().toString())` could be null and is dereferenced at line 202.,https://github.com/jreleaser/jreleaser/blob/v1.7.0/plugins/jreleaser-ant-tasks/src/main/java/org/jreleaser/ant/tasks/AbstractJReleaserTask.java,"protected JReleaserContext.Configurer resolveConfigurer(Path configFile) {
        switch (StringUtils.getFilenameExtension(configFile.getFileName().toString())) {
            case ""yml"":
            case ""yaml"":
                return JReleaserContext.Configurer.CLI_YAML;
            case ""toml"":
                return JReleaserContext.Configurer.CLI_TOML;
            case ""json"":
                return JReleaserContext.Configurer.CLI_JSON;
            default:
                // should not happen!
                throw new IllegalArgumentException(""Invalid configuration format: "" + configFile.getFileName());
        }
    }",1
jreleaser-1.7.0,NULL_DEREFERENCE,core/jreleaser-model-impl/src/main/java/org/jreleaser/model/internal/upload/Upload.java,"org.jreleaser.model.internal.upload.Upload.resolveDownloadUrls(org.jreleaser.model.internal.JReleaserContext,org.jreleaser.model.internal.distributions.Distribution,org.jreleaser.model.internal.common.Artifact,java.lang.String):java.util.Map",571,object returned by `uploader.getType()` could be null and is dereferenced by call to `findUploadersByType(...)` at line 571.,"555: public Map<String, String> resolveDownloadUrls(JReleaserContext context, Distribution distribution, Artifact artifact, String prefix) {
 556: Map<String, String> urls = new LinkedHashMap<>();
 557: 
 558: List<Uploader<?>> uploaders = findAllActiveUploaders();
 559: for (Uploader<?> uploader : uploaders) {
 560: List<String> keys = uploader.resolveSkipKeys();
 561: if (isSkip(distribution, keys) ||
 562: isSkip(artifact, keys)) continue;
 563: String key = prefix +
 564: ""Download"" +
 565: capitalize(uploader.getType()) +
 566: getClassNameForLowerCaseHyphenSeparatedName(uploader.getName()) +
 567: ""Url"";
 568: String url = uploader.getResolvedDownloadUrl(context, artifact);
 569: urls.put(key, url);
 570: 
 571: if (findUploadersByType(uploader.getType()).size() == 1 && !isSkip(distribution, keys) &&
 572: !isSkip(artifact, keys)) {
 573: key = prefix +
 574: ""Download"" +
 575: capitalize(uploader.getType()) +
 576: ""Url"";
 577: url = uploader.getResolvedDownloadUrl(context, artifact);
 578: urls.put(key, url);
 579: }
 580: }
 581: 
 582: if (uploaders.size() == 1) {
 583: Uploader<?> uploader = uploaders.get(0);
 584: List<String> keys = uploader.resolveSkipKeys();
 585: if (!isSkip(distribution, keys) &&
 586: !isSkip(artifact, keys)) {
 587: String key = prefix + ""DownloadUrl"";
 588: String url = uploader.getResolvedDownloadUrl(context, artifact);
 589: urls.put(key, url);
 590: }
 591: }
 592: 
 593: return urls;","public Map<String, String> resolveDownloadUrls(JReleaserContext context, Distribution distribution, Artifact artifact, String prefix) {
        Map<String, String> urls = new LinkedHashMap<>();

        List<Uploader<?>> uploaders = findAllActiveUploaders();
        for (Uploader<?> uploader : uploaders) {
            List<String> keys = uploader.resolveSkipKeys();
            if (isSkip(distribution, keys) ||
                isSkip(artifact, keys)) continue;
            String key = prefix +
                ""Download"" +
                capitalize(uploader.getType()) +
                getClassNameForLowerCaseHyphenSeparatedName(uploader.getName()) +
                ""Url"";
            String url = uploader.getResolvedDownloadUrl(context, artifact);
            urls.put(key, url);

            if (findUploadersByType(uploader.getType()).size() == 1 && !isSkip(distribution, keys) &&
                !isSkip(artifact, keys)) {
                key = prefix +
                    ""Download"" +
                    capitalize(uploader.getType()) +
                    ""Url"";
                url = uploader.getResolvedDownloadUrl(context, artifact);
                urls.put(key, url);
            }
        }

        if (uploaders.size() == 1) {
            Uploader<?> uploader = uploaders.get(0);
            List<String> keys = uploader.resolveSkipKeys();
            if (!isSkip(distribution, keys) &&
                !isSkip(artifact, keys)) {
                String key = prefix + ""DownloadUrl"";
                String url = uploader.getResolvedDownloadUrl(context, artifact);
                urls.put(key, url);
            }
        }

        return urls;
    }
",0
jreleaser-1.7.0,NULL_DEREFERENCE,core/jreleaser-model-impl/src/main/java/org/jreleaser/model/internal/assemble/JpackageAssembler.java,org.jreleaser.model.internal.assemble.JpackageAssembler$AbstractPlatformPackager.merge(org.jreleaser.model.internal.assemble.JpackageAssembler$AbstractPlatformPackager):void,721,"object returned by `merge(valueOf(JpackageAssembler$AbstractPlatformPackager.enabled),valueOf(source.isEnabled()))` could be null and is dereferenced at line 721.",https://github.com/jreleaser/jreleaser/blob/v1.7.0/core/jreleaser-model-impl/src/main/java/org/jreleaser/model/internal/assemble/JpackageAssembler.java,"public void merge(S source) {
            this.icon = this.merge(this.icon, source.getIcon());
            this.appName = this.merge(this.appName, source.getAppName());
            this.enabled = this.merge(this.enabled, source.isEnabled());
            this.installDir = this.merge(this.installDir, source.getInstallDir());
            this.resourceDir = this.merge(this.resourceDir, source.getResourceDir());
            setJdk(source.getJdk());
            setTypes(merge(this.types, source.getTypes()));
        }",1
jsoup 1.16.1,NULL_DEREFERENCE,src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java,"org.jsoup.parser.HtmlTreeBuilderState$2.process(org.jsoup.parser.Token,org.jsoup.parser.HtmlTreeBuilder):boolean",54,object returned by `t.asStartTag().normalName()` could be null and is dereferenced at line 54.,"46: boolean process(Token t, HtmlTreeBuilder tb) {
 47: if (t.isDoctype()) {
 48: tb.error(this);
 49: return false;
 50: } else if (t.isComment()) {
 51: tb.insert(t.asComment());
 52: } else if (isWhitespace(t)) {
 53: tb.insert(t.asCharacter()); // out of spec - include whitespace
 54: } else if (t.isStartTag() && t.asStartTag().normalName().equals(""html"")) {
 55: tb.insert(t.asStartTag());
 56: tb.transition(BeforeHead);
 57: } else if (t.isEndTag() && (inSorted(t.asEndTag().normalName(), BeforeHtmlToHead))) {
 58: return anythingElse(t, tb);
 59: } else if (t.isEndTag()) {
 60: tb.error(this);
 61: return false;
 62: } else {
 63: return anythingElse(t, tb);
 64: }
 65: return true;","boolean process(Token t, HtmlTreeBuilder tb) {
            if (t.isDoctype()) {
                tb.error(this);
                return false;
            } else if (t.isComment()) {
                tb.insert(t.asComment());
            } else if (isWhitespace(t)) {
                tb.insert(t.asCharacter()); // out of spec - include whitespace
            } else if (t.isStartTag() && t.asStartTag().normalName().equals(""html"")) {
                tb.insert(t.asStartTag());
                tb.transition(BeforeHead);
            } else if (t.isEndTag() && (inSorted(t.asEndTag().normalName(), BeforeHtmlToHead))) {
                return anythingElse(t, tb);
            } else if (t.isEndTag()) {
                tb.error(this);
                return false;
            } else {
                return anythingElse(t, tb);
            }
            return true;
        }",0
jsoup 1.16.1,NULL_DEREFERENCE,src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java,"org.jsoup.parser.HtmlTreeBuilderState$3.process(org.jsoup.parser.Token,org.jsoup.parser.HtmlTreeBuilder):boolean",83,object returned by `t.asStartTag().normalName()` could be null and is dereferenced at line 83.,"75: boolean process(Token t, HtmlTreeBuilder tb) {
 76: if (isWhitespace(t)) {
 77: tb.insert(t.asCharacter()); // out of spec - include whitespace
 78: } else if (t.isComment()) {
 79: tb.insert(t.asComment());
 80: } else if (t.isDoctype()) {
 81: tb.error(this);
 82: return false;
 83: } else if (t.isStartTag() && t.asStartTag().normalName().equals(""html"")) {
 84: return InBody.process(t, tb); // does not transition
 85: } else if (t.isStartTag() && t.asStartTag().normalName().equals(""head"")) {
 86: Element head = tb.insert(t.asStartTag());
 87: tb.setHeadElement(head);
 88: tb.transition(InHead);
 89: } else if (t.isEndTag() && (inSorted(t.asEndTag().normalName(), BeforeHtmlToHead))) {
 90: tb.processStartTag(""head"");
 91: return tb.process(t);
 92: } else if (t.isEndTag()) {
 93: tb.error(this);
 94: return false;
 95: } else {
 96: tb.processStartTag(""head"");
 97: return tb.process(t);
 98: }
 99: return true;","boolean process(Token t, HtmlTreeBuilder tb) {
            if (isWhitespace(t)) {
                tb.insert(t.asCharacter()); // out of spec - include whitespace
            } else if (t.isComment()) {
                tb.insert(t.asComment());
            } else if (t.isDoctype()) {
                tb.error(this);
                return false;
            } else if (t.isStartTag() && t.asStartTag().normalName().equals(""html"")) {
                return InBody.process(t, tb); // does not transition
            } else if (t.isStartTag() && t.asStartTag().normalName().equals(""head"")) {
                Element head = tb.insert(t.asStartTag());
                tb.setHeadElement(head);
                tb.transition(InHead);
            } else if (t.isEndTag() && (inSorted(t.asEndTag().normalName(), BeforeHtmlToHead))) {
                tb.processStartTag(""head"");
                return tb.process(t);
            } else if (t.isEndTag()) {
                tb.error(this);
                return false;
            } else {
                tb.processStartTag(""head"");
                return tb.process(t);
            }
            return true;
        }",0
jsoup 1.16.1,NULL_DEREFERENCE,src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java,"org.jsoup.parser.HtmlTreeBuilderState$4.process(org.jsoup.parser.Token,org.jsoup.parser.HtmlTreeBuilder):boolean",118,object `name` last assigned on line 117 could be null and is dereferenced at line 118.,"103: boolean process(Token t, HtmlTreeBuilder tb) {
 104: if (isWhitespace(t)) {
 105: tb.insert(t.asCharacter()); // out of spec - include whitespace
 106: return true;
 107: }
 108: switch (t.type) {
 109: case Comment:
 110: tb.insert(t.asComment());
 111: break;
 112: case Doctype:
 113: tb.error(this);
 114: return false;
 115: case StartTag:
 116: Token.StartTag start = t.asStartTag();
 117: String name = start.normalName();
 118: if (name.equals(""html"")) {
 119: return InBody.process(t, tb);
 120: } else if (inSorted(name, InHeadEmpty)) {
 121: Element el = tb.insertEmpty(start);
 122: // jsoup special: update base the first time it is seen
 123: if (name.equals(""base"") && el.hasAttr(""href""))
 124: tb.maybeSetBaseUri(el);
 125: } else if (name.equals(""meta"")) {
 126: tb.insertEmpty(start);
 127: // todo: charset switches
 128: } else if (name.equals(""title"")) {
 129: handleRcData(start, tb);
 130: } else if (inSorted(name, InHeadRaw)) {
 131: handleRawtext(start, tb);
 132: } else if (name.equals(""noscript"")) {
 133: // else if noscript && scripting flag = true: rawtext (jsoup doesn't run script, to handle as noscript)
 134: tb.insert(start);
 135: tb.transition(InHeadNoscript);
 136: } else if (name.equals(""script"")) {
 137: // skips some script rules as won't execute them
 138: tb.tokeniser.transition(TokeniserState.ScriptData);
 139: tb.markInsertionMode();
 140: tb.transition(Text);
 141: tb.insert(start);
 142: } else if (name.equals(""head"")) {
 143: tb.error(this);
 144: return false;
 145: } else if (name.equals(""template"")) {
 146: tb.insert(start);
 147: tb.insertMarkerToFormattingElements();
 148: tb.framesetOk(false);
 149: tb.transition(InTemplate);
 150: tb.pushTemplateMode(InTemplate);
 151: } else {
 152: return anythingElse(t, tb);
 153: }
 154: break;
 155: case EndTag:
 156: Token.EndTag end = t.asEndTag();
 157: name = end.normalName();
 158: if (name.equals(""head"")) {
 159: tb.pop();
 160: tb.transition(AfterHead);
 161: } else if (inSorted(name, Constants.InHeadEnd)) {
 162: return anythingElse(t, tb);
 163: } else if (name.equals(""template"")) {
 164: if (!tb.onStack(name)) {
 165: tb.error(this);
 166: } else {
 167: tb.generateImpliedEndTags(true);
 168: if (!name.equals(tb.currentElement().normalName())) tb.error(this);
 169: tb.popStackToClose(name);
 170: tb.clearFormattingElementsToLastMarker();
 171: tb.popTemplateMode();
 172: tb.resetInsertionMode();
 173: }
 174: }
 175: else {
 176: tb.error(this);
 177: return false;
 178: }
 179: break;
 180: default:
 181: return anythingElse(t, tb);
 182: }
 183: return true;","boolean process(Token t, HtmlTreeBuilder tb) {
            if (isWhitespace(t)) {
                tb.insert(t.asCharacter()); // out of spec - include whitespace
                return true;
            }
            switch (t.type) {
                case Comment:
                    tb.insert(t.asComment());
                    break;
                case Doctype:
                    tb.error(this);
                    return false;
                case StartTag:
                    Token.StartTag start = t.asStartTag();
                    String name = start.normalName();
                    if (name.equals(""html"")) {
                        return InBody.process(t, tb);
                    } else if (inSorted(name, InHeadEmpty)) {
                        Element el = tb.insertEmpty(start);
                        // jsoup special: update base the first time it is seen
                        if (name.equals(""base"") && el.hasAttr(""href""))
                            tb.maybeSetBaseUri(el);
                    } else if (name.equals(""meta"")) {
                        tb.insertEmpty(start);
                        // todo: charset switches
                    } else if (name.equals(""title"")) {
                        handleRcData(start, tb);
                    } else if (inSorted(name, InHeadRaw)) {
                        handleRawtext(start, tb);
                    } else if (name.equals(""noscript"")) {
                        // else if noscript && scripting flag = true: rawtext (jsoup doesn't run script, to handle as noscript)
                        tb.insert(start);
                        tb.transition(InHeadNoscript);
                    } else if (name.equals(""script"")) {
                        // skips some script rules as won't execute them
                        tb.tokeniser.transition(TokeniserState.ScriptData);
                        tb.markInsertionMode();
                        tb.transition(Text);
                        tb.insert(start);
                    } else if (name.equals(""head"")) {
                        tb.error(this);
                        return false;
                    } else if (name.equals(""template"")) {
                        tb.insert(start);
                        tb.insertMarkerToFormattingElements();
                        tb.framesetOk(false);
                        tb.transition(InTemplate);
                        tb.pushTemplateMode(InTemplate);
                    } else {
                        return anythingElse(t, tb);
                    }
                    break;
                case EndTag:
                    Token.EndTag end = t.asEndTag();
                    name = end.normalName();
                    if (name.equals(""head"")) {
                        tb.pop();
                        tb.transition(AfterHead);
                    } else if (inSorted(name, Constants.InHeadEnd)) {
                        return anythingElse(t, tb);
                    } else if (name.equals(""template"")) {
                        if (!tb.onStack(name)) {
                            tb.error(this);
                        } else {
                            tb.generateImpliedEndTags(true);
                            if (!name.equals(tb.currentElement().normalName())) tb.error(this);
                            tb.popStackToClose(name);
                            tb.clearFormattingElementsToLastMarker();
                            tb.popTemplateMode();
                            tb.resetInsertionMode();
                        }
                    }
                    else {
                        tb.error(this);
                        return false;
                    }
                    break;
                default:
                    return anythingElse(t, tb);
            }
            return true;
        }",0
jsoup 1.16.1,NULL_DEREFERENCE,src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java,"org.jsoup.parser.HtmlTreeBuilderState$4.process(org.jsoup.parser.Token,org.jsoup.parser.HtmlTreeBuilder):boolean",158,object `name` last assigned on line 157 could be null and is dereferenced at line 158.,"103: boolean process(Token t, HtmlTreeBuilder tb) {
 104: if (isWhitespace(t)) {
 105: tb.insert(t.asCharacter()); // out of spec - include whitespace
 106: return true;
 107: }
 108: switch (t.type) {
 109: case Comment:
 110: tb.insert(t.asComment());
 111: break;
 112: case Doctype:
 113: tb.error(this);
 114: return false;
 115: case StartTag:
 116: Token.StartTag start = t.asStartTag();
 117: String name = start.normalName();
 118: if (name.equals(""html"")) {
 119: return InBody.process(t, tb);
 120: } else if (inSorted(name, InHeadEmpty)) {
 121: Element el = tb.insertEmpty(start);
 122: // jsoup special: update base the first time it is seen
 123: if (name.equals(""base"") && el.hasAttr(""href""))
 124: tb.maybeSetBaseUri(el);
 125: } else if (name.equals(""meta"")) {
 126: tb.insertEmpty(start);
 127: // todo: charset switches
 128: } else if (name.equals(""title"")) {
 129: handleRcData(start, tb);
 130: } else if (inSorted(name, InHeadRaw)) {
 131: handleRawtext(start, tb);
 132: } else if (name.equals(""noscript"")) {
 133: // else if noscript && scripting flag = true: rawtext (jsoup doesn't run script, to handle as noscript)
 134: tb.insert(start);
 135: tb.transition(InHeadNoscript);
 136: } else if (name.equals(""script"")) {
 137: // skips some script rules as won't execute them
 138: tb.tokeniser.transition(TokeniserState.ScriptData);
 139: tb.markInsertionMode();
 140: tb.transition(Text);
 141: tb.insert(start);
 142: } else if (name.equals(""head"")) {
 143: tb.error(this);
 144: return false;
 145: } else if (name.equals(""template"")) {
 146: tb.insert(start);
 147: tb.insertMarkerToFormattingElements();
 148: tb.framesetOk(false);
 149: tb.transition(InTemplate);
 150: tb.pushTemplateMode(InTemplate);
 151: } else {
 152: return anythingElse(t, tb);
 153: }
 154: break;
 155: case EndTag:
 156: Token.EndTag end = t.asEndTag();
 157: name = end.normalName();
 158: if (name.equals(""head"")) {
 159: tb.pop();
 160: tb.transition(AfterHead);
 161: } else if (inSorted(name, Constants.InHeadEnd)) {
 162: return anythingElse(t, tb);
 163: } else if (name.equals(""template"")) {
 164: if (!tb.onStack(name)) {
 165: tb.error(this);
 166: } else {
 167: tb.generateImpliedEndTags(true);
 168: if (!name.equals(tb.currentElement().normalName())) tb.error(this);
 169: tb.popStackToClose(name);
 170: tb.clearFormattingElementsToLastMarker();
 171: tb.popTemplateMode();
 172: tb.resetInsertionMode();
 173: }
 174: }
 175: else {
 176: tb.error(this);
 177: return false;
 178: }
 179: break;
 180: default:
 181: return anythingElse(t, tb);
 182: }
 183: return true;","boolean process(Token t, HtmlTreeBuilder tb) {
            if (isWhitespace(t)) {
                tb.insert(t.asCharacter()); // out of spec - include whitespace
                return true;
            }
            switch (t.type) {
                case Comment:
                    tb.insert(t.asComment());
                    break;
                case Doctype:
                    tb.error(this);
                    return false;
                case StartTag:
                    Token.StartTag start = t.asStartTag();
                    String name = start.normalName();
                    if (name.equals(""html"")) {
                        return InBody.process(t, tb);
                    } else if (inSorted(name, InHeadEmpty)) {
                        Element el = tb.insertEmpty(start);
                        // jsoup special: update base the first time it is seen
                        if (name.equals(""base"") && el.hasAttr(""href""))
                            tb.maybeSetBaseUri(el);
                    } else if (name.equals(""meta"")) {
                        tb.insertEmpty(start);
                        // todo: charset switches
                    } else if (name.equals(""title"")) {
                        handleRcData(start, tb);
                    } else if (inSorted(name, InHeadRaw)) {
                        handleRawtext(start, tb);
                    } else if (name.equals(""noscript"")) {
                        // else if noscript && scripting flag = true: rawtext (jsoup doesn't run script, to handle as noscript)
                        tb.insert(start);
                        tb.transition(InHeadNoscript);
                    } else if (name.equals(""script"")) {
                        // skips some script rules as won't execute them
                        tb.tokeniser.transition(TokeniserState.ScriptData);
                        tb.markInsertionMode();
                        tb.transition(Text);
                        tb.insert(start);
                    } else if (name.equals(""head"")) {
                        tb.error(this);
                        return false;
                    } else if (name.equals(""template"")) {
                        tb.insert(start);
                        tb.insertMarkerToFormattingElements();
                        tb.framesetOk(false);
                        tb.transition(InTemplate);
                        tb.pushTemplateMode(InTemplate);
                    } else {
                        return anythingElse(t, tb);
                    }
                    break;
                case EndTag:
                    Token.EndTag end = t.asEndTag();
                    name = end.normalName();
                    if (name.equals(""head"")) {
                        tb.pop();
                        tb.transition(AfterHead);
                    } else if (inSorted(name, Constants.InHeadEnd)) {
                        return anythingElse(t, tb);
                    } else if (name.equals(""template"")) {
                        if (!tb.onStack(name)) {
                            tb.error(this);
                        } else {
                            tb.generateImpliedEndTags(true);
                            if (!name.equals(tb.currentElement().normalName())) tb.error(this);
                            tb.popStackToClose(name);
                            tb.clearFormattingElementsToLastMarker();
                            tb.popTemplateMode();
                            tb.resetInsertionMode();
                        }
                    }
                    else {
                        tb.error(this);
                        return false;
                    }
                    break;
                default:
                    return anythingElse(t, tb);
            }
            return true;
        }",0
jsoup 1.16.1,NULL_DEREFERENCE,src/main/java/org/jsoup/safety/Cleaner.java,"org.jsoup.safety.Cleaner$CleaningVisitor.head(org.jsoup.nodes.Node,int):void",157,object returned by `source.parent()` could be null and is dereferenced at line 157.,https://github.com/jhy/jsoup/blob/jsoup-1.16.1/src/main/java/org/jsoup/safety/Cleaner.java,"public void head(Node source, int depth) {
            if (source instanceof Element) {
                Element sourceEl = (Element) source;

                if (safelist.isSafeTag(sourceEl.normalName())) { // safe, clone and copy safe attrs
                    ElementMeta meta = createSafeElement(sourceEl);
                    Element destChild = meta.el;
                    destination.appendChild(destChild);

                    numDiscarded += meta.numAttribsDiscarded;
                    destination = destChild;
                } else if (source != root) { // not a safe tag, so don't add. don't count root against discarded.
                    numDiscarded++;
                }
            } else if (source instanceof TextNode) {
                TextNode sourceText = (TextNode) source;
                TextNode destText = new TextNode(sourceText.getWholeText());
                destination.appendChild(destText);
            } else if (source instanceof DataNode && safelist.isSafeTag(source.parent().nodeName())) {
              DataNode sourceData = (DataNode) source;
              DataNode destData = new DataNode(sourceData.getWholeData());
              destination.appendChild(destData);
            } else { // else, we don't care about comments, xml proc instructions, etc
                numDiscarded++;
            }
        }",0
jsoup 1.16.1,NULL_DEREFERENCE,src/main/java/org/jsoup/parser/Token.java,org.jsoup.parser.Token$Tag.newAttribute():void,148,object `name` last assigned on line 147 could be null and is dereferenced at line 148.,"141: final void newAttribute() {
 142: if (attributes == null)
 143: attributes = new Attributes();
 144: 
 145: if (hasAttrName && attributes.size() < MaxAttributes) {
 146: // the tokeniser has skipped whitespace control chars, but trimming could collapse to empty for other control codes, so verify here
 147: String name = attrName.length() > 0 ? attrName.toString() : attrNameS;
 148: name = name.trim();
 149: if (name.length() > 0) {
 150: String value;
 151: if (hasAttrValue)
 152: value = attrValue.length() > 0 ? attrValue.toString() : attrValueS;
 153: else if (hasEmptyAttrValue)
 154: value = """";
 155: else
 156: value = null;
 157: // note that we add, not put. So that the first is kept, and rest are deduped, once in a context where case sensitivity is known (the appropriate tree builder).
 158: attributes.add(name, value);
 159: }
 160: }
 161: reset(attrName);
 162: attrNameS = null;
 163: hasAttrName = false;
 164: 
 165: reset(attrValue);
 166: attrValueS = null;
 167: hasAttrValue = false;
 168: hasEmptyAttrValue = false;","final void newAttribute() {
            if (attributes == null)
                attributes = new Attributes();

            if (hasAttrName && attributes.size() < MaxAttributes) {
                // the tokeniser has skipped whitespace control chars, but trimming could collapse to empty for other control codes, so verify here
                String name = attrName.length() > 0 ? attrName.toString() : attrNameS;
                name = name.trim();
                if (name.length() > 0) {
                    String value;
                    if (hasAttrValue)
                        value = attrValue.length() > 0 ? attrValue.toString() : attrValueS;
                    else if (hasEmptyAttrValue)
                        value = """";
                    else
                        value = null;
                    // note that we add, not put. So that the first is kept, and rest are deduped, once in a context where case sensitivity is known (the appropriate tree builder).
                    attributes.add(name, value);
                }
            }
            reset(attrName);
            attrNameS = null;
            hasAttrName = false;

            reset(attrValue);
            attrValueS = null;
            hasAttrValue = false;
            hasEmptyAttrValue = false;
        }

        final boolean hasAttributes() {
            return attributes != null;
        }",0
jsoup 1.16.1,NULL_DEREFERENCE,src/main/java/org/jsoup/select/Elements.java,org.jsoup.select.Elements.val():java.lang.String,188,object returned by `first()` could be null and is dereferenced at line 188.,https://github.com/jhy/jsoup/blob/jsoup-1.16.1/src/main/java/org/jsoup/select/Elements.java,"public String val() {
        if (size() > 0)
            //noinspection ConstantConditions
            return first().val(); // first() != null as size() > 0
        else
            return """";
    }",1
jsoup 1.16.1,NULL_DEREFERENCE,src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java,"org.jsoup.parser.HtmlTreeBuilderState$5.process(org.jsoup.parser.Token,org.jsoup.parser.HtmlTreeBuilder):boolean",197,object returned by `t.asEndTag().normalName()` could be null and is dereferenced at line 197.,"192: boolean process(Token t, HtmlTreeBuilder tb) {
 193: if (t.isDoctype()) {
 194: tb.error(this);
 195: } else if (t.isStartTag() && t.asStartTag().normalName().equals(""html"")) {
 196: return tb.process(t, InBody);
 197: } else if (t.isEndTag() && t.asEndTag().normalName().equals(""noscript"")) {
 198: tb.pop();
 199: tb.transition(InHead);
 200: } else if (isWhitespace(t) || t.isComment() || (t.isStartTag() && inSorted(t.asStartTag().normalName(),
 201: InHeadNoScriptHead))) {
 202: return tb.process(t, InHead);
 203: } else if (t.isEndTag() && t.asEndTag().normalName().equals(""br"")) {
 204: return anythingElse(t, tb);
 205: } else if ((t.isStartTag() && inSorted(t.asStartTag().normalName(), InHeadNoscriptIgnore)) || t.isEndTag()) {
 206: tb.error(this);
 207: return false;
 208: } else {
 209: return anythingElse(t, tb);
 210: }
 211: return true;","boolean process(Token t, HtmlTreeBuilder tb) {
            if (t.isDoctype()) {
                tb.error(this);
            } else if (t.isStartTag() && t.asStartTag().normalName().equals(""html"")) {
                return tb.process(t, InBody);
            } else if (t.isEndTag() && t.asEndTag().normalName().equals(""noscript"")) {
                tb.pop();
                tb.transition(InHead);
            } else if (isWhitespace(t) || t.isComment() || (t.isStartTag() && inSorted(t.asStartTag().normalName(),
                    InHeadNoScriptHead))) {
                return tb.process(t, InHead);
            } else if (t.isEndTag() && t.asEndTag().normalName().equals(""br"")) {
                return anythingElse(t, tb);
            } else if ((t.isStartTag() && inSorted(t.asStartTag().normalName(), InHeadNoscriptIgnore)) || t.isEndTag()) {
                tb.error(this);
                return false;
            } else {
                return anythingElse(t, tb);
            }
            return true;
        }",0
jsoup 1.16.1,NULL_DEREFERENCE,src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java,"org.jsoup.parser.HtmlTreeBuilderState$5.process(org.jsoup.parser.Token,org.jsoup.parser.HtmlTreeBuilder):boolean",195,object returned by `t.asStartTag().normalName()` could be null and is dereferenced at line 195.,"192: boolean process(Token t, HtmlTreeBuilder tb) {
 193: if (t.isDoctype()) {
 194: tb.error(this);
 195: } else if (t.isStartTag() && t.asStartTag().normalName().equals(""html"")) {
 196: return tb.process(t, InBody);
 197: } else if (t.isEndTag() && t.asEndTag().normalName().equals(""noscript"")) {
 198: tb.pop();
 199: tb.transition(InHead);
 200: } else if (isWhitespace(t) || t.isComment() || (t.isStartTag() && inSorted(t.asStartTag().normalName(),
 201: InHeadNoScriptHead))) {
 202: return tb.process(t, InHead);
 203: } else if (t.isEndTag() && t.asEndTag().normalName().equals(""br"")) {
 204: return anythingElse(t, tb);
 205: } else if ((t.isStartTag() && inSorted(t.asStartTag().normalName(), InHeadNoscriptIgnore)) || t.isEndTag()) {
 206: tb.error(this);
 207: return false;
 208: } else {
 209: return anythingElse(t, tb);
 210: }
 211: return true;","boolean process(Token t, HtmlTreeBuilder tb) {
            if (t.isDoctype()) {
                tb.error(this);
            } else if (t.isStartTag() && t.asStartTag().normalName().equals(""html"")) {
                return tb.process(t, InBody);
            } else if (t.isEndTag() && t.asEndTag().normalName().equals(""noscript"")) {
                tb.pop();
                tb.transition(InHead);
            } else if (isWhitespace(t) || t.isComment() || (t.isStartTag() && inSorted(t.asStartTag().normalName(),
                    InHeadNoScriptHead))) {
                return tb.process(t, InHead);
            } else if (t.isEndTag() && t.asEndTag().normalName().equals(""br"")) {
                return anythingElse(t, tb);
            } else if ((t.isStartTag() && inSorted(t.asStartTag().normalName(), InHeadNoscriptIgnore)) || t.isEndTag()) {
                tb.error(this);
                return false;
            } else {
                return anythingElse(t, tb);
            }
            return true;
        }",0
jsoup 1.16.1,NULL_DEREFERENCE,src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java,"org.jsoup.parser.HtmlTreeBuilderState$6.process(org.jsoup.parser.Token,org.jsoup.parser.HtmlTreeBuilder):boolean",234,object `name` last assigned on line 233 could be null and is dereferenced at line 234.,"224: boolean process(Token t, HtmlTreeBuilder tb) {
 225: if (isWhitespace(t)) {
 226: tb.insert(t.asCharacter());
 227: } else if (t.isComment()) {
 228: tb.insert(t.asComment());
 229: } else if (t.isDoctype()) {
 230: tb.error(this);
 231: } else if (t.isStartTag()) {
 232: Token.StartTag startTag = t.asStartTag();
 233: String name = startTag.normalName();
 234: if (name.equals(""html"")) {
 235: return tb.process(t, InBody);
 236: } else if (name.equals(""body"")) {
 237: tb.insert(startTag);
 238: tb.framesetOk(false);
 239: tb.transition(InBody);
 240: } else if (name.equals(""frameset"")) {
 241: tb.insert(startTag);
 242: tb.transition(InFrameset);
 243: } else if (inSorted(name, InBodyStartToHead)) {
 244: tb.error(this);
 245: Element head = tb.getHeadElement();
 246: tb.push(head);
 247: tb.process(t, InHead);
 248: tb.removeFromStack(head);
 249: } else if (name.equals(""head"")) {
 250: tb.error(this);
 251: return false;
 252: } else {
 253: anythingElse(t, tb);
 254: }
 255: } else if (t.isEndTag()) {
 256: String name = t.asEndTag().normalName();
 257: if (inSorted(name, AfterHeadBody)) {
 258: anythingElse(t, tb);
 259: } else if (name.equals(""template"")) {
 260: tb.process(t, InHead);
 261: }
 262: else {
 263: tb.error(this);
 264: return false;
 265: }
 266: } else {
 267: anythingElse(t, tb);
 268: }
 269: return true;","boolean process(Token t, HtmlTreeBuilder tb) {
            if (isWhitespace(t)) {
                tb.insert(t.asCharacter());
            } else if (t.isComment()) {
                tb.insert(t.asComment());
            } else if (t.isDoctype()) {
                tb.error(this);
            } else if (t.isStartTag()) {
                Token.StartTag startTag = t.asStartTag();
                String name = startTag.normalName();
                if (name.equals(""html"")) {
                    return tb.process(t, InBody);
                } else if (name.equals(""body"")) {
                    tb.insert(startTag);
                    tb.framesetOk(false);
                    tb.transition(InBody);
                } else if (name.equals(""frameset"")) {
                    tb.insert(startTag);
                    tb.transition(InFrameset);
                } else if (inSorted(name, InBodyStartToHead)) {
                    tb.error(this);
                    Element head = tb.getHeadElement();
                    tb.push(head);
                    tb.process(t, InHead);
                    tb.removeFromStack(head);
                } else if (name.equals(""head"")) {
                    tb.error(this);
                    return false;
                } else {
                    anythingElse(t, tb);
                }
            } else if (t.isEndTag()) {
                String name = t.asEndTag().normalName();
                if (inSorted(name, AfterHeadBody)) {
                    anythingElse(t, tb);
                } else if (name.equals(""template"")) {
                    tb.process(t, InHead);
                }
                else {
                    tb.error(this);
                    return false;
                }
            } else {
                anythingElse(t, tb);
            }
            return true;
        }
",0
jsoup 1.16.1,NULL_DEREFERENCE,src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java,"org.jsoup.parser.HtmlTreeBuilderState$6.process(org.jsoup.parser.Token,org.jsoup.parser.HtmlTreeBuilder):boolean",259,object `name` last assigned on line 256 could be null and is dereferenced at line 259.,"224: boolean process(Token t, HtmlTreeBuilder tb) {
 225: if (isWhitespace(t)) {
 226: tb.insert(t.asCharacter());
 227: } else if (t.isComment()) {
 228: tb.insert(t.asComment());
 229: } else if (t.isDoctype()) {
 230: tb.error(this);
 231: } else if (t.isStartTag()) {
 232: Token.StartTag startTag = t.asStartTag();
 233: String name = startTag.normalName();
 234: if (name.equals(""html"")) {
 235: return tb.process(t, InBody);
 236: } else if (name.equals(""body"")) {
 237: tb.insert(startTag);
 238: tb.framesetOk(false);
 239: tb.transition(InBody);
 240: } else if (name.equals(""frameset"")) {
 241: tb.insert(startTag);
 242: tb.transition(InFrameset);
 243: } else if (inSorted(name, InBodyStartToHead)) {
 244: tb.error(this);
 245: Element head = tb.getHeadElement();
 246: tb.push(head);
 247: tb.process(t, InHead);
 248: tb.removeFromStack(head);
 249: } else if (name.equals(""head"")) {
 250: tb.error(this);
 251: return false;
 252: } else {
 253: anythingElse(t, tb);
 254: }
 255: } else if (t.isEndTag()) {
 256: String name = t.asEndTag().normalName();
 257: if (inSorted(name, AfterHeadBody)) {
 258: anythingElse(t, tb);
 259: } else if (name.equals(""template"")) {
 260: tb.process(t, InHead);
 261: }
 262: else {
 263: tb.error(this);
 264: return false;
 265: }
 266: } else {
 267: anythingElse(t, tb);
 268: }
 269: return true;","boolean process(Token t, HtmlTreeBuilder tb) {
            if (isWhitespace(t)) {
                tb.insert(t.asCharacter());
            } else if (t.isComment()) {
                tb.insert(t.asComment());
            } else if (t.isDoctype()) {
                tb.error(this);
            } else if (t.isStartTag()) {
                Token.StartTag startTag = t.asStartTag();
                String name = startTag.normalName();
                if (name.equals(""html"")) {
                    return tb.process(t, InBody);
                } else if (name.equals(""body"")) {
                    tb.insert(startTag);
                    tb.framesetOk(false);
                    tb.transition(InBody);
                } else if (name.equals(""frameset"")) {
                    tb.insert(startTag);
                    tb.transition(InFrameset);
                } else if (inSorted(name, InBodyStartToHead)) {
                    tb.error(this);
                    Element head = tb.getHeadElement();
                    tb.push(head);
                    tb.process(t, InHead);
                    tb.removeFromStack(head);
                } else if (name.equals(""head"")) {
                    tb.error(this);
                    return false;
                } else {
                    anythingElse(t, tb);
                }
            } else if (t.isEndTag()) {
                String name = t.asEndTag().normalName();
                if (inSorted(name, AfterHeadBody)) {
                    anythingElse(t, tb);
                } else if (name.equals(""template"")) {
                    tb.process(t, InHead);
                }
                else {
                    tb.error(this);
                    return false;
                }
            } else {
                anythingElse(t, tb);
            }
            return true;
        }
",0
jsoup 1.16.1,NULL_DEREFERENCE,src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java,"org.jsoup.parser.HtmlTreeBuilderState$7.inBodyEndTag(org.jsoup.parser.Token,org.jsoup.parser.HtmlTreeBuilder):boolean",705,object `name` last assigned on line 703 could be null and is dereferenced at line 705.,"701: private boolean inBodyEndTag(Token t, HtmlTreeBuilder tb) {
 702: final Token.EndTag endTag = t.asEndTag();
 703: final String name = endTag.normalName();
 704: 
 705: switch (name) {
 706: case ""template"":
 707: tb.process(t, InHead);
 708: break;
 709: case ""sarcasm"": // *sigh*
 710: case ""span"":
 711: // same as final fall through, but saves short circuit
 712: return anyOtherEndTag(t, tb);
 713: case ""li"":
 714: if (!tb.inListItemScope(name)) {
 715: tb.error(this);
 716: return false;
 717: } else {
 718: tb.generateImpliedEndTags(name);
 719: if (!tb.currentElementIs(name))
 720: tb.error(this);
 721: tb.popStackToClose(name);
 722: }
 723: break;
 724: case ""body"":
 725: if (!tb.inScope(""body"")) {
 726: tb.error(this);
 727: return false;
 728: } else {
 729: if (tb.onStackNot(InBodyEndOtherErrors))
 730: tb.error(this);
 731: tb.transition(AfterBody);
 732: }
 733: break;
 734: case ""html"":
 735: if (!tb.onStack(""body"")) {
 736: tb.error(this);
 737: return false; // ignore
 738: } else {
 739: if (tb.onStackNot(InBodyEndOtherErrors))
 740: tb.error(this);
 741: tb.transition(AfterBody);
 742: return tb.process(t); // re-process
 743: }
 744: 
 745: case ""form"":
 746: if (!tb.onStack(""template"")) {
 747: Element currentForm = tb.getFormElement();
 748: tb.setFormElement(null);
 749: if (currentForm == null || !tb.inScope(name)) {
 750: tb.error(this);
 751: return false;
 752: }
 753: tb.generateImpliedEndTags();
 754: if (!tb.currentElementIs(name))
 755: tb.error(this);
 756: // remove currentForm from stack. will shift anything under up.
 757: tb.removeFromStack(currentForm);
 758: } else { // template on stack
 759: if (!tb.inScope(name)) {
 760: tb.error(this);
 761: return false;
 762: }
 763: tb.generateImpliedEndTags();
 764: if (!tb.currentElementIs(name)) tb.error(this);
 765: tb.popStackToClose(name);
 766: }
 767: break;
 768: case ""p"":
 769: if (!tb.inButtonScope(name)) {
 770: tb.error(this);
 771: tb.processStartTag(name); // if no p to close, creates an empty <p></p>
 772: return tb.process(endTag);
 773: } else {
 774: tb.generateImpliedEndTags(name);
 775: if (!tb.currentElementIs(name))
 776: tb.error(this);
 777: tb.popStackToClose(name);
 778: }
 779: break;
 780: case ""dd"":
 781: case ""dt"":
 782: if (!tb.inScope(name)) {
 783: tb.error(this);
 784: return false;
 785: } else {
 786: tb.generateImpliedEndTags(name);
 787: if (!tb.currentElementIs(name))
 788: tb.error(this);
 789: tb.popStackToClose(name);
 790: }
 791: break;
 792: case ""h1"":
 793: case ""h2"":
 794: case ""h3"":
 795: case ""h4"":
 796: case ""h5"":
 797: case ""h6"":
 798: if (!tb.inScope(Constants.Headings)) {
 799: tb.error(this);
 800: return false;
 801: } else {
 802: tb.generateImpliedEndTags(name);
 803: if (!tb.currentElementIs(name))
 804: tb.error(this);
 805: tb.popStackToClose(Constants.Headings);
 806: }
 807: break;
 808: case ""br"":
 809: tb.error(this);
 810: tb.processStartTag(""br"");
 811: return false;
 812: default:
 813: // todo - move rest to switch if desired
 814: if (inSorted(name, Constants.InBodyEndAdoptionFormatters)) {
 815: return inBodyEndTagAdoption(t, tb);
 816: } else if (inSorted(name, Constants.InBodyEndClosers)) {
 817: if (!tb.inScope(name)) {
 818: // nothing to close
 819: tb.error(this);
 820: return false;
 821: } else {
 822: tb.generateImpliedEndTags();
 823: if (!tb.currentElementIs(name))
 824: tb.error(this);
 825: tb.popStackToClose(name);
 826: }
 827: } else if (inSorted(name, Constants.InBodyStartApplets)) {
 828: if (!tb.inScope(""name"")) {
 829: if (!tb.inScope(name)) {
 830: tb.error(this);
 831: return false;
 832: }
 833: tb.generateImpliedEndTags();
 834: if (!tb.currentElementIs(name))
 835: tb.error(this);
 836: tb.popStackToClose(name);
 837: tb.clearFormattingElementsToLastMarker();
 838: }
 839: } else {
 840: return anyOtherEndTag(t, tb);
 841: }
 842: }
 843: return true;","private boolean inBodyEndTag(Token t, HtmlTreeBuilder tb) {
            final Token.EndTag endTag = t.asEndTag();
            final String name = endTag.normalName();

            switch (name) {
                case ""template"":
                    tb.process(t, InHead);
                    break;
                case ""sarcasm"": // *sigh*
                case ""span"":
                    // same as final fall through, but saves short circuit
                    return anyOtherEndTag(t, tb);
                case ""li"":
                    if (!tb.inListItemScope(name)) {
                        tb.error(this);
                        return false;
                    } else {
                        tb.generateImpliedEndTags(name);
                        if (!tb.currentElementIs(name))
                            tb.error(this);
                        tb.popStackToClose(name);
                    }
                    break;
                case ""body"":
                    if (!tb.inScope(""body"")) {
                        tb.error(this);
                        return false;
                    } else {
                        if (tb.onStackNot(InBodyEndOtherErrors))
                            tb.error(this);
                        tb.transition(AfterBody);
                    }
                    break;
                case ""html"":
                    if (!tb.onStack(""body"")) {
                        tb.error(this);
                        return false; // ignore
                    } else {
                        if (tb.onStackNot(InBodyEndOtherErrors))
                            tb.error(this);
                        tb.transition(AfterBody);
                        return tb.process(t); // re-process
                    }

                case ""form"":
                    if (!tb.onStack(""template"")) {
                        Element currentForm = tb.getFormElement();
                        tb.setFormElement(null);
                        if (currentForm == null || !tb.inScope(name)) {
                            tb.error(this);
                            return false;
                        }
                        tb.generateImpliedEndTags();
                        if (!tb.currentElementIs(name))
                            tb.error(this);
                        // remove currentForm from stack. will shift anything under up.
                        tb.removeFromStack(currentForm);
                    } else { // template on stack
                        if (!tb.inScope(name)) {
                            tb.error(this);
                            return false;
                        }
                        tb.generateImpliedEndTags();
                        if (!tb.currentElementIs(name)) tb.error(this);
                        tb.popStackToClose(name);
                    }
                    break;
                case ""p"":
                    if (!tb.inButtonScope(name)) {
                        tb.error(this);
                        tb.processStartTag(name); // if no p to close, creates an empty <p></p>
                        return tb.process(endTag);
                    } else {
                        tb.generateImpliedEndTags(name);
                        if (!tb.currentElementIs(name))
                            tb.error(this);
                        tb.popStackToClose(name);
                    }
                    break;
                case ""dd"":
                case ""dt"":
                    if (!tb.inScope(name)) {
                        tb.error(this);
                        return false;
                    } else {
                        tb.generateImpliedEndTags(name);
                        if (!tb.currentElementIs(name))
                            tb.error(this);
                        tb.popStackToClose(name);
                    }
                    break;
                case ""h1"":
                case ""h2"":
                case ""h3"":
                case ""h4"":
                case ""h5"":
                case ""h6"":
                    if (!tb.inScope(Constants.Headings)) {
                        tb.error(this);
                        return false;
                    } else {
                        tb.generateImpliedEndTags(name);
                        if (!tb.currentElementIs(name))
                            tb.error(this);
                        tb.popStackToClose(Constants.Headings);
                    }
                    break;
                case ""br"":
                    tb.error(this);
                    tb.processStartTag(""br"");
                    return false;
                default:
                    // todo - move rest to switch if desired
                    if (inSorted(name, Constants.InBodyEndAdoptionFormatters)) {
                        return inBodyEndTagAdoption(t, tb);
                    } else if (inSorted(name, Constants.InBodyEndClosers)) {
                        if (!tb.inScope(name)) {
                            // nothing to close
                            tb.error(this);
                            return false;
                        } else {
                            tb.generateImpliedEndTags();
                            if (!tb.currentElementIs(name))
                                tb.error(this);
                            tb.popStackToClose(name);
                        }
                    } else if (inSorted(name, Constants.InBodyStartApplets)) {
                        if (!tb.inScope(""name"")) {
                            if (!tb.inScope(name)) {
                                tb.error(this);
                                return false;
                            }
                            tb.generateImpliedEndTags();
                            if (!tb.currentElementIs(name))
                                tb.error(this);
                            tb.popStackToClose(name);
                            tb.clearFormattingElementsToLastMarker();
                        }
                    } else {
                        return anyOtherEndTag(t, tb);
                    }
            }
            return true;
        }
",0
jsoup 1.16.1,NULL_DEREFERENCE,src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java,"org.jsoup.parser.HtmlTreeBuilderState$9.process(org.jsoup.parser.Token,org.jsoup.parser.HtmlTreeBuilder):boolean",1010,object `name` last assigned on line 1009 could be null and is dereferenced at line 1010.,"995: boolean process(Token t, HtmlTreeBuilder tb) {
 996: if (t.isCharacter() && inSorted(tb.currentElement().normalName(), InTableFoster)) {
 997: tb.resetPendingTableCharacters();
 998: tb.markInsertionMode();
 999: tb.transition(InTableText);
1000: return tb.process(t);
1001: } else if (t.isComment()) {
1002: tb.insert(t.asComment());
1003: return true;
1004: } else if (t.isDoctype()) {
1005: tb.error(this);
1006: return false;
1007: } else if (t.isStartTag()) {
1008: Token.StartTag startTag = t.asStartTag();
1009: String name = startTag.normalName();
1010: if (name.equals(""caption"")) {
1011: tb.clearStackToTableContext();
1012: tb.insertMarkerToFormattingElements();
1013: tb.insert(startTag);
1014: tb.transition(InCaption);
1015: } else if (name.equals(""colgroup"")) {
1016: tb.clearStackToTableContext();
1017: tb.insert(startTag);
1018: tb.transition(InColumnGroup);
1019: } else if (name.equals(""col"")) {
1020: tb.clearStackToTableContext();
1021: tb.processStartTag(""colgroup"");
1022: return tb.process(t);
1023: } else if (inSorted(name, InTableToBody)) {
1024: tb.clearStackToTableContext();
1025: tb.insert(startTag);
1026: tb.transition(InTableBody);
1027: } else if (inSorted(name, InTableAddBody)) {
1028: tb.clearStackToTableContext();
1029: tb.processStartTag(""tbody"");
1030: return tb.process(t);
1031: } else if (name.equals(""table"")) {
1032: tb.error(this);
1033: if (!tb.inTableScope(name)) { // ignore it
1034: return false;
1035: } else {
1036: tb.popStackToClose(name);
1037: if (!tb.resetInsertionMode()) {
1038: // not per spec - but haven't transitioned out of table. so try something else
1039: tb.insert(startTag);
1040: return true;
1041: }
1042: return tb.process(t);
1043: }
1044: } else if (inSorted(name, InTableToHead)) {
1045: return tb.process(t, InHead);
1046: } else if (name.equals(""input"")) {
1047: if (!(startTag.hasAttributes() && startTag.attributes.get(""type"").equalsIgnoreCase(""hidden""))) {
1048: return anythingElse(t, tb);
1049: } else {
1050: tb.insertEmpty(startTag);
1051: }
1052: } else if (name.equals(""form"")) {
1053: tb.error(this);
1054: if (tb.getFormElement() != null || tb.onStack(""template""))
1055: return false;
1056: else {
1057: tb.insertForm(startTag, false, false); // not added to stack. can associate to template
1058: }
1059: } else {
1060: return anythingElse(t, tb);
1061: }
1062: return true; // todo: check if should return processed http://www.whatwg.org/specs/web-apps/current-work/multipage/tree-construction.html#parsing-main-intable
1063: } else if (t.isEndTag()) {
1064: Token.EndTag endTag = t.asEndTag();
1065: String name = endTag.normalName();
1066: 
1067: if (name.equals(""table"")) {
1068: if (!tb.inTableScope(name)) {
1069: tb.error(this);
1070: return false;
1071: } else {
1072: tb.popStackToClose(""table"");
1073: tb.resetInsertionMode();
1074: }
1075: } else if (inSorted(name, InTableEndErr)) {
1076: tb.error(this);
1077: return false;
1078: } else if (name.equals(""template"")) {
1079: tb.process(t, InHead);
1080: } else {
1081: return anythingElse(t, tb);
1082: }
1083: return true; // todo: as above todo
1084: } else if (t.isEOF()) {
1085: if (tb.currentElementIs(""html""))
1086: tb.error(this);
1087: return true; // stops parsing
1088: }
1089: return anythingElse(t, tb);","boolean process(Token t, HtmlTreeBuilder tb) {
            if (t.isCharacter() && inSorted(tb.currentElement().normalName(), InTableFoster)) {
                tb.resetPendingTableCharacters();
                tb.markInsertionMode();
                tb.transition(InTableText);
                return tb.process(t);
            } else if (t.isComment()) {
                tb.insert(t.asComment());
                return true;
            } else if (t.isDoctype()) {
                tb.error(this);
                return false;
            } else if (t.isStartTag()) {
                Token.StartTag startTag = t.asStartTag();
                String name = startTag.normalName();
                if (name.equals(""caption"")) {
                    tb.clearStackToTableContext();
                    tb.insertMarkerToFormattingElements();
                    tb.insert(startTag);
                    tb.transition(InCaption);
                } else if (name.equals(""colgroup"")) {
                    tb.clearStackToTableContext();
                    tb.insert(startTag);
                    tb.transition(InColumnGroup);
                } else if (name.equals(""col"")) {
                    tb.clearStackToTableContext();
                    tb.processStartTag(""colgroup"");
                    return tb.process(t);
                } else if (inSorted(name, InTableToBody)) {
                    tb.clearStackToTableContext();
                    tb.insert(startTag);
                    tb.transition(InTableBody);
                } else if (inSorted(name, InTableAddBody)) {
                    tb.clearStackToTableContext();
                    tb.processStartTag(""tbody"");
                    return tb.process(t);
                } else if (name.equals(""table"")) {
                    tb.error(this);
                    if (!tb.inTableScope(name)) { // ignore it
                        return false;
                    } else {
                        tb.popStackToClose(name);
                        if (!tb.resetInsertionMode()) {
                            // not per spec - but haven't transitioned out of table. so try something else
                            tb.insert(startTag);
                            return true;
                        }
                        return tb.process(t);
                    }
                } else if (inSorted(name, InTableToHead)) {
                    return tb.process(t, InHead);
                } else if (name.equals(""input"")) {
                    if (!(startTag.hasAttributes() && startTag.attributes.get(""type"").equalsIgnoreCase(""hidden""))) {
                        return anythingElse(t, tb);
                    } else {
                        tb.insertEmpty(startTag);
                    }
                } else if (name.equals(""form"")) {
                    tb.error(this);
                    if (tb.getFormElement() != null || tb.onStack(""template""))
                        return false;
                    else {
                        tb.insertForm(startTag, false, false); // not added to stack. can associate to template
                    }
                } else {
                    return anythingElse(t, tb);
                }
                return true; // todo: check if should return processed http://www.whatwg.org/specs/web-apps/current-work/multipage/tree-construction.html#parsing-main-intable
            } else if (t.isEndTag()) {
                Token.EndTag endTag = t.asEndTag();
                String name = endTag.normalName();

                if (name.equals(""table"")) {
                    if (!tb.inTableScope(name)) {
                        tb.error(this);
                        return false;
                    } else {
                        tb.popStackToClose(""table"");
                        tb.resetInsertionMode();
                    }
                } else if (inSorted(name, InTableEndErr)) {
                    tb.error(this);
                    return false;
                } else if (name.equals(""template"")) {
                    tb.process(t, InHead);
                } else {
                    return anythingElse(t, tb);
                }
                return true; // todo: as above todo
            } else if (t.isEOF()) {
                if (tb.currentElementIs(""html""))
                    tb.error(this);
                return true; // stops parsing
            }
            return anythingElse(t, tb);
        }
",0
jsoup 1.16.1,NULL_DEREFERENCE,src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java,"org.jsoup.parser.HtmlTreeBuilderState$9.process(org.jsoup.parser.Token,org.jsoup.parser.HtmlTreeBuilder):boolean",1067,object `name` last assigned on line 1065 could be null and is dereferenced at line 1067.,"995: boolean process(Token t, HtmlTreeBuilder tb) {
 996: if (t.isCharacter() && inSorted(tb.currentElement().normalName(), InTableFoster)) {
 997: tb.resetPendingTableCharacters();
 998: tb.markInsertionMode();
 999: tb.transition(InTableText);
1000: return tb.process(t);
1001: } else if (t.isComment()) {
1002: tb.insert(t.asComment());
1003: return true;
1004: } else if (t.isDoctype()) {
1005: tb.error(this);
1006: return false;
1007: } else if (t.isStartTag()) {
1008: Token.StartTag startTag = t.asStartTag();
1009: String name = startTag.normalName();
1010: if (name.equals(""caption"")) {
1011: tb.clearStackToTableContext();
1012: tb.insertMarkerToFormattingElements();
1013: tb.insert(startTag);
1014: tb.transition(InCaption);
1015: } else if (name.equals(""colgroup"")) {
1016: tb.clearStackToTableContext();
1017: tb.insert(startTag);
1018: tb.transition(InColumnGroup);
1019: } else if (name.equals(""col"")) {
1020: tb.clearStackToTableContext();
1021: tb.processStartTag(""colgroup"");
1022: return tb.process(t);
1023: } else if (inSorted(name, InTableToBody)) {
1024: tb.clearStackToTableContext();
1025: tb.insert(startTag);
1026: tb.transition(InTableBody);
1027: } else if (inSorted(name, InTableAddBody)) {
1028: tb.clearStackToTableContext();
1029: tb.processStartTag(""tbody"");
1030: return tb.process(t);
1031: } else if (name.equals(""table"")) {
1032: tb.error(this);
1033: if (!tb.inTableScope(name)) { // ignore it
1034: return false;
1035: } else {
1036: tb.popStackToClose(name);
1037: if (!tb.resetInsertionMode()) {
1038: // not per spec - but haven't transitioned out of table. so try something else
1039: tb.insert(startTag);
1040: return true;
1041: }
1042: return tb.process(t);
1043: }
1044: } else if (inSorted(name, InTableToHead)) {
1045: return tb.process(t, InHead);
1046: } else if (name.equals(""input"")) {
1047: if (!(startTag.hasAttributes() && startTag.attributes.get(""type"").equalsIgnoreCase(""hidden""))) {
1048: return anythingElse(t, tb);
1049: } else {
1050: tb.insertEmpty(startTag);
1051: }
1052: } else if (name.equals(""form"")) {
1053: tb.error(this);
1054: if (tb.getFormElement() != null || tb.onStack(""template""))
1055: return false;
1056: else {
1057: tb.insertForm(startTag, false, false); // not added to stack. can associate to template
1058: }
1059: } else {
1060: return anythingElse(t, tb);
1061: }
1062: return true; // todo: check if should return processed http://www.whatwg.org/specs/web-apps/current-work/multipage/tree-construction.html#parsing-main-intable
1063: } else if (t.isEndTag()) {
1064: Token.EndTag endTag = t.asEndTag();
1065: String name = endTag.normalName();
1066: 
1067: if (name.equals(""table"")) {
1068: if (!tb.inTableScope(name)) {
1069: tb.error(this);
1070: return false;
1071: } else {
1072: tb.popStackToClose(""table"");
1073: tb.resetInsertionMode();
1074: }
1075: } else if (inSorted(name, InTableEndErr)) {
1076: tb.error(this);
1077: return false;
1078: } else if (name.equals(""template"")) {
1079: tb.process(t, InHead);
1080: } else {
1081: return anythingElse(t, tb);
1082: }
1083: return true; // todo: as above todo
1084: } else if (t.isEOF()) {
1085: if (tb.currentElementIs(""html""))
1086: tb.error(this);
1087: return true; // stops parsing
1088: }
1089: return anythingElse(t, tb);","boolean process(Token t, HtmlTreeBuilder tb) {
            if (t.isCharacter() && inSorted(tb.currentElement().normalName(), InTableFoster)) {
                tb.resetPendingTableCharacters();
                tb.markInsertionMode();
                tb.transition(InTableText);
                return tb.process(t);
            } else if (t.isComment()) {
                tb.insert(t.asComment());
                return true;
            } else if (t.isDoctype()) {
                tb.error(this);
                return false;
            } else if (t.isStartTag()) {
                Token.StartTag startTag = t.asStartTag();
                String name = startTag.normalName();
                if (name.equals(""caption"")) {
                    tb.clearStackToTableContext();
                    tb.insertMarkerToFormattingElements();
                    tb.insert(startTag);
                    tb.transition(InCaption);
                } else if (name.equals(""colgroup"")) {
                    tb.clearStackToTableContext();
                    tb.insert(startTag);
                    tb.transition(InColumnGroup);
                } else if (name.equals(""col"")) {
                    tb.clearStackToTableContext();
                    tb.processStartTag(""colgroup"");
                    return tb.process(t);
                } else if (inSorted(name, InTableToBody)) {
                    tb.clearStackToTableContext();
                    tb.insert(startTag);
                    tb.transition(InTableBody);
                } else if (inSorted(name, InTableAddBody)) {
                    tb.clearStackToTableContext();
                    tb.processStartTag(""tbody"");
                    return tb.process(t);
                } else if (name.equals(""table"")) {
                    tb.error(this);
                    if (!tb.inTableScope(name)) { // ignore it
                        return false;
                    } else {
                        tb.popStackToClose(name);
                        if (!tb.resetInsertionMode()) {
                            // not per spec - but haven't transitioned out of table. so try something else
                            tb.insert(startTag);
                            return true;
                        }
                        return tb.process(t);
                    }
                } else if (inSorted(name, InTableToHead)) {
                    return tb.process(t, InHead);
                } else if (name.equals(""input"")) {
                    if (!(startTag.hasAttributes() && startTag.attributes.get(""type"").equalsIgnoreCase(""hidden""))) {
                        return anythingElse(t, tb);
                    } else {
                        tb.insertEmpty(startTag);
                    }
                } else if (name.equals(""form"")) {
                    tb.error(this);
                    if (tb.getFormElement() != null || tb.onStack(""template""))
                        return false;
                    else {
                        tb.insertForm(startTag, false, false); // not added to stack. can associate to template
                    }
                } else {
                    return anythingElse(t, tb);
                }
                return true; // todo: check if should return processed http://www.whatwg.org/specs/web-apps/current-work/multipage/tree-construction.html#parsing-main-intable
            } else if (t.isEndTag()) {
                Token.EndTag endTag = t.asEndTag();
                String name = endTag.normalName();

                if (name.equals(""table"")) {
                    if (!tb.inTableScope(name)) {
                        tb.error(this);
                        return false;
                    } else {
                        tb.popStackToClose(""table"");
                        tb.resetInsertionMode();
                    }
                } else if (inSorted(name, InTableEndErr)) {
                    tb.error(this);
                    return false;
                } else if (name.equals(""template"")) {
                    tb.process(t, InHead);
                } else {
                    return anythingElse(t, tb);
                }
                return true; // todo: as above todo
            } else if (t.isEOF()) {
                if (tb.currentElementIs(""html""))
                    tb.error(this);
                return true; // stops parsing
            }
            return anythingElse(t, tb);
        }
",0
jsoup 1.16.1,NULL_DEREFERENCE,src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java,"org.jsoup.parser.HtmlTreeBuilderState$11.process(org.jsoup.parser.Token,org.jsoup.parser.HtmlTreeBuilder):boolean",1136,object returned by `t.asEndTag().normalName()` could be null and is dereferenced at line 1136.,"1135: boolean process(Token t, HtmlTreeBuilder tb) {
1136: if (t.isEndTag() && t.asEndTag().normalName().equals(""caption"")) {
1137: Token.EndTag endTag = t.asEndTag();
1138: String name = endTag.normalName();
1139: if (!tb.inTableScope(name)) {
1140: tb.error(this);
1141: return false;
1142: } else {
1143: tb.generateImpliedEndTags();
1144: if (!tb.currentElementIs(""caption""))
1145: tb.error(this);
1146: tb.popStackToClose(""caption"");
1147: tb.clearFormattingElementsToLastMarker();
1148: tb.transition(InTable);
1149: }
1150: } else if ((
1151: t.isStartTag() && inSorted(t.asStartTag().normalName(), InCellCol) ||
1152: t.isEndTag() && t.asEndTag().normalName().equals(""table""))
1153: ) {
1154: tb.error(this);
1155: boolean processed = tb.processEndTag(""caption"");
1156: if (processed)
1157: return tb.process(t);
1158: } else if (t.isEndTag() && inSorted(t.asEndTag().normalName(), InCaptionIgnore)) {
1159: tb.error(this);
1160: return false;
1161: } else {
1162: return tb.process(t, InBody);
1163: }
1164: return true;","boolean process(Token t, HtmlTreeBuilder tb) {
            if (t.isEndTag() && t.asEndTag().normalName().equals(""caption"")) {
                Token.EndTag endTag = t.asEndTag();
                String name = endTag.normalName();
                if (!tb.inTableScope(name)) {
                    tb.error(this);
                    return false;
                } else {
                    tb.generateImpliedEndTags();
                    if (!tb.currentElementIs(""caption""))
                        tb.error(this);
                    tb.popStackToClose(""caption"");
                    tb.clearFormattingElementsToLastMarker();
                    tb.transition(InTable);
                }
            } else if ((
                    t.isStartTag() && inSorted(t.asStartTag().normalName(), InCellCol) ||
                            t.isEndTag() && t.asEndTag().normalName().equals(""table""))
                    ) {
                tb.error(this);
                boolean processed = tb.processEndTag(""caption"");
                if (processed)
                    return tb.process(t);
            } else if (t.isEndTag() && inSorted(t.asEndTag().normalName(), InCaptionIgnore)) {
                tb.error(this);
                return false;
            } else {
                return tb.process(t, InBody);
            }
            return true;
        }",0
jsoup 1.16.1,NULL_DEREFERENCE,src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java,"org.jsoup.parser.HtmlTreeBuilderState$12.process(org.jsoup.parser.Token,org.jsoup.parser.HtmlTreeBuilder):boolean",1198,object `name` last assigned on line 1197 could be null and is dereferenced at line 1198.,"1168: boolean process(Token t, HtmlTreeBuilder tb) {
1169: if (isWhitespace(t)) {
1170: tb.insert(t.asCharacter());
1171: return true;
1172: }
1173: switch (t.type) {
1174: case Comment:
1175: tb.insert(t.asComment());
1176: break;
1177: case Doctype:
1178: tb.error(this);
1179: break;
1180: case StartTag:
1181: Token.StartTag startTag = t.asStartTag();
1182: switch (startTag.normalName()) {
1183: case ""html"":
1184: return tb.process(t, InBody);
1185: case ""col"":
1186: tb.insertEmpty(startTag);
1187: break;
1188: case ""template"":
1189: tb.process(t, InHead);
1190: break;
1191: default:
1192: return anythingElse(t, tb);
1193: }
1194: break;
1195: case EndTag:
1196: Token.EndTag endTag = t.asEndTag();
1197: String name = endTag.normalName();
1198: switch (name) {
1199: case ""colgroup"":
1200: if (!tb.currentElementIs(name)) {
1201: tb.error(this);
1202: return false;
1203: } else {
1204: tb.pop();
1205: tb.transition(InTable);
1206: }
1207: break;
1208: case ""template"":
1209: tb.process(t, InHead);
1210: break;
1211: default:
1212: return anythingElse(t, tb);
1213: }
1214: break;
1215: case EOF:
1216: if (tb.currentElementIs(""html""))
1217: return true; // stop parsing; frag case
1218: else
1219: return anythingElse(t, tb);
1220: default:
1221: return anythingElse(t, tb);
1222: }
1223: return true;","boolean process(Token t, HtmlTreeBuilder tb) {
            if (isWhitespace(t)) {
                tb.insert(t.asCharacter());
                return true;
            }
            switch (t.type) {
                case Comment:
                    tb.insert(t.asComment());
                    break;
                case Doctype:
                    tb.error(this);
                    break;
                case StartTag:
                    Token.StartTag startTag = t.asStartTag();
                    switch (startTag.normalName()) {
                        case ""html"":
                            return tb.process(t, InBody);
                        case ""col"":
                            tb.insertEmpty(startTag);
                            break;
                        case ""template"":
                            tb.process(t, InHead);
                            break;
                        default:
                            return anythingElse(t, tb);
                    }
                    break;
                case EndTag:
                    Token.EndTag endTag = t.asEndTag();
                    String name = endTag.normalName();
                    switch (name) {
                        case ""colgroup"":
                            if (!tb.currentElementIs(name)) {
                                tb.error(this);
                                return false;
                            } else {
                                tb.pop();
                                tb.transition(InTable);
                            }
                            break;
                        case ""template"":
                            tb.process(t, InHead);
                            break;
                        default:
                            return anythingElse(t, tb);
                    }
                    break;
                case EOF:
                    if (tb.currentElementIs(""html""))
                        return true; // stop parsing; frag case
                    else
                        return anythingElse(t, tb);
                default:
                    return anythingElse(t, tb);
            }
            return true;
        }
",0
jsoup 1.16.1,NULL_DEREFERENCE,src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java,"org.jsoup.parser.HtmlTreeBuilderState$12.process(org.jsoup.parser.Token,org.jsoup.parser.HtmlTreeBuilder):boolean",1182,object returned by `startTag.normalName()` could be null and is dereferenced at line 1182.,"1168: boolean process(Token t, HtmlTreeBuilder tb) {
1169: if (isWhitespace(t)) {
1170: tb.insert(t.asCharacter());
1171: return true;
1172: }
1173: switch (t.type) {
1174: case Comment:
1175: tb.insert(t.asComment());
1176: break;
1177: case Doctype:
1178: tb.error(this);
1179: break;
1180: case StartTag:
1181: Token.StartTag startTag = t.asStartTag();
1182: switch (startTag.normalName()) {
1183: case ""html"":
1184: return tb.process(t, InBody);
1185: case ""col"":
1186: tb.insertEmpty(startTag);
1187: break;
1188: case ""template"":
1189: tb.process(t, InHead);
1190: break;
1191: default:
1192: return anythingElse(t, tb);
1193: }
1194: break;
1195: case EndTag:
1196: Token.EndTag endTag = t.asEndTag();
1197: String name = endTag.normalName();
1198: switch (name) {
1199: case ""colgroup"":
1200: if (!tb.currentElementIs(name)) {
1201: tb.error(this);
1202: return false;
1203: } else {
1204: tb.pop();
1205: tb.transition(InTable);
1206: }
1207: break;
1208: case ""template"":
1209: tb.process(t, InHead);
1210: break;
1211: default:
1212: return anythingElse(t, tb);
1213: }
1214: break;
1215: case EOF:
1216: if (tb.currentElementIs(""html""))
1217: return true; // stop parsing; frag case
1218: else
1219: return anythingElse(t, tb);
1220: default:
1221: return anythingElse(t, tb);
1222: }
1223: return true;","boolean process(Token t, HtmlTreeBuilder tb) {
            if (isWhitespace(t)) {
                tb.insert(t.asCharacter());
                return true;
            }
            switch (t.type) {
                case Comment:
                    tb.insert(t.asComment());
                    break;
                case Doctype:
                    tb.error(this);
                    break;
                case StartTag:
                    Token.StartTag startTag = t.asStartTag();
                    switch (startTag.normalName()) {
                        case ""html"":
                            return tb.process(t, InBody);
                        case ""col"":
                            tb.insertEmpty(startTag);
                            break;
                        case ""template"":
                            tb.process(t, InHead);
                            break;
                        default:
                            return anythingElse(t, tb);
                    }
                    break;
                case EndTag:
                    Token.EndTag endTag = t.asEndTag();
                    String name = endTag.normalName();
                    switch (name) {
                        case ""colgroup"":
                            if (!tb.currentElementIs(name)) {
                                tb.error(this);
                                return false;
                            } else {
                                tb.pop();
                                tb.transition(InTable);
                            }
                            break;
                        case ""template"":
                            tb.process(t, InHead);
                            break;
                        default:
                            return anythingElse(t, tb);
                    }
                    break;
                case EOF:
                    if (tb.currentElementIs(""html""))
                        return true; // stop parsing; frag case
                    else
                        return anythingElse(t, tb);
                default:
                    return anythingElse(t, tb);
            }
            return true;
        }
",0
jsoup 1.16.1,NULL_DEREFERENCE,src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java,"org.jsoup.parser.HtmlTreeBuilderState$13.process(org.jsoup.parser.Token,org.jsoup.parser.HtmlTreeBuilder):boolean",1243,object `name` last assigned on line 1242 could be null and is dereferenced at line 1243.,"1238: boolean process(Token t, HtmlTreeBuilder tb) {
1239: switch (t.type) {
1240: case StartTag:
1241: Token.StartTag startTag = t.asStartTag();
1242: String name = startTag.normalName();
1243: if (name.equals(""tr"")) {
1244: tb.clearStackToTableBodyContext();
1245: tb.insert(startTag);
1246: tb.transition(InRow);
1247: } else if (inSorted(name, InCellNames)) {
1248: tb.error(this);
1249: tb.processStartTag(""tr"");
1250: return tb.process(startTag);
1251: } else if (inSorted(name, InTableBodyExit)) {
1252: return exitTableBody(t, tb);
1253: } else
1254: return anythingElse(t, tb);
1255: break;
1256: case EndTag:
1257: Token.EndTag endTag = t.asEndTag();
1258: name = endTag.normalName();
1259: if (inSorted(name, InTableEndIgnore)) {
1260: if (!tb.inTableScope(name)) {
1261: tb.error(this);
1262: return false;
1263: } else {
1264: tb.clearStackToTableBodyContext();
1265: tb.pop();
1266: tb.transition(InTable);
1267: }
1268: } else if (name.equals(""table"")) {
1269: return exitTableBody(t, tb);
1270: } else if (inSorted(name, InTableBodyEndIgnore)) {
1271: tb.error(this);
1272: return false;
1273: } else
1274: return anythingElse(t, tb);
1275: break;
1276: default:
1277: return anythingElse(t, tb);
1278: }
1279: return true;","boolean process(Token t, HtmlTreeBuilder tb) {
            switch (t.type) {
                case StartTag:
                    Token.StartTag startTag = t.asStartTag();
                    String name = startTag.normalName();
                    if (name.equals(""tr"")) {
                        tb.clearStackToTableBodyContext();
                        tb.insert(startTag);
                        tb.transition(InRow);
                    } else if (inSorted(name, InCellNames)) {
                        tb.error(this);
                        tb.processStartTag(""tr"");
                        return tb.process(startTag);
                    } else if (inSorted(name, InTableBodyExit)) {
                        return exitTableBody(t, tb);
                    } else
                        return anythingElse(t, tb);
                    break;
                case EndTag:
                    Token.EndTag endTag = t.asEndTag();
                    name = endTag.normalName();
                    if (inSorted(name, InTableEndIgnore)) {
                        if (!tb.inTableScope(name)) {
                            tb.error(this);
                            return false;
                        } else {
                            tb.clearStackToTableBodyContext();
                            tb.pop();
                            tb.transition(InTable);
                        }
                    } else if (name.equals(""table"")) {
                        return exitTableBody(t, tb);
                    } else if (inSorted(name, InTableBodyEndIgnore)) {
                        tb.error(this);
                        return false;
                    } else
                        return anythingElse(t, tb);
                    break;
                default:
                    return anythingElse(t, tb);
            }
            return true;
        }",0
jsoup 1.16.1,NULL_DEREFERENCE,src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java,"org.jsoup.parser.HtmlTreeBuilderState$13.process(org.jsoup.parser.Token,org.jsoup.parser.HtmlTreeBuilder):boolean",1268,object `name` last assigned on line 1258 could be null and is dereferenced at line 1268.,"1238: boolean process(Token t, HtmlTreeBuilder tb) {
1239: switch (t.type) {
1240: case StartTag:
1241: Token.StartTag startTag = t.asStartTag();
1242: String name = startTag.normalName();
1243: if (name.equals(""tr"")) {
1244: tb.clearStackToTableBodyContext();
1245: tb.insert(startTag);
1246: tb.transition(InRow);
1247: } else if (inSorted(name, InCellNames)) {
1248: tb.error(this);
1249: tb.processStartTag(""tr"");
1250: return tb.process(startTag);
1251: } else if (inSorted(name, InTableBodyExit)) {
1252: return exitTableBody(t, tb);
1253: } else
1254: return anythingElse(t, tb);
1255: break;
1256: case EndTag:
1257: Token.EndTag endTag = t.asEndTag();
1258: name = endTag.normalName();
1259: if (inSorted(name, InTableEndIgnore)) {
1260: if (!tb.inTableScope(name)) {
1261: tb.error(this);
1262: return false;
1263: } else {
1264: tb.clearStackToTableBodyContext();
1265: tb.pop();
1266: tb.transition(InTable);
1267: }
1268: } else if (name.equals(""table"")) {
1269: return exitTableBody(t, tb);
1270: } else if (inSorted(name, InTableBodyEndIgnore)) {
1271: tb.error(this);
1272: return false;
1273: } else
1274: return anythingElse(t, tb);
1275: break;
1276: default:
1277: return anythingElse(t, tb);
1278: }
1279: return true;","boolean process(Token t, HtmlTreeBuilder tb) {
            switch (t.type) {
                case StartTag:
                    Token.StartTag startTag = t.asStartTag();
                    String name = startTag.normalName();
                    if (name.equals(""tr"")) {
                        tb.clearStackToTableBodyContext();
                        tb.insert(startTag);
                        tb.transition(InRow);
                    } else if (inSorted(name, InCellNames)) {
                        tb.error(this);
                        tb.processStartTag(""tr"");
                        return tb.process(startTag);
                    } else if (inSorted(name, InTableBodyExit)) {
                        return exitTableBody(t, tb);
                    } else
                        return anythingElse(t, tb);
                    break;
                case EndTag:
                    Token.EndTag endTag = t.asEndTag();
                    name = endTag.normalName();
                    if (inSorted(name, InTableEndIgnore)) {
                        if (!tb.inTableScope(name)) {
                            tb.error(this);
                            return false;
                        } else {
                            tb.clearStackToTableBodyContext();
                            tb.pop();
                            tb.transition(InTable);
                        }
                    } else if (name.equals(""table"")) {
                        return exitTableBody(t, tb);
                    } else if (inSorted(name, InTableBodyEndIgnore)) {
                        tb.error(this);
                        return false;
                    } else
                        return anythingElse(t, tb);
                    break;
                default:
                    return anythingElse(t, tb);
            }
            return true;
        }",0
jsoup 1.16.1,NULL_DEREFERENCE,src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java,"org.jsoup.parser.HtmlTreeBuilderState$14.process(org.jsoup.parser.Token,org.jsoup.parser.HtmlTreeBuilder):boolean",1317,object `name` last assigned on line 1315 could be null and is dereferenced at line 1317.,"1298: boolean process(Token t, HtmlTreeBuilder tb) {
1299: if (t.isStartTag()) {
1300: Token.StartTag startTag = t.asStartTag();
1301: String name = startTag.normalName();
1302: 
1303: if (inSorted(name, InCellNames)) {
1304: tb.clearStackToTableRowContext();
1305: tb.insert(startTag);
1306: tb.transition(InCell);
1307: tb.insertMarkerToFormattingElements();
1308: } else if (inSorted(name, InRowMissing)) {
1309: return handleMissingTr(t, tb);
1310: } else {
1311: return anythingElse(t, tb);
1312: }
1313: } else if (t.isEndTag()) {
1314: Token.EndTag endTag = t.asEndTag();
1315: String name = endTag.normalName();
1316: 
1317: if (name.equals(""tr"")) {
1318: if (!tb.inTableScope(name)) {
1319: tb.error(this); // frag
1320: return false;
1321: }
1322: tb.clearStackToTableRowContext();
1323: tb.pop(); // tr
1324: tb.transition(InTableBody);
1325: } else if (name.equals(""table"")) {
1326: return handleMissingTr(t, tb);
1327: } else if (inSorted(name, InTableToBody)) {
1328: if (!tb.inTableScope(name) || !tb.inTableScope(""tr"")) {
1329: tb.error(this);
1330: return false;
1331: }
1332: tb.clearStackToTableRowContext();
1333: tb.pop(); // tr
1334: tb.transition(InTableBody);
1335: } else if (inSorted(name, InRowIgnore)) {
1336: tb.error(this);
1337: return false;
1338: } else {
1339: return anythingElse(t, tb);
1340: }
1341: } else {
1342: return anythingElse(t, tb);
1343: }
1344: return true;","boolean process(Token t, HtmlTreeBuilder tb) {
            if (t.isStartTag()) {
                Token.StartTag startTag = t.asStartTag();
                String name = startTag.normalName();

                if (inSorted(name, InCellNames)) {
                    tb.clearStackToTableRowContext();
                    tb.insert(startTag);
                    tb.transition(InCell);
                    tb.insertMarkerToFormattingElements();
                } else if (inSorted(name, InRowMissing)) {
                    return handleMissingTr(t, tb);
                } else {
                    return anythingElse(t, tb);
                }
            } else if (t.isEndTag()) {
                Token.EndTag endTag = t.asEndTag();
                String name = endTag.normalName();

                if (name.equals(""tr"")) {
                    if (!tb.inTableScope(name)) {
                        tb.error(this); // frag
                        return false;
                    }
                    tb.clearStackToTableRowContext();
                    tb.pop(); // tr
                    tb.transition(InTableBody);
                } else if (name.equals(""table"")) {
                    return handleMissingTr(t, tb);
                } else if (inSorted(name, InTableToBody)) {
                    if (!tb.inTableScope(name) || !tb.inTableScope(""tr"")) {
                        tb.error(this);
                        return false;
                    }
                    tb.clearStackToTableRowContext();
                    tb.pop(); // tr
                    tb.transition(InTableBody);
                } else if (inSorted(name, InRowIgnore)) {
                    tb.error(this);
                    return false;
                } else {
                    return anythingElse(t, tb);
                }
            } else {
                return anythingElse(t, tb);
            }
            return true;
        }",0
jsoup 1.16.1,NULL_DEREFERENCE,src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java,"org.jsoup.parser.HtmlTreeBuilderState$16.process(org.jsoup.parser.Token,org.jsoup.parser.HtmlTreeBuilder):boolean",1436,object `name` last assigned on line 1435 could be null and is dereferenced at line 1436.,"1416: boolean process(Token t, HtmlTreeBuilder tb) {
1417: switch (t.type) {
1418: case Character:
1419: Token.Character c = t.asCharacter();
1420: if (c.getData().equals(nullString)) {
1421: tb.error(this);
1422: return false;
1423: } else {
1424: tb.insert(c);
1425: }
1426: break;
1427: case Comment:
1428: tb.insert(t.asComment());
1429: break;
1430: case Doctype:
1431: tb.error(this);
1432: return false;
1433: case StartTag:
1434: Token.StartTag start = t.asStartTag();
1435: String name = start.normalName();
1436: if (name.equals(""html""))
1437: return tb.process(start, InBody);
1438: else if (name.equals(""option"")) {
1439: if (tb.currentElementIs(""option""))
1440: tb.processEndTag(""option"");
1441: tb.insert(start);
1442: } else if (name.equals(""optgroup"")) {
1443: if (tb.currentElementIs(""option""))
1444: tb.processEndTag(""option""); // pop option and flow to pop optgroup
1445: if (tb.currentElementIs(""optgroup""))
1446: tb.processEndTag(""optgroup"");
1447: tb.insert(start);
1448: } else if (name.equals(""select"")) {
1449: tb.error(this);
1450: return tb.processEndTag(""select"");
1451: } else if (inSorted(name, InSelectEnd)) {
1452: tb.error(this);
1453: if (!tb.inSelectScope(""select""))
1454: return false; // frag
1455: tb.processEndTag(""select"");
1456: return tb.process(start);
1457: } else if (name.equals(""script"") || name.equals(""template"")) {
1458: return tb.process(t, InHead);
1459: } else {
1460: return anythingElse(t, tb);
1461: }
1462: break;
1463: case EndTag:
1464: Token.EndTag end = t.asEndTag();
1465: name = end.normalName();
1466: switch (name) {
1467: case ""optgroup"":
1468: if (tb.currentElementIs(""option"") && tb.aboveOnStack(tb.currentElement()) != null && tb.aboveOnStack(tb.currentElement()).normalName().equals(""optgroup""))
1469: tb.processEndTag(""option"");
1470: if (tb.currentElementIs(""optgroup""))
1471: tb.pop();
1472: else
1473: tb.error(this);
1474: break;
1475: case ""option"":
1476: if (tb.currentElementIs(""option""))
1477: tb.pop();
1478: else
1479: tb.error(this);
1480: break;
1481: case ""select"":
1482: if (!tb.inSelectScope(name)) {
1483: tb.error(this);
1484: return false;
1485: } else {
1486: tb.popStackToClose(name);
1487: tb.resetInsertionMode();
1488: }
1489: break;
1490: case ""template"":
1491: return tb.process(t, InHead);
1492: default:
1493: return anythingElse(t, tb);
1494: }
1495: break;
1496: case EOF:
1497: if (!tb.currentElementIs(""html""))
1498: tb.error(this);
1499: break;
1500: default:
1501: return anythingElse(t, tb);
1502: }
1503: return true;","boolean process(Token t, HtmlTreeBuilder tb) {
            switch (t.type) {
                case Character:
                    Token.Character c = t.asCharacter();
                    if (c.getData().equals(nullString)) {
                        tb.error(this);
                        return false;
                    } else {
                        tb.insert(c);
                    }
                    break;
                case Comment:
                    tb.insert(t.asComment());
                    break;
                case Doctype:
                    tb.error(this);
                    return false;
                case StartTag:
                    Token.StartTag start = t.asStartTag();
                    String name = start.normalName();
                    if (name.equals(""html""))
                        return tb.process(start, InBody);
                    else if (name.equals(""option"")) {
                        if (tb.currentElementIs(""option""))
                            tb.processEndTag(""option"");
                        tb.insert(start);
                    } else if (name.equals(""optgroup"")) {
                        if (tb.currentElementIs(""option""))
                            tb.processEndTag(""option""); // pop option and flow to pop optgroup
                        if (tb.currentElementIs(""optgroup""))
                            tb.processEndTag(""optgroup"");
                        tb.insert(start);
                    } else if (name.equals(""select"")) {
                        tb.error(this);
                        return tb.processEndTag(""select"");
                    } else if (inSorted(name, InSelectEnd)) {
                        tb.error(this);
                        if (!tb.inSelectScope(""select""))
                            return false; // frag
                        tb.processEndTag(""select"");
                        return tb.process(start);
                    } else if (name.equals(""script"") || name.equals(""template"")) {
                        return tb.process(t, InHead);
                    } else {
                        return anythingElse(t, tb);
                    }
                    break;
                case EndTag:
                    Token.EndTag end = t.asEndTag();
                    name = end.normalName();
                    switch (name) {
                        case ""optgroup"":
                            if (tb.currentElementIs(""option"") && tb.aboveOnStack(tb.currentElement()) != null && tb.aboveOnStack(tb.currentElement()).normalName().equals(""optgroup""))
                                tb.processEndTag(""option"");
                            if (tb.currentElementIs(""optgroup""))
                                tb.pop();
                            else
                                tb.error(this);
                            break;
                        case ""option"":
                            if (tb.currentElementIs(""option""))
                                tb.pop();
                            else
                                tb.error(this);
                            break;
                        case ""select"":
                            if (!tb.inSelectScope(name)) {
                                tb.error(this);
                                return false;
                            } else {
                                tb.popStackToClose(name);
                                tb.resetInsertionMode();
                            }
                            break;
                        case ""template"":
                            return tb.process(t, InHead);
                        default:
                            return anythingElse(t, tb);
                    }
                    break;
                case EOF:
                    if (!tb.currentElementIs(""html""))
                        tb.error(this);
                    break;
                default:
                    return anythingElse(t, tb);
            }
            return true;
        }
",0
jsoup 1.16.1,NULL_DEREFERENCE,src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java,"org.jsoup.parser.HtmlTreeBuilderState$16.process(org.jsoup.parser.Token,org.jsoup.parser.HtmlTreeBuilder):boolean",1466,object `name` last assigned on line 1465 could be null and is dereferenced at line 1466.,"1416: boolean process(Token t, HtmlTreeBuilder tb) {
1417: switch (t.type) {
1418: case Character:
1419: Token.Character c = t.asCharacter();
1420: if (c.getData().equals(nullString)) {
1421: tb.error(this);
1422: return false;
1423: } else {
1424: tb.insert(c);
1425: }
1426: break;
1427: case Comment:
1428: tb.insert(t.asComment());
1429: break;
1430: case Doctype:
1431: tb.error(this);
1432: return false;
1433: case StartTag:
1434: Token.StartTag start = t.asStartTag();
1435: String name = start.normalName();
1436: if (name.equals(""html""))
1437: return tb.process(start, InBody);
1438: else if (name.equals(""option"")) {
1439: if (tb.currentElementIs(""option""))
1440: tb.processEndTag(""option"");
1441: tb.insert(start);
1442: } else if (name.equals(""optgroup"")) {
1443: if (tb.currentElementIs(""option""))
1444: tb.processEndTag(""option""); // pop option and flow to pop optgroup
1445: if (tb.currentElementIs(""optgroup""))
1446: tb.processEndTag(""optgroup"");
1447: tb.insert(start);
1448: } else if (name.equals(""select"")) {
1449: tb.error(this);
1450: return tb.processEndTag(""select"");
1451: } else if (inSorted(name, InSelectEnd)) {
1452: tb.error(this);
1453: if (!tb.inSelectScope(""select""))
1454: return false; // frag
1455: tb.processEndTag(""select"");
1456: return tb.process(start);
1457: } else if (name.equals(""script"") || name.equals(""template"")) {
1458: return tb.process(t, InHead);
1459: } else {
1460: return anythingElse(t, tb);
1461: }
1462: break;
1463: case EndTag:
1464: Token.EndTag end = t.asEndTag();
1465: name = end.normalName();
1466: switch (name) {
1467: case ""optgroup"":
1468: if (tb.currentElementIs(""option"") && tb.aboveOnStack(tb.currentElement()) != null && tb.aboveOnStack(tb.currentElement()).normalName().equals(""optgroup""))
1469: tb.processEndTag(""option"");
1470: if (tb.currentElementIs(""optgroup""))
1471: tb.pop();
1472: else
1473: tb.error(this);
1474: break;
1475: case ""option"":
1476: if (tb.currentElementIs(""option""))
1477: tb.pop();
1478: else
1479: tb.error(this);
1480: break;
1481: case ""select"":
1482: if (!tb.inSelectScope(name)) {
1483: tb.error(this);
1484: return false;
1485: } else {
1486: tb.popStackToClose(name);
1487: tb.resetInsertionMode();
1488: }
1489: break;
1490: case ""template"":
1491: return tb.process(t, InHead);
1492: default:
1493: return anythingElse(t, tb);
1494: }
1495: break;
1496: case EOF:
1497: if (!tb.currentElementIs(""html""))
1498: tb.error(this);
1499: break;
1500: default:
1501: return anythingElse(t, tb);
1502: }
1503: return true;","boolean process(Token t, HtmlTreeBuilder tb) {
            switch (t.type) {
                case Character:
                    Token.Character c = t.asCharacter();
                    if (c.getData().equals(nullString)) {
                        tb.error(this);
                        return false;
                    } else {
                        tb.insert(c);
                    }
                    break;
                case Comment:
                    tb.insert(t.asComment());
                    break;
                case Doctype:
                    tb.error(this);
                    return false;
                case StartTag:
                    Token.StartTag start = t.asStartTag();
                    String name = start.normalName();
                    if (name.equals(""html""))
                        return tb.process(start, InBody);
                    else if (name.equals(""option"")) {
                        if (tb.currentElementIs(""option""))
                            tb.processEndTag(""option"");
                        tb.insert(start);
                    } else if (name.equals(""optgroup"")) {
                        if (tb.currentElementIs(""option""))
                            tb.processEndTag(""option""); // pop option and flow to pop optgroup
                        if (tb.currentElementIs(""optgroup""))
                            tb.processEndTag(""optgroup"");
                        tb.insert(start);
                    } else if (name.equals(""select"")) {
                        tb.error(this);
                        return tb.processEndTag(""select"");
                    } else if (inSorted(name, InSelectEnd)) {
                        tb.error(this);
                        if (!tb.inSelectScope(""select""))
                            return false; // frag
                        tb.processEndTag(""select"");
                        return tb.process(start);
                    } else if (name.equals(""script"") || name.equals(""template"")) {
                        return tb.process(t, InHead);
                    } else {
                        return anythingElse(t, tb);
                    }
                    break;
                case EndTag:
                    Token.EndTag end = t.asEndTag();
                    name = end.normalName();
                    switch (name) {
                        case ""optgroup"":
                            if (tb.currentElementIs(""option"") && tb.aboveOnStack(tb.currentElement()) != null && tb.aboveOnStack(tb.currentElement()).normalName().equals(""optgroup""))
                                tb.processEndTag(""option"");
                            if (tb.currentElementIs(""optgroup""))
                                tb.pop();
                            else
                                tb.error(this);
                            break;
                        case ""option"":
                            if (tb.currentElementIs(""option""))
                                tb.pop();
                            else
                                tb.error(this);
                            break;
                        case ""select"":
                            if (!tb.inSelectScope(name)) {
                                tb.error(this);
                                return false;
                            } else {
                                tb.popStackToClose(name);
                                tb.resetInsertionMode();
                            }
                            break;
                        case ""template"":
                            return tb.process(t, InHead);
                        default:
                            return anythingElse(t, tb);
                    }
                    break;
                case EOF:
                    if (!tb.currentElementIs(""html""))
                        tb.error(this);
                    break;
                default:
                    return anythingElse(t, tb);
            }
            return true;
        }
",0
jsoup 1.16.1,NULL_DEREFERENCE,src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java,"org.jsoup.parser.HtmlTreeBuilderState$18.process(org.jsoup.parser.Token,org.jsoup.parser.HtmlTreeBuilder):boolean",1550,object `name` last assigned on line 1541 could be null and is dereferenced at line 1550.,"1532: boolean process(Token t, HtmlTreeBuilder tb) {
1533: final String name;
1534: switch (t.type) {
1535: case Character:
1536: case Comment:
1537: case Doctype:
1538: tb.process(t, InBody);
1539: break;
1540: case StartTag:
1541: name = t.asStartTag().normalName();
1542: if (inSorted(name, InTemplateToHead))
1543: tb.process(t, InHead);
1544: else if (inSorted(name, InTemplateToTable)) {
1545: tb.popTemplateMode();
1546: tb.pushTemplateMode(InTable);
1547: tb.transition(InTable);
1548: return tb.process(t);
1549: }
1550: else if (name.equals(""col"")) {
1551: tb.popTemplateMode();
1552: tb.pushTemplateMode(InColumnGroup);
1553: tb.transition(InColumnGroup);
1554: return tb.process(t);
1555: } else if (name.equals(""tr"")) {
1556: tb.popTemplateMode();
1557: tb.pushTemplateMode(InTableBody);
1558: tb.transition(InTableBody);
1559: return tb.process(t);
1560: } else if (name.equals(""td"") || name.equals(""th"")) {
1561: tb.popTemplateMode();
1562: tb.pushTemplateMode(InRow);
1563: tb.transition(InRow);
1564: return tb.process(t);
1565: } else {
1566: tb.popTemplateMode();
1567: tb.pushTemplateMode(InBody);
1568: tb.transition(InBody);
1569: return tb.process(t);
1570: }
1571: 
1572: break;
1573: case EndTag:
1574: name = t.asEndTag().normalName();
1575: if (name.equals(""template""))
1576: tb.process(t, InHead);
1577: else {
1578: tb.error(this);
1579: return false;
1580: }
1581: break;
1582: case EOF:
1583: if (!tb.onStack(""template"")) {// stop parsing
1584: return true;
1585: }
1586: tb.error(this);
1587: tb.popStackToClose(""template"");
1588: tb.clearFormattingElementsToLastMarker();
1589: tb.popTemplateMode();
1590: tb.resetInsertionMode();
1591: // spec deviation - if we did not break out of Template, stop processing, and don't worry about cleaning up ultra-deep template stacks
1592: // limited depth because this can recurse and will blow stack if too deep
1593: if (tb.state() != InTemplate && tb.templateModeSize() < 12)
1594: return tb.process(t);
1595: else return true;
1596: }
1597: return true;","boolean process(Token t, HtmlTreeBuilder tb) {
            final String name;
            switch (t.type) {
                case Character:
                case Comment:
                case Doctype:
                    tb.process(t, InBody);
                    break;
                case StartTag:
                    name = t.asStartTag().normalName();
                    if (inSorted(name, InTemplateToHead))
                        tb.process(t, InHead);
                    else if (inSorted(name, InTemplateToTable)) {
                        tb.popTemplateMode();
                        tb.pushTemplateMode(InTable);
                        tb.transition(InTable);
                        return tb.process(t);
                    }
                    else if (name.equals(""col"")) {
                        tb.popTemplateMode();
                        tb.pushTemplateMode(InColumnGroup);
                        tb.transition(InColumnGroup);
                        return tb.process(t);
                    } else if (name.equals(""tr"")) {
                        tb.popTemplateMode();
                        tb.pushTemplateMode(InTableBody);
                        tb.transition(InTableBody);
                        return tb.process(t);
                    } else if (name.equals(""td"") || name.equals(""th"")) {
                        tb.popTemplateMode();
                        tb.pushTemplateMode(InRow);
                        tb.transition(InRow);
                        return tb.process(t);
                    } else {
                        tb.popTemplateMode();
                        tb.pushTemplateMode(InBody);
                        tb.transition(InBody);
                        return tb.process(t);
                    }

                    break;
                case EndTag:
                    name = t.asEndTag().normalName();
                    if (name.equals(""template""))
                        tb.process(t, InHead);
                    else {
                        tb.error(this);
                        return false;
                    }
                    break;
                case EOF:
                    if (!tb.onStack(""template"")) {// stop parsing
                        return true;
                    }
                    tb.error(this);
                    tb.popStackToClose(""template"");
                    tb.clearFormattingElementsToLastMarker();
                    tb.popTemplateMode();
                    tb.resetInsertionMode();
                    // spec deviation - if we did not break out of Template, stop processing, and don't worry about cleaning up ultra-deep template stacks
                    // limited depth because this can recurse and will blow stack if too deep
                    if (tb.state() != InTemplate && tb.templateModeSize() < 12)
                        return tb.process(t);
                    else return true;
            }
            return true;
        }",0
jsoup 1.16.1,NULL_DEREFERENCE,src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java,"org.jsoup.parser.HtmlTreeBuilderState$18.process(org.jsoup.parser.Token,org.jsoup.parser.HtmlTreeBuilder):boolean",1575,object `name` last assigned on line 1574 could be null and is dereferenced at line 1575.,"1532: boolean process(Token t, HtmlTreeBuilder tb) {
1533: final String name;
1534: switch (t.type) {
1535: case Character:
1536: case Comment:
1537: case Doctype:
1538: tb.process(t, InBody);
1539: break;
1540: case StartTag:
1541: name = t.asStartTag().normalName();
1542: if (inSorted(name, InTemplateToHead))
1543: tb.process(t, InHead);
1544: else if (inSorted(name, InTemplateToTable)) {
1545: tb.popTemplateMode();
1546: tb.pushTemplateMode(InTable);
1547: tb.transition(InTable);
1548: return tb.process(t);
1549: }
1550: else if (name.equals(""col"")) {
1551: tb.popTemplateMode();
1552: tb.pushTemplateMode(InColumnGroup);
1553: tb.transition(InColumnGroup);
1554: return tb.process(t);
1555: } else if (name.equals(""tr"")) {
1556: tb.popTemplateMode();
1557: tb.pushTemplateMode(InTableBody);
1558: tb.transition(InTableBody);
1559: return tb.process(t);
1560: } else if (name.equals(""td"") || name.equals(""th"")) {
1561: tb.popTemplateMode();
1562: tb.pushTemplateMode(InRow);
1563: tb.transition(InRow);
1564: return tb.process(t);
1565: } else {
1566: tb.popTemplateMode();
1567: tb.pushTemplateMode(InBody);
1568: tb.transition(InBody);
1569: return tb.process(t);
1570: }
1571: 
1572: break;
1573: case EndTag:
1574: name = t.asEndTag().normalName();
1575: if (name.equals(""template""))
1576: tb.process(t, InHead);
1577: else {
1578: tb.error(this);
1579: return false;
1580: }
1581: break;
1582: case EOF:
1583: if (!tb.onStack(""template"")) {// stop parsing
1584: return true;
1585: }
1586: tb.error(this);
1587: tb.popStackToClose(""template"");
1588: tb.clearFormattingElementsToLastMarker();
1589: tb.popTemplateMode();
1590: tb.resetInsertionMode();
1591: // spec deviation - if we did not break out of Template, stop processing, and don't worry about cleaning up ultra-deep template stacks
1592: // limited depth because this can recurse and will blow stack if too deep
1593: if (tb.state() != InTemplate && tb.templateModeSize() < 12)
1594: return tb.process(t);
1595: else return true;
1596: }
1597: return true;","boolean process(Token t, HtmlTreeBuilder tb) {
            final String name;
            switch (t.type) {
                case Character:
                case Comment:
                case Doctype:
                    tb.process(t, InBody);
                    break;
                case StartTag:
                    name = t.asStartTag().normalName();
                    if (inSorted(name, InTemplateToHead))
                        tb.process(t, InHead);
                    else if (inSorted(name, InTemplateToTable)) {
                        tb.popTemplateMode();
                        tb.pushTemplateMode(InTable);
                        tb.transition(InTable);
                        return tb.process(t);
                    }
                    else if (name.equals(""col"")) {
                        tb.popTemplateMode();
                        tb.pushTemplateMode(InColumnGroup);
                        tb.transition(InColumnGroup);
                        return tb.process(t);
                    } else if (name.equals(""tr"")) {
                        tb.popTemplateMode();
                        tb.pushTemplateMode(InTableBody);
                        tb.transition(InTableBody);
                        return tb.process(t);
                    } else if (name.equals(""td"") || name.equals(""th"")) {
                        tb.popTemplateMode();
                        tb.pushTemplateMode(InRow);
                        tb.transition(InRow);
                        return tb.process(t);
                    } else {
                        tb.popTemplateMode();
                        tb.pushTemplateMode(InBody);
                        tb.transition(InBody);
                        return tb.process(t);
                    }

                    break;
                case EndTag:
                    name = t.asEndTag().normalName();
                    if (name.equals(""template""))
                        tb.process(t, InHead);
                    else {
                        tb.error(this);
                        return false;
                    }
                    break;
                case EOF:
                    if (!tb.onStack(""template"")) {// stop parsing
                        return true;
                    }
                    tb.error(this);
                    tb.popStackToClose(""template"");
                    tb.clearFormattingElementsToLastMarker();
                    tb.popTemplateMode();
                    tb.resetInsertionMode();
                    // spec deviation - if we did not break out of Template, stop processing, and don't worry about cleaning up ultra-deep template stacks
                    // limited depth because this can recurse and will blow stack if too deep
                    if (tb.state() != InTemplate && tb.templateModeSize() < 12)
                        return tb.process(t);
                    else return true;
            }
            return true;
        }",0
jsoup 1.16.1,NULL_DEREFERENCE,src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java,"org.jsoup.parser.HtmlTreeBuilderState$19.process(org.jsoup.parser.Token,org.jsoup.parser.HtmlTreeBuilder):boolean",1616,object returned by `t.asEndTag().normalName()` could be null and is dereferenced at line 1616.,"1601: boolean process(Token t, HtmlTreeBuilder tb) {
1602: if (isWhitespace(t)) {
1603: // spec deviation - currently body is still on stack, but we want this to go to the html node
1604: Element html = tb.getFromStack(""html"");
1605: if (html != null)
1606: tb.insert(t.asCharacter(), html);
1607: else
1608: tb.process(t, InBody); // will get into body
1609: } else if (t.isComment()) {
1610: tb.insert(t.asComment()); // into html node
1611: } else if (t.isDoctype()) {
1612: tb.error(this);
1613: return false;
1614: } else if (t.isStartTag() && t.asStartTag().normalName().equals(""html"")) {
1615: return tb.process(t, InBody);
1616: } else if (t.isEndTag() && t.asEndTag().normalName().equals(""html"")) {
1617: if (tb.isFragmentParsing()) {
1618: tb.error(this);
1619: return false;
1620: } else {
1621: tb.transition(AfterAfterBody);
1622: }
1623: } else if (t.isEOF()) {
1624: // chillax! we're done
1625: } else {
1626: tb.error(this);
1627: tb.resetBody();
1628: return tb.process(t);
1629: }
1630: return true;","boolean process(Token t, HtmlTreeBuilder tb) {
            if (isWhitespace(t)) {
                // spec deviation - currently body is still on stack, but we want this to go to the html node
                Element html = tb.getFromStack(""html"");
                if (html != null)
                    tb.insert(t.asCharacter(), html);
                else
                    tb.process(t, InBody); // will get into body
            } else if (t.isComment()) {
                tb.insert(t.asComment()); // into html node
            } else if (t.isDoctype()) {
                tb.error(this);
                return false;
            } else if (t.isStartTag() && t.asStartTag().normalName().equals(""html"")) {
                return tb.process(t, InBody);
            } else if (t.isEndTag() && t.asEndTag().normalName().equals(""html"")) {
                if (tb.isFragmentParsing()) {
                    tb.error(this);
                    return false;
                } else {
                    tb.transition(AfterAfterBody);
                }
            } else if (t.isEOF()) {
                // chillax! we're done
            } else {
                tb.error(this);
                tb.resetBody();
                return tb.process(t);
            }
            return true;
        }",0
jsoup 1.16.1,NULL_DEREFERENCE,src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java,"org.jsoup.parser.HtmlTreeBuilderState$19.process(org.jsoup.parser.Token,org.jsoup.parser.HtmlTreeBuilder):boolean",1614,object returned by `t.asStartTag().normalName()` could be null and is dereferenced at line 1614.,"1601: boolean process(Token t, HtmlTreeBuilder tb) {
1602: if (isWhitespace(t)) {
1603: // spec deviation - currently body is still on stack, but we want this to go to the html node
1604: Element html = tb.getFromStack(""html"");
1605: if (html != null)
1606: tb.insert(t.asCharacter(), html);
1607: else
1608: tb.process(t, InBody); // will get into body
1609: } else if (t.isComment()) {
1610: tb.insert(t.asComment()); // into html node
1611: } else if (t.isDoctype()) {
1612: tb.error(this);
1613: return false;
1614: } else if (t.isStartTag() && t.asStartTag().normalName().equals(""html"")) {
1615: return tb.process(t, InBody);
1616: } else if (t.isEndTag() && t.asEndTag().normalName().equals(""html"")) {
1617: if (tb.isFragmentParsing()) {
1618: tb.error(this);
1619: return false;
1620: } else {
1621: tb.transition(AfterAfterBody);
1622: }
1623: } else if (t.isEOF()) {
1624: // chillax! we're done
1625: } else {
1626: tb.error(this);
1627: tb.resetBody();
1628: return tb.process(t);
1629: }
1630: return true;","boolean process(Token t, HtmlTreeBuilder tb) {
            if (isWhitespace(t)) {
                // spec deviation - currently body is still on stack, but we want this to go to the html node
                Element html = tb.getFromStack(""html"");
                if (html != null)
                    tb.insert(t.asCharacter(), html);
                else
                    tb.process(t, InBody); // will get into body
            } else if (t.isComment()) {
                tb.insert(t.asComment()); // into html node
            } else if (t.isDoctype()) {
                tb.error(this);
                return false;
            } else if (t.isStartTag() && t.asStartTag().normalName().equals(""html"")) {
                return tb.process(t, InBody);
            } else if (t.isEndTag() && t.asEndTag().normalName().equals(""html"")) {
                if (tb.isFragmentParsing()) {
                    tb.error(this);
                    return false;
                } else {
                    tb.transition(AfterAfterBody);
                }
            } else if (t.isEOF()) {
                // chillax! we're done
            } else {
                tb.error(this);
                tb.resetBody();
                return tb.process(t);
            }
            return true;
        }",0
jsoup 1.16.1,NULL_DEREFERENCE,src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java,"org.jsoup.parser.HtmlTreeBuilderState$20.process(org.jsoup.parser.Token,org.jsoup.parser.HtmlTreeBuilder):boolean",1644,object returned by `start.normalName()` could be null and is dereferenced at line 1644.,"1634: boolean process(Token t, HtmlTreeBuilder tb) {
1635: if (isWhitespace(t)) {
1636: tb.insert(t.asCharacter());
1637: } else if (t.isComment()) {
1638: tb.insert(t.asComment());
1639: } else if (t.isDoctype()) {
1640: tb.error(this);
1641: return false;
1642: } else if (t.isStartTag()) {
1643: Token.StartTag start = t.asStartTag();
1644: switch (start.normalName()) {
1645: case ""html"":
1646: return tb.process(start, InBody);
1647: case ""frameset"":
1648: tb.insert(start);
1649: break;
1650: case ""frame"":
1651: tb.insertEmpty(start);
1652: break;
1653: case ""noframes"":
1654: return tb.process(start, InHead);
1655: default:
1656: tb.error(this);
1657: return false;
1658: }
1659: } else if (t.isEndTag() && t.asEndTag().normalName().equals(""frameset"")) {
1660: if (tb.currentElementIs(""html"")) { // frag
1661: tb.error(this);
1662: return false;
1663: } else {
1664: tb.pop();
1665: if (!tb.isFragmentParsing() && !tb.currentElementIs(""frameset"")) {
1666: tb.transition(AfterFrameset);
1667: }
1668: }
1669: } else if (t.isEOF()) {
1670: if (!tb.currentElementIs(""html"")) {
1671: tb.error(this);
1672: return true;
1673: }
1674: } else {
1675: tb.error(this);
1676: return false;
1677: }
1678: return true;","boolean process(Token t, HtmlTreeBuilder tb) {
            if (isWhitespace(t)) {
                tb.insert(t.asCharacter());
            } else if (t.isComment()) {
                tb.insert(t.asComment());
            } else if (t.isDoctype()) {
                tb.error(this);
                return false;
            } else if (t.isStartTag()) {
                Token.StartTag start = t.asStartTag();
                switch (start.normalName()) {
                    case ""html"":
                        return tb.process(start, InBody);
                    case ""frameset"":
                        tb.insert(start);
                        break;
                    case ""frame"":
                        tb.insertEmpty(start);
                        break;
                    case ""noframes"":
                        return tb.process(start, InHead);
                    default:
                        tb.error(this);
                        return false;
                }
            } else if (t.isEndTag() && t.asEndTag().normalName().equals(""frameset"")) {
                if (tb.currentElementIs(""html"")) { // frag
                    tb.error(this);
                    return false;
                } else {
                    tb.pop();
                    if (!tb.isFragmentParsing() && !tb.currentElementIs(""frameset"")) {
                        tb.transition(AfterFrameset);
                    }
                }
            } else if (t.isEOF()) {
                if (!tb.currentElementIs(""html"")) {
                    tb.error(this);
                    return true;
                }
            } else {
                tb.error(this);
                return false;
            }
            return true;
        }",0
jsoup 1.16.1,NULL_DEREFERENCE,src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java,"org.jsoup.parser.HtmlTreeBuilderState$20.process(org.jsoup.parser.Token,org.jsoup.parser.HtmlTreeBuilder):boolean",1659,object returned by `t.asEndTag().normalName()` could be null and is dereferenced at line 1659.,"1634: boolean process(Token t, HtmlTreeBuilder tb) {
1635: if (isWhitespace(t)) {
1636: tb.insert(t.asCharacter());
1637: } else if (t.isComment()) {
1638: tb.insert(t.asComment());
1639: } else if (t.isDoctype()) {
1640: tb.error(this);
1641: return false;
1642: } else if (t.isStartTag()) {
1643: Token.StartTag start = t.asStartTag();
1644: switch (start.normalName()) {
1645: case ""html"":
1646: return tb.process(start, InBody);
1647: case ""frameset"":
1648: tb.insert(start);
1649: break;
1650: case ""frame"":
1651: tb.insertEmpty(start);
1652: break;
1653: case ""noframes"":
1654: return tb.process(start, InHead);
1655: default:
1656: tb.error(this);
1657: return false;
1658: }
1659: } else if (t.isEndTag() && t.asEndTag().normalName().equals(""frameset"")) {
1660: if (tb.currentElementIs(""html"")) { // frag
1661: tb.error(this);
1662: return false;
1663: } else {
1664: tb.pop();
1665: if (!tb.isFragmentParsing() && !tb.currentElementIs(""frameset"")) {
1666: tb.transition(AfterFrameset);
1667: }
1668: }
1669: } else if (t.isEOF()) {
1670: if (!tb.currentElementIs(""html"")) {
1671: tb.error(this);
1672: return true;
1673: }
1674: } else {
1675: tb.error(this);
1676: return false;
1677: }
1678: return true;","boolean process(Token t, HtmlTreeBuilder tb) {
            if (isWhitespace(t)) {
                tb.insert(t.asCharacter());
            } else if (t.isComment()) {
                tb.insert(t.asComment());
            } else if (t.isDoctype()) {
                tb.error(this);
                return false;
            } else if (t.isStartTag()) {
                Token.StartTag start = t.asStartTag();
                switch (start.normalName()) {
                    case ""html"":
                        return tb.process(start, InBody);
                    case ""frameset"":
                        tb.insert(start);
                        break;
                    case ""frame"":
                        tb.insertEmpty(start);
                        break;
                    case ""noframes"":
                        return tb.process(start, InHead);
                    default:
                        tb.error(this);
                        return false;
                }
            } else if (t.isEndTag() && t.asEndTag().normalName().equals(""frameset"")) {
                if (tb.currentElementIs(""html"")) { // frag
                    tb.error(this);
                    return false;
                } else {
                    tb.pop();
                    if (!tb.isFragmentParsing() && !tb.currentElementIs(""frameset"")) {
                        tb.transition(AfterFrameset);
                    }
                }
            } else if (t.isEOF()) {
                if (!tb.currentElementIs(""html"")) {
                    tb.error(this);
                    return true;
                }
            } else {
                tb.error(this);
                return false;
            }
            return true;
        }",0
jsoup 1.16.1,NULL_DEREFERENCE,src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java,"org.jsoup.parser.HtmlTreeBuilderState$21.process(org.jsoup.parser.Token,org.jsoup.parser.HtmlTreeBuilder):boolean",1692,object returned by `t.asEndTag().normalName()` could be null and is dereferenced at line 1692.,"1682: boolean process(Token t, HtmlTreeBuilder tb) {
1683: if (isWhitespace(t)) {
1684: tb.insert(t.asCharacter());
1685: } else if (t.isComment()) {
1686: tb.insert(t.asComment());
1687: } else if (t.isDoctype()) {
1688: tb.error(this);
1689: return false;
1690: } else if (t.isStartTag() && t.asStartTag().normalName().equals(""html"")) {
1691: return tb.process(t, InBody);
1692: } else if (t.isEndTag() && t.asEndTag().normalName().equals(""html"")) {
1693: tb.transition(AfterAfterFrameset);
1694: } else if (t.isStartTag() && t.asStartTag().normalName().equals(""noframes"")) {
1695: return tb.process(t, InHead);
1696: } else if (t.isEOF()) {
1697: // cool your heels, we're complete
1698: } else {
1699: tb.error(this);
1700: return false;
1701: }
1702: return true;","boolean process(Token t, HtmlTreeBuilder tb) {
            if (isWhitespace(t)) {
                tb.insert(t.asCharacter());
            } else if (t.isComment()) {
                tb.insert(t.asComment());
            } else if (t.isDoctype()) {
                tb.error(this);
                return false;
            } else if (t.isStartTag() && t.asStartTag().normalName().equals(""html"")) {
                return tb.process(t, InBody);
            } else if (t.isEndTag() && t.asEndTag().normalName().equals(""html"")) {
                tb.transition(AfterAfterFrameset);
            } else if (t.isStartTag() && t.asStartTag().normalName().equals(""noframes"")) {
                return tb.process(t, InHead);
            } else if (t.isEOF()) {
                // cool your heels, we're complete
            } else {
                tb.error(this);
                return false;
            }
            return true;
        }",0
jsoup 1.16.1,NULL_DEREFERENCE,src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java,"org.jsoup.parser.HtmlTreeBuilderState$21.process(org.jsoup.parser.Token,org.jsoup.parser.HtmlTreeBuilder):boolean",1690,object returned by `t.asStartTag().normalName()` could be null and is dereferenced at line 1690.,"1682: boolean process(Token t, HtmlTreeBuilder tb) {
1683: if (isWhitespace(t)) {
1684: tb.insert(t.asCharacter());
1685: } else if (t.isComment()) {
1686: tb.insert(t.asComment());
1687: } else if (t.isDoctype()) {
1688: tb.error(this);
1689: return false;
1690: } else if (t.isStartTag() && t.asStartTag().normalName().equals(""html"")) {
1691: return tb.process(t, InBody);
1692: } else if (t.isEndTag() && t.asEndTag().normalName().equals(""html"")) {
1693: tb.transition(AfterAfterFrameset);
1694: } else if (t.isStartTag() && t.asStartTag().normalName().equals(""noframes"")) {
1695: return tb.process(t, InHead);
1696: } else if (t.isEOF()) {
1697: // cool your heels, we're complete
1698: } else {
1699: tb.error(this);
1700: return false;
1701: }
1702: return true;","boolean process(Token t, HtmlTreeBuilder tb) {
            if (isWhitespace(t)) {
                tb.insert(t.asCharacter());
            } else if (t.isComment()) {
                tb.insert(t.asComment());
            } else if (t.isDoctype()) {
                tb.error(this);
                return false;
            } else if (t.isStartTag() && t.asStartTag().normalName().equals(""html"")) {
                return tb.process(t, InBody);
            } else if (t.isEndTag() && t.asEndTag().normalName().equals(""html"")) {
                tb.transition(AfterAfterFrameset);
            } else if (t.isStartTag() && t.asStartTag().normalName().equals(""noframes"")) {
                return tb.process(t, InHead);
            } else if (t.isEOF()) {
                // cool your heels, we're complete
            } else {
                tb.error(this);
                return false;
            }
            return true;
        }",0
jsoup 1.16.1,NULL_DEREFERENCE,src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java,"org.jsoup.parser.HtmlTreeBuilderState$22.process(org.jsoup.parser.Token,org.jsoup.parser.HtmlTreeBuilder):boolean",1709,object returned by `t.asStartTag().normalName()` could be null and is dereferenced at line 1709.,"1706: boolean process(Token t, HtmlTreeBuilder tb) {
1707: if (t.isComment()) {
1708: tb.insert(t.asComment());
1709: } else if (t.isDoctype() || (t.isStartTag() && t.asStartTag().normalName().equals(""html""))) {
1710: return tb.process(t, InBody);
1711: } else if (isWhitespace(t)) {
1712: // spec deviation - body and html still on stack, but want this space to go after </html>
1713: Element doc = tb.getDocument();
1714: tb.insert(t.asCharacter(), doc);
1715: }else if (t.isEOF()) {
1716: // nice work chuck
1717: } else {
1718: tb.error(this);
1719: tb.resetBody();
1720: return tb.process(t);
1721: }
1722: return true;","boolean process(Token t, HtmlTreeBuilder tb) {
            if (t.isComment()) {
                tb.insert(t.asComment());
            } else if (t.isDoctype() || (t.isStartTag() && t.asStartTag().normalName().equals(""html""))) {
                return tb.process(t, InBody);
            } else if (isWhitespace(t)) {
                // spec deviation - body and html still on stack, but want this space to go after </html>
                Element doc = tb.getDocument();
                tb.insert(t.asCharacter(), doc);
            }else if (t.isEOF()) {
                // nice work chuck
            } else {
                tb.error(this);
                tb.resetBody();
                return tb.process(t);
            }
            return true;
        }",0
jsoup 1.16.1,NULL_DEREFERENCE,src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java,"org.jsoup.parser.HtmlTreeBuilderState$23.process(org.jsoup.parser.Token,org.jsoup.parser.HtmlTreeBuilder):boolean",1729,object returned by `t.asStartTag().normalName()` could be null and is dereferenced at line 1729.,"1726: boolean process(Token t, HtmlTreeBuilder tb) {
1727: if (t.isComment()) {
1728: tb.insert(t.asComment());
1729: } else if (t.isDoctype() || isWhitespace(t) || (t.isStartTag() && t.asStartTag().normalName().equals(""html""))) {
1730: return tb.process(t, InBody);
1731: } else if (t.isEOF()) {
1732: // nice work chuck
1733: } else if (t.isStartTag() && t.asStartTag().normalName().equals(""noframes"")) {
1734: return tb.process(t, InHead);
1735: } else {
1736: tb.error(this);
1737: return false;
1738: }
1739: return true;","boolean process(Token t, HtmlTreeBuilder tb) {
            if (t.isComment()) {
                tb.insert(t.asComment());
            } else if (t.isDoctype() || isWhitespace(t) || (t.isStartTag() && t.asStartTag().normalName().equals(""html""))) {
                return tb.process(t, InBody);
            } else if (t.isEOF()) {
                // nice work chuck
            } else if (t.isStartTag() && t.asStartTag().normalName().equals(""noframes"")) {
                return tb.process(t, InHead);
            } else {
                tb.error(this);
                return false;
            }
            return true;
        }",0
bundletool-1.15.1,RESOURCE_LEAK,src/main/java/com/android/tools/build/bundletool/transparency/ApkModeTransparencyChecker.java,com.android.tools.build.bundletool.transparency.ApkModeTransparencyChecker.checkTransparency(com.android.tools.build.bundletool.commands.CheckTransparencyCommand):com.android.tools.build.bundletool.transparency.TransparencyCheckResult,43,"resource of type `com.android.tools.build.bundletool.io.TempDirectory` acquired by call to `new()` at line 40 is not released after line 43.
**Note**: potential exception at line 42",https://github.com/google/bundletool/blob/1.15.1/src/main/java/com/android/tools/build/bundletool/transparency/ApkModeTransparencyChecker.java,"public static TransparencyCheckResult checkTransparency(CheckTransparencyCommand command) {
    try (TempDirectory tempDir = new TempDirectory(""apk-transparency-checker"")) {
      return ApkTransparencyCheckUtils.checkTransparency(
          extractAllApksFromZip(command.getApkZipPath().get(), tempDir));
    } catch (IOException e) {
      throw new UncheckedIOException(""An error occurred when processing the file."", e);
    }
  }",0
bundletool-1.15.1,RESOURCE_LEAK,src/main/java/com/android/tools/build/bundletool/transparency/ApkModeTransparencyChecker.java,"com.android.tools.build.bundletool.transparency.ApkModeTransparencyChecker.extractAllApksFromZip(java.nio.file.Path,com.android.tools.build.bundletool.io.TempDirectory):com.google.common.collect.ImmutableList",55,"resource of type `java.util.zip.ZipFile` acquired to `zipOfApks` by call to `openZipFile(...)` at line 55 is not released after line 55.
**Note**: potential exception at line 72","49: private static ImmutableList<Path> extractAllApksFromZip(
 50: Path zipOfApksPath, TempDirectory tempDirectory) throws IOException {
 51: ImmutableList.Builder<Path> allExtractedApkPaths = ImmutableList.builder();
 52: Path zipExtractedSubDirectory = tempDirectory.getPath().resolve(""extracted"");
 53: Files.createDirectory(zipExtractedSubDirectory);
 54: 
 55: try (ZipFile zipOfApks = ZipUtils.openZipFile(zipOfApksPath)) {
 56: ImmutableList<ZipEntry> listOfApksToExtract =
 57: zipOfApks.stream()
 58: .filter(
 59: zipEntry ->
 60: !zipEntry.isDirectory()
 61: && zipEntry.getName().toLowerCase(Locale.ROOT).endsWith("".apk""))
 62: .collect(toImmutableList());
 63: 
 64: for (ZipEntry apkToExtract : listOfApksToExtract) {
 65: Path extractedApkPath =
 66: zipExtractedSubDirectory.resolve(ZipPath.create(apkToExtract.getName()).toString());
 67: Files.createDirectories(extractedApkPath.getParent());
 68: try (InputStream inputStream = zipOfApks.getInputStream(apkToExtract);
 69: OutputStream outputApk = Files.newOutputStream(extractedApkPath)) {
 70: ByteStreams.copy(inputStream, outputApk);
 71: allExtractedApkPaths.add(extractedApkPath);
 72: }
 73: }
 74: }
 75: return allExtractedApkPaths.build();","private static ImmutableList<Path> extractAllApksFromZip(
      Path zipOfApksPath, TempDirectory tempDirectory) throws IOException {
    ImmutableList.Builder<Path> allExtractedApkPaths = ImmutableList.builder();
    Path zipExtractedSubDirectory = tempDirectory.getPath().resolve(""extracted"");
    Files.createDirectory(zipExtractedSubDirectory);

    try (ZipFile zipOfApks = ZipUtils.openZipFile(zipOfApksPath)) {
      ImmutableList<ZipEntry> listOfApksToExtract =
          zipOfApks.stream()
              .filter(
                  zipEntry ->
                      !zipEntry.isDirectory()
                          && zipEntry.getName().toLowerCase(Locale.ROOT).endsWith("".apk""))
              .collect(toImmutableList());

      for (ZipEntry apkToExtract : listOfApksToExtract) {
        Path extractedApkPath =
            zipExtractedSubDirectory.resolve(ZipPath.create(apkToExtract.getName()).toString());
        Files.createDirectories(extractedApkPath.getParent());
        try (InputStream inputStream = zipOfApks.getInputStream(apkToExtract);
            OutputStream outputApk = Files.newOutputStream(extractedApkPath)) {
          ByteStreams.copy(inputStream, outputApk);
          allExtractedApkPaths.add(extractedApkPath);
        }
      }
    }
    return allExtractedApkPaths.build();
  }",0
bundletool-1.15.1,RESOURCE_LEAK,src/main/java/com/android/tools/build/bundletool/size/ApkBreakdownGenerator.java,com.android.tools.build.bundletool.size.ApkBreakdownGenerator.calculateBreakdown(java.nio.file.Path):com.android.bundle.SizesOuterClass$Breakdown,58,"resource of type `java.util.zip.ZipFile` acquired to `apk` by call to `ZipFile(...)` at line 58 is not released after line 58.
**Note**: potential exception at line 59",https://github.com/google/bundletool/blob/1.15.1/src/main/java/com/android/tools/build/bundletool/size/ApkBreakdownGenerator.java,"public Breakdown calculateBreakdown(Path apkPath) throws IOException {
    try (ZipFile apk = new ZipFile(apkPath.toFile())) {
      ImmutableMap<String, Long> downloadSizeByEntry = calculateDownloadSizePerEntry(apk);

      ImmutableMap<ApkComponent, Long> downloadSizeByComponent =
          downloadSizeByEntry.entrySet().stream()
              .collect(
                      groupingByDeterministic(
                          entry -> ApkComponent.fromEntryName(entry.getKey()),
                          Collectors.summingLong(Map.Entry<String, Long>::getValue)));

      ImmutableMap<ApkComponent, Long> diskSizeByComponent =
          apk.stream()
              .collect(
                  groupingByDeterministic(
                      zipEntry -> ApkComponent.fromEntryName(zipEntry.getName()),
                      Collectors.summingLong(ZipEntry::getCompressedSize)));

      Sizes actualTotalSize = calculateActualTotals(apkPath);
      Sizes zipOverheads =
          subtractSizes(
              actualTotalSize,
              sizes(
                  diskSizeByComponent.values().stream().mapToLong(Long::longValue).sum(),
                  downloadSizeByComponent.values().stream().mapToLong(Long::longValue).sum()));

      return Breakdown.newBuilder()
          .setDex(getSizes(ApkComponent.DEX, diskSizeByComponent, downloadSizeByComponent))
          .setAssets(getSizes(ApkComponent.ASSETS, diskSizeByComponent, downloadSizeByComponent))
          .setNativeLibs(
              getSizes(ApkComponent.NATIVE_LIBS, diskSizeByComponent, downloadSizeByComponent))
          .setResources(
              getSizes(ApkComponent.RESOURCES, diskSizeByComponent, downloadSizeByComponent))
          .setOther(
              addSizes(
                  getSizes(ApkComponent.OTHER, diskSizeByComponent, downloadSizeByComponent),
                  zipOverheads))
          .setTotal(actualTotalSize)
          .build();
    }
  }",0
bundletool-1.15.1,RESOURCE_LEAK,src/main/java/com/android/tools/build/bundletool/model/utils/ApkSizeUtils.java,"com.android.tools.build.bundletool.model.utils.ApkSizeUtils.getCompressedSizeByApkPaths(com.google.common.collect.ImmutableList,java.nio.file.Path):com.google.common.collect.ImmutableMap",65,"resource of type `java.util.zip.ZipFile` acquired by call to `ZipFile(...)` at line 54 is not released after line 65.
**Note**: potential exception at line 62","51: public static ImmutableMap<String, Long> getCompressedSizeByApkPaths(
 52: ImmutableList<String> apkPaths, Path apksArchive) {
 53: ImmutableMap.Builder<String, Long> sizeByApkPath = ImmutableMap.builder();
 54: try (ZipFile apksZip = new ZipFile(apksArchive.toFile())) {
 55: for (String apkPath : apkPaths) {
 56: ZipEntry entry = checkNotNull(apksZip.getEntry(apkPath));
 57: // It's possible that the compressed size is larger than the uncompressed one, but the
 58: // smallest APK is the one that is actually served.
 59: long size =
 60: Math.min(
 61: entry.getSize(),
 62: GZipUtils.calculateGzipCompressedSize(ZipUtils.asByteSource(apksZip, entry)));
 63: sizeByApkPath.put(apkPath, size);
 64: }
 65: } catch (IOException e) {
 66: throw new UncheckedIOException(
 67: String.format(""Error while processing the APK Set archive '%s'."", apksArchive), e);
 68: }
 69: return sizeByApkPath.build();","public static ImmutableMap<String, Long> getCompressedSizeByApkPaths(
      ImmutableList<String> apkPaths, Path apksArchive) {
    ImmutableMap.Builder<String, Long> sizeByApkPath = ImmutableMap.builder();
    try (ZipFile apksZip = new ZipFile(apksArchive.toFile())) {
      for (String apkPath : apkPaths) {
        ZipEntry entry = checkNotNull(apksZip.getEntry(apkPath));
        // It's possible that the compressed size is larger than the uncompressed one, but the
        // smallest APK is the one that is actually served.
        long size =
            Math.min(
                entry.getSize(),
                GZipUtils.calculateGzipCompressedSize(ZipUtils.asByteSource(apksZip, entry)));
        sizeByApkPath.put(apkPath, size);
      }
    } catch (IOException e) {
      throw new UncheckedIOException(
          String.format(""Error while processing the APK Set archive '%s'."", apksArchive), e);
    }
    return sizeByApkPath.build();
  }

  private ApkSizeUtils() {}
}",0
bundletool-1.15.1,RESOURCE_LEAK,src/main/java/com/android/tools/build/bundletool/transparency/ConnectedDeviceModeTransparencyChecker.java,com.android.tools.build.bundletool.transparency.ConnectedDeviceModeTransparencyChecker.checkTransparency(com.android.tools.build.bundletool.commands.CheckTransparencyCommand):com.android.tools.build.bundletool.transparency.TransparencyCheckResult,78,"resource of type `com.android.tools.build.bundletool.io.TempDirectory` acquired by call to `new()` at line 64 is not released after line 78.
**Note**: potential exception at line 73",https://github.com/google/bundletool/blob/1.15.1/src/main/java/com/android/tools/build/bundletool/transparency/ConnectedDeviceModeTransparencyChecker.java,"public static TransparencyCheckResult checkTransparency(CheckTransparencyCommand command) {
    command.getAdbServer().get().init(command.getAdbPath().get());
    AdbRunner adbRunner = new AdbRunner(command.getAdbServer().get());
    Device adbDevice = getDevice(command.getAdbServer().get(), command.getDeviceId());

    // Execute a shell command to retrieve paths to all APKs for the given package name.
    AdbShellCommandTask adbShellCommandTask =
        new AdbShellCommandTask(adbDevice, ""pm path "" + command.getPackageName().get());
    ImmutableList<String> pathsToApksOnDevice =
        adbShellCommandTask.execute().stream()
            .filter(path -> path.startsWith(APK_PATH_ON_DEVICE_PREFIX))
            .map(path -> path.substring(APK_PATH_ON_DEVICE_PREFIX.length()))
            .collect(toImmutableList());
    if (pathsToApksOnDevice.isEmpty()) {
      throw InvalidCommandException.builder()
          .withInternalMessage(""No files found for package "" + command.getPackageName().get())
          .build();
    }

    // Pull APKs to a temporary directory and verify code transparency.
    try (TempDirectory tempDir = new TempDirectory(""connected-device-transparency-check"")) {
      Path apksExtractedSubDirectory = tempDir.getPath().resolve(""extracted"");
      Files.createDirectory(apksExtractedSubDirectory);
      ImmutableList<FilePullParams> pullParams =
          createPullParams(pathsToApksOnDevice, apksExtractedSubDirectory);

      if (command.getDeviceId().isPresent()) {
        adbRunner.run(device -> device.pull(pullParams), command.getDeviceId().get());
      } else {
        adbRunner.run(device -> device.pull(pullParams));
      }

      return ApkTransparencyCheckUtils.checkTransparency(
          pullParams.stream().map(FilePullParams::getDestinationPath).collect(toImmutableList()));
    } catch (IOException e) {
      throw new UncheckedIOException(e);
    }
  }",0
bundletool-1.15.1,RESOURCE_LEAK,src/main/java/com/android/tools/build/bundletool/io/ApkSigner.java,"com.android.tools.build.bundletool.io.ApkSigner.signApk(java.nio.file.Path,com.android.tools.build.bundletool.model.ModuleSplit):java.util.Optional",103,"resource of type `com.android.tools.build.bundletool.io.TempDirectory` acquired by call to `new()` at line 75 is not released after line 103.
**Note**: potential exception at line 88",https://github.com/google/bundletool/blob/1.15.1/src/main/java/com/android/tools/build/bundletool/io/ApkSigner.java,"public Optional<SigningDescription> signApk(Path apkPath, ModuleSplit split) {
    if (!signingConfigProvider.isPresent()) {
      return Optional.empty();
    }

    ApksigSigningConfiguration signingConfig =
        signingConfigProvider.get().getSigningConfiguration(ApkDescription.fromModuleSplit(split));

    try (TempDirectory tempDirectory = new TempDirectory(getClass().getSimpleName())) {
      Path signedApkPath = tempDirectory.getPath().resolve(""signed.apk"");
      com.android.apksig.ApkSigner.Builder apkSigner =
          new com.android.apksig.ApkSigner.Builder(
                  signingConfig.getSignerConfigs().stream()
                      .map(ApkSigner::convertToApksigSignerConfig)
                      .collect(toImmutableList()))
              .setInputApk(apkPath.toFile())
              .setOutputApk(signedApkPath.toFile())
              .setV1SigningEnabled(signingConfig.getV1SigningEnabled())
              .setV2SigningEnabled(signingConfig.getV2SigningEnabled())
              .setV3SigningEnabled(signingConfig.getV3SigningEnabled())
              .setOtherSignersSignaturesPreserved(false)
              .setMinSdkVersion(split.getAndroidManifest().getEffectiveMinSdkVersion());
      signingConfig
          .getSigningCertificateLineage()
          .ifPresent(apkSigner::setSigningCertificateLineage);


      sourceStampSigningConfig.ifPresent(
          stampConfig -> {
            apkSigner.setSourceStampSignerConfig(
                convertToApksigSignerConfig(
                    stampConfig.getSigningConfiguration().getSignerConfig()));
          });
      apkSigner.build().sign();
      Files.move(signedApkPath, apkPath, REPLACE_EXISTING);
      return Optional.of(signingDescription(signingConfig));
    } catch (IOException
        | ApkFormatException
        | NoSuchAlgorithmException
        | InvalidKeyException
        | SignatureException e) {
      throw CommandExecutionException.builder()
          .withCause(e)
          .withInternalMessage(""Unable to sign APK."")
          .build();
    }
  }",0
bundletool-1.15.1,RESOURCE_LEAK,src/main/java/com/android/tools/build/bundletool/commands/BuildSdkAsarCommand.java,com.android.tools.build.bundletool.commands.BuildSdkAsarCommand.execute():java.nio.file.Path,114,"resource of type `java.util.zip.ZipFile` acquired by call to `getModulesZip(...)` at line 120 is not released after line 114.
**Note**: potential exception at line 123",https://github.com/google/bundletool/blob/1.15.1/src/main/java/com/android/tools/build/bundletool/commands/BuildSdkAsarCommand.java,"public Path execute() {
    validateInput();

    try (ZipFile bundleZip = new ZipFile(getSdkBundlePath().toFile())) {
      TempDirectory tempDir = new TempDirectory(getClass().getSimpleName());
      SdkBundleValidator bundleValidator = SdkBundleValidator.create();
      bundleValidator.validateFile(bundleZip);

      Path modulesPath = tempDir.getPath().resolve(SDK_MODULES_FILE_NAME);
      try (ZipFile modulesZip = getModulesZip(bundleZip, modulesPath)) {
        bundleValidator.validateModulesFile(modulesZip);
        SdkBundle sdkBundle =
            SdkBundle.buildFromZip(bundleZip, modulesZip, PLACEHOLDER_VERSION_CODE);
        bundleValidator.validate(sdkBundle);

        DaggerBuildSdkAsarManagerComponent.builder()
            .setBuildSdkAsarCommand(this)
            .setSdkBundle(sdkBundle)
            .build()
            .create()
            .execute(modulesPath);
      }
    } catch (ZipException e) {
      throw InvalidBundleException.builder()
          .withCause(e)
          .withUserMessage(""The SDK Bundle is not a valid zip file."")
          .build();
    } catch (IOException e) {
      throw new UncheckedIOException(""An error occurred when validating the Sdk Bundle."", e);
    }

    return getOutputFile();
  }",0
bundletool-1.15.1,RESOURCE_LEAK,src/main/java/com/android/tools/build/bundletool/commands/BuildSdkAsarCommand.java,com.android.tools.build.bundletool.commands.BuildSdkAsarCommand.execute():java.nio.file.Path,119,resource of type `com.android.tools.build.bundletool.io.TempDirectory` acquired by call to `new()` at line 115 is not released after line 119.,https://github.com/google/bundletool/blob/1.15.1/src/main/java/com/android/tools/build/bundletool/commands/BuildSdkAsarCommand.java,"public Path execute() {
    validateInput();

    try (ZipFile bundleZip = new ZipFile(getSdkBundlePath().toFile())) {
      TempDirectory tempDir = new TempDirectory(getClass().getSimpleName());
      SdkBundleValidator bundleValidator = SdkBundleValidator.create();
      bundleValidator.validateFile(bundleZip);

      Path modulesPath = tempDir.getPath().resolve(SDK_MODULES_FILE_NAME);
      try (ZipFile modulesZip = getModulesZip(bundleZip, modulesPath)) {
        bundleValidator.validateModulesFile(modulesZip);
        SdkBundle sdkBundle =
            SdkBundle.buildFromZip(bundleZip, modulesZip, PLACEHOLDER_VERSION_CODE);
        bundleValidator.validate(sdkBundle);

        DaggerBuildSdkAsarManagerComponent.builder()
            .setBuildSdkAsarCommand(this)
            .setSdkBundle(sdkBundle)
            .build()
            .create()
            .execute(modulesPath);
      }
    } catch (ZipException e) {
      throw InvalidBundleException.builder()
          .withCause(e)
          .withUserMessage(""The SDK Bundle is not a valid zip file."")
          .build();
    } catch (IOException e) {
      throw new UncheckedIOException(""An error occurred when validating the Sdk Bundle."", e);
    }

    return getOutputFile();
  }",0
bundletool-1.15.1,RESOURCE_LEAK,src/main/java/com/android/tools/build/bundletool/commands/BuildSdkAsarCommand.java,com.android.tools.build.bundletool.commands.BuildSdkAsarCommand.execute():java.nio.file.Path,133,"resource of type `java.util.zip.ZipFile` acquired by call to `ZipFile(...)` at line 114 is not released after line 133.
**Note**: potential exception at line 120",https://github.com/google/bundletool/blob/1.15.1/src/main/java/com/android/tools/build/bundletool/commands/BuildSdkAsarCommand.java,"public Path execute() {
    validateInput();

    try (ZipFile bundleZip = new ZipFile(getSdkBundlePath().toFile())) {
      TempDirectory tempDir = new TempDirectory(getClass().getSimpleName());
      SdkBundleValidator bundleValidator = SdkBundleValidator.create();
      bundleValidator.validateFile(bundleZip);

      Path modulesPath = tempDir.getPath().resolve(SDK_MODULES_FILE_NAME);
      try (ZipFile modulesZip = getModulesZip(bundleZip, modulesPath)) {
        bundleValidator.validateModulesFile(modulesZip);
        SdkBundle sdkBundle =
            SdkBundle.buildFromZip(bundleZip, modulesZip, PLACEHOLDER_VERSION_CODE);
        bundleValidator.validate(sdkBundle);

        DaggerBuildSdkAsarManagerComponent.builder()
            .setBuildSdkAsarCommand(this)
            .setSdkBundle(sdkBundle)
            .build()
            .create()
            .execute(modulesPath);
      }
    } catch (ZipException e) {
      throw InvalidBundleException.builder()
          .withCause(e)
          .withUserMessage(""The SDK Bundle is not a valid zip file."")
          .build();
    } catch (IOException e) {
      throw new UncheckedIOException(""An error occurred when validating the Sdk Bundle."", e);
    }

    return getOutputFile();
  }",0
bundletool-1.15.1,RESOURCE_LEAK,src/main/java/com/android/tools/build/bundletool/commands/BuildSdkAsarCommand.java,com.android.tools.build.bundletool.commands.BuildSdkAsarCommand.execute():java.nio.file.Path,133,"resource of type `java.util.zip.ZipFile` acquired by call to `getModulesZip(...)` at line 120 is not released after line 133.
**Note**: potential exception at line 123",https://github.com/google/bundletool/blob/1.15.1/src/main/java/com/android/tools/build/bundletool/commands/BuildSdkAsarCommand.java,"public Path execute() {
    validateInput();

    try (ZipFile bundleZip = new ZipFile(getSdkBundlePath().toFile())) {
      TempDirectory tempDir = new TempDirectory(getClass().getSimpleName());
      SdkBundleValidator bundleValidator = SdkBundleValidator.create();
      bundleValidator.validateFile(bundleZip);

      Path modulesPath = tempDir.getPath().resolve(SDK_MODULES_FILE_NAME);
      try (ZipFile modulesZip = getModulesZip(bundleZip, modulesPath)) {
        bundleValidator.validateModulesFile(modulesZip);
        SdkBundle sdkBundle =
            SdkBundle.buildFromZip(bundleZip, modulesZip, PLACEHOLDER_VERSION_CODE);
        bundleValidator.validate(sdkBundle);

        DaggerBuildSdkAsarManagerComponent.builder()
            .setBuildSdkAsarCommand(this)
            .setSdkBundle(sdkBundle)
            .build()
            .create()
            .execute(modulesPath);
      }
    } catch (ZipException e) {
      throw InvalidBundleException.builder()
          .withCause(e)
          .withUserMessage(""The SDK Bundle is not a valid zip file."")
          .build();
    } catch (IOException e) {
      throw new UncheckedIOException(""An error occurred when validating the Sdk Bundle."", e);
    }

    return getOutputFile();
  }",0
bundletool-1.15.1,RESOURCE_LEAK,src/main/java/com/android/tools/build/bundletool/commands/DumpManager.java,com.android.tools.build.bundletool.commands.DumpManager.printBundleConfig():void,136,"resource of type `java.util.zip.ZipFile` acquired by call to `ZipFile(...)` at line 132 is not released after line 136.
**Note**: potential exception at line 134",https://github.com/google/bundletool/blob/1.15.1/src/main/java/com/android/tools/build/bundletool/commands/DumpManager.java,"void printBundleConfig() {
    try (ZipFile zipFile = new ZipFile(bundlePath.toFile())) {
      BundleConfig bundleConfig =
          extractAndParse(zipFile, ZipPath.create(""BundleConfig.pb""), BundleConfig::parseFrom);
      printStream.println(JsonFormat.printer().print(bundleConfig));
    } catch (IOException e) {
      throw new UncheckedIOException(""Error occurred when reading the bundle."", e);
    }
  }",0
bundletool-1.15.1,RESOURCE_LEAK,src/main/java/com/android/tools/build/bundletool/commands/BuildSdkAsarCommand.java,com.android.tools.build.bundletool.commands.BuildSdkAsarCommand.execute():java.nio.file.Path,138,"resource of type `java.util.zip.ZipFile` acquired by call to `ZipFile(...)` at line 114 is not released after line 138.
**Note**: potential exception at line 120",https://github.com/google/bundletool/blob/1.15.1/src/main/java/com/android/tools/build/bundletool/commands/BuildSdkAsarCommand.java,"public Path execute() {
    validateInput();

    try (ZipFile bundleZip = new ZipFile(getSdkBundlePath().toFile())) {
      TempDirectory tempDir = new TempDirectory(getClass().getSimpleName());
      SdkBundleValidator bundleValidator = SdkBundleValidator.create();
      bundleValidator.validateFile(bundleZip);

      Path modulesPath = tempDir.getPath().resolve(SDK_MODULES_FILE_NAME);
      try (ZipFile modulesZip = getModulesZip(bundleZip, modulesPath)) {
        bundleValidator.validateModulesFile(modulesZip);
        SdkBundle sdkBundle =
            SdkBundle.buildFromZip(bundleZip, modulesZip, PLACEHOLDER_VERSION_CODE);
        bundleValidator.validate(sdkBundle);

        DaggerBuildSdkAsarManagerComponent.builder()
            .setBuildSdkAsarCommand(this)
            .setSdkBundle(sdkBundle)
            .build()
            .create()
            .execute(modulesPath);
      }
    } catch (ZipException e) {
      throw InvalidBundleException.builder()
          .withCause(e)
          .withUserMessage(""The SDK Bundle is not a valid zip file."")
          .build();
    } catch (IOException e) {
      throw new UncheckedIOException(""An error occurred when validating the Sdk Bundle."", e);
    }

    return getOutputFile();
  }",0
bundletool-1.15.1,RESOURCE_LEAK,src/main/java/com/android/tools/build/bundletool/commands/BuildSdkAsarCommand.java,com.android.tools.build.bundletool.commands.BuildSdkAsarCommand.execute():java.nio.file.Path,138,"resource of type `java.util.zip.ZipFile` acquired by call to `getModulesZip(...)` at line 120 is not released after line 138.
**Note**: potential exception at line 123",https://github.com/google/bundletool/blob/1.15.1/src/main/java/com/android/tools/build/bundletool/commands/BuildSdkAsarCommand.java,"public Path execute() {
    validateInput();

    try (ZipFile bundleZip = new ZipFile(getSdkBundlePath().toFile())) {
      TempDirectory tempDir = new TempDirectory(getClass().getSimpleName());
      SdkBundleValidator bundleValidator = SdkBundleValidator.create();
      bundleValidator.validateFile(bundleZip);

      Path modulesPath = tempDir.getPath().resolve(SDK_MODULES_FILE_NAME);
      try (ZipFile modulesZip = getModulesZip(bundleZip, modulesPath)) {
        bundleValidator.validateModulesFile(modulesZip);
        SdkBundle sdkBundle =
            SdkBundle.buildFromZip(bundleZip, modulesZip, PLACEHOLDER_VERSION_CODE);
        bundleValidator.validate(sdkBundle);

        DaggerBuildSdkAsarManagerComponent.builder()
            .setBuildSdkAsarCommand(this)
            .setSdkBundle(sdkBundle)
            .build()
            .create()
            .execute(modulesPath);
      }
    } catch (ZipException e) {
      throw InvalidBundleException.builder()
          .withCause(e)
          .withUserMessage(""The SDK Bundle is not a valid zip file."")
          .build();
    } catch (IOException e) {
      throw new UncheckedIOException(""An error occurred when validating the Sdk Bundle."", e);
    }

    return getOutputFile();
  }",0
bundletool-1.15.1,RESOURCE_LEAK,src/main/java/com/android/tools/build/bundletool/commands/DumpManager.java,"com.android.tools.build.bundletool.commands.DumpManager.extractAndParse(java.nio.file.Path,com.android.tools.build.bundletool.model.AutoValue_ZipPath,com.android.tools.build.bundletool.commands.DumpManager$Lambda$_10_26):java.lang.Object",182,"resource of type `java.util.zip.ZipFile` acquired by call to `ZipFile(...)` at line 180 is not released after line 182.
**Note**: potential exception at line 181",https://github.com/google/bundletool/blob/1.15.1/src/main/java/com/android/tools/build/bundletool/commands/DumpManager.java,"private static <T> T extractAndParse(
      Path bundlePath, ZipPath filePath, ProtoParser<T> protoParser) {
    try (ZipFile zipFile = new ZipFile(bundlePath.toFile())) {
      return extractAndParse(zipFile, filePath, protoParser);
    } catch (ZipException e) {
      throw InvalidBundleException.builder()
          .withUserMessage(""Bundle is not a valid zip file."")
          .withCause(e)
          .build();
    } catch (IOException e) {
      throw new UncheckedIOException(""Error occurred when trying to open the bundle."", e);
    }
  }",0
bundletool-1.15.1,RESOURCE_LEAK,src/main/java/com/android/tools/build/bundletool/commands/DumpManager.java,"com.android.tools.build.bundletool.commands.DumpManager.extractAndParse(java.nio.file.Path,com.android.tools.build.bundletool.model.AutoValue_ZipPath,com.android.tools.build.bundletool.commands.DumpManager$Lambda$_10_26):java.lang.Object",187,"resource of type `java.util.zip.ZipFile` acquired by call to `ZipFile(...)` at line 180 is not released after line 187.
**Note**: potential exception at line 181",https://github.com/google/bundletool/blob/1.15.1/src/main/java/com/android/tools/build/bundletool/commands/DumpManager.java,"private static <T> T extractAndParse(
      Path bundlePath, ZipPath filePath, ProtoParser<T> protoParser) {
    try (ZipFile zipFile = new ZipFile(bundlePath.toFile())) {
      return extractAndParse(zipFile, filePath, protoParser);
    } catch (ZipException e) {
      throw InvalidBundleException.builder()
          .withUserMessage(""Bundle is not a valid zip file."")
          .withCause(e)
          .build();
    } catch (IOException e) {
      throw new UncheckedIOException(""Error occurred when trying to open the bundle."", e);
    }
  }",0
bundletool-1.15.1,RESOURCE_LEAK,src/main/java/com/android/tools/build/bundletool/commands/InstallApksCommand.java,com.android.tools.build.bundletool.commands.InstallApksCommand.execute():void,201,"resource of type `com.android.tools.build.bundletool.io.TempDirectory` acquired to `tempDirectory` by call to `TempDirectory()` at line 201 is not released after line 201.
**Note**: potential exception at line 216",https://github.com/google/bundletool/blob/1.15.1/src/main/java/com/android/tools/build/bundletool/commands/InstallApksCommand.java,"public void execute() {
    BuildApksResult toc = readBuildApksResult();
    validateInput(toc);

    AdbServer adbServer = getAdbServer();
    adbServer.init(getAdbPath());

    try (TempDirectory tempDirectory = new TempDirectory()) {
      DeviceSpec deviceSpec = new DeviceAnalyzer(adbServer).getDeviceSpec(getDeviceId());
      if (getDeviceTier().isPresent()) {
        deviceSpec =
            deviceSpec.toBuilder().setDeviceTier(Int32Value.of(getDeviceTier().get())).build();
      }
      if (getDeviceGroups().isPresent()) {
        deviceSpec = deviceSpec.toBuilder().addAllDeviceGroups(getDeviceGroups().get()).build();
      }
      if (getCountrySet().isPresent()) {
        deviceSpec =
            deviceSpec.toBuilder().setCountrySet(StringValue.of(getCountrySet().get())).build();
      }

      final ImmutableList<Path> apksToInstall =
          getApksToInstall(toc, deviceSpec, tempDirectory.getPath());
      final ImmutableList<Path> filesToPush =
          ImmutableList.<Path>builder()
              .addAll(getApksToPushToStorage(toc, deviceSpec, tempDirectory.getPath()))
              .addAll(getAdditionalLocalTestingFiles().orElse(ImmutableList.of()))
              .build();

      AdbRunner adbRunner = new AdbRunner(adbServer);
      InstallOptions installOptions =
          InstallOptions.builder()
              .setAllowDowngrade(getAllowDowngrade())
              .setAllowTestOnly(getAllowTestOnly())
              .setGrantRuntimePermissions(getGrantRuntimePermissions())
              .setTimeout(getTimeout())
              .build();

      if (getDeviceId().isPresent()) {
        adbRunner.run(
            device -> device.installApks(apksToInstall, installOptions), getDeviceId().get());
      } else {
        adbRunner.run(device -> device.installApks(apksToInstall, installOptions));
      }

      if (!filesToPush.isEmpty()) {
        pushFiles(filesToPush, toc, adbRunner);
      }
      if (toc.getLocalTestingInfo().getEnabled()) {
        cleanUpEmulatedSplits(adbRunner, toc);
      }
    }
  }",0
bundletool-1.15.1,RESOURCE_LEAK,src/main/java/com/android/tools/build/bundletool/commands/InstallMultiApksCommand.java,com.android.tools.build.bundletool.commands.InstallMultiApksCommand.execute():void,222,"resource of type `com.android.tools.build.bundletool.io.TempDirectory` acquired to `tempDirectory` by call to `TempDirectory()` at line 222 is not released after line 222.
**Note**: potential exception at line 225",https://github.com/google/bundletool/blob/1.15.1/src/main/java/com/android/tools/build/bundletool/commands/InstallMultiApksCommand.java,"public void execute() throws TimeoutException, IOException {
    validateInput();

    AdbServer adbServer = getAdbServer();
    adbServer.init(getAdbPath());

    try (TempDirectory tempDirectory = new TempDirectory()) {
      DeviceAnalyzer deviceAnalyzer = new DeviceAnalyzer(adbServer);
      DeviceSpec deviceSpec = deviceAnalyzer.getDeviceSpec(getDeviceId());
      Device device = deviceAnalyzer.getAndValidateDevice(getDeviceId());

      if (getTimeout().isPresent()
          && !device.getVersion().isGreaterOrEqualThan(Versions.ANDROID_S_API_VERSION)) {
        throw InvalidCommandException.builder()
            .withInternalMessage(
                ""'%s' flag is supported for Android 12+ devices."", TIMEOUT_MILLIS_FLAG.getName())
            .build();
      }

      Path aapt2Dir = tempDirectory.getPath().resolve(""aapt2"");
      Files.createDirectory(aapt2Dir);
      Supplier<Aapt2Command> aapt2CommandSupplier =
          Suppliers.memoize(() -> getOrExtractAapt2Command(aapt2Dir));

      ImmutableMap<String, InstalledPackageInfo> existingPackages =
          getPackagesInstalledOnDevice(device);

      ImmutableList<PackagePathVersion> installableApksFilesWithBadgingInfo =
          getActualApksPaths(tempDirectory).stream()
              .flatMap(
                  apksArchivePath ->
                      stream(
                          apksWithPackageName(apksArchivePath, deviceSpec, aapt2CommandSupplier)))
              .filter(apks -> shouldInstall(apks, existingPackages))
              .collect(toImmutableList());

      ImmutableList<PackagePathVersion> apkFilesToInstall =
          uniqueApksByPackageName(installableApksFilesWithBadgingInfo).stream()
              .flatMap(
                  apks ->
                      extractApkListFromApks(
                          deviceSpec,
                          apks,
                          Optional.ofNullable(existingPackages.get(apks.getPackageName())),
                          tempDirectory)
                          .stream())
              .collect(toImmutableList());
      ImmutableListMultimap<String, String> apkToInstallByPackage =
          apkFilesToInstall.stream()
              .collect(
                  toImmutableListMultimap(
                      PackagePathVersion::getPackageName,
                      packagePathVersion ->
                          packagePathVersion.getPath().toAbsolutePath().toString()));

      if (apkFilesToInstall.isEmpty()) {
        logger.warning(""No packages found to install! Exiting..."");
        return;
      }

      AdbCommand adbCommand = getOrCreateAdbCommand();
      ImmutableList<String> commandResults =
          adbCommand.installMultiPackage(
              apkToInstallByPackage, getStaged(), getEnableRollback(), getTimeout(), getDeviceId());
      logger.info(String.format(""Output:\n%s"", String.join(""\n"", commandResults)));
      logger.info(""Please reboot device to complete installation."");
    }
  }",0
bundletool-1.15.1,RESOURCE_LEAK,src/main/java/com/android/tools/build/bundletool/model/utils/BundleParser.java,"com.android.tools.build.bundletool.model.utils.BundleParser.getModulesZip(java.util.zip.ZipFile,java.nio.file.Path):java.util.zip.ZipFile",298,"resource of type `java.util.zip.ZipFile` acquired by call to `ZipFile(...)` at line 297 is not released after line 298.
**Note**: potential exception at line 298",https://github.com/google/bundletool/blob/1.15.1/src/main/java/com/android/tools/build/bundletool/model/utils/BundleParser.java,"public static ZipFile getModulesZip(ZipFile bundleZip, Path modulesPath) throws IOException {
    ZipEntry modulesEntry = bundleZip.getEntry(SDK_MODULES_FILE_NAME);
    try (InputStream modulesInputStream = bundleZip.getInputStream(modulesEntry)) {
      Files.copy(modulesInputStream, modulesPath);
      return new ZipFile(modulesPath.toFile());
    }
  }
}",1
bundletool-1.15.1,RESOURCE_LEAK,src/main/java/com/android/tools/build/bundletool/commands/ExtractApksCommand.java,"com.android.tools.build.bundletool.commands.ExtractApksCommand.extractMatchedApksFromApksArchive(com.google.common.collect.ImmutableList,com.android.bundle.Commands$BuildApksResult):com.google.common.collect.ImmutableList",300,"resource of type `java.util.zip.ZipFile` acquired by call to `ZipFile(...)` at line 282 is not released after line 300.
**Note**: potential exception at line 292",https://github.com/google/bundletool/blob/1.15.1/src/main/java/com/android/tools/build/bundletool/commands/ExtractApksCommand.java,"private ImmutableList<Path> extractMatchedApksFromApksArchive(
      ImmutableList<GeneratedApk> generatedApks, BuildApksResult toc) {
    Path outputDirectoryPath =
        getOutputDirectory().orElseGet(ExtractApksCommand::createTempDirectory);

    getOutputDirectory()
        .ifPresent(
            dir -> {
              if (!Files.exists(dir)) {
                logger.info(""Output directory '"" + dir + ""' does not exist, creating it."");
                FileUtils.createDirectories(dir);
              }
            });

    ImmutableList.Builder<Path> builder = ImmutableList.builder();
    try (ZipFile apksArchive = new ZipFile(getApksArchivePath().toFile())) {
      for (GeneratedApk matchedApk : generatedApks) {
        ZipEntry entry = apksArchive.getEntry(matchedApk.getPath().toString());
        checkNotNull(entry);
        Path extractedApkPath =
            outputDirectoryPath.resolve(matchedApk.getPath().getFileName().toString());
        try (InputStream inputStream = apksArchive.getInputStream(entry);
            OutputStream outputApk = Files.newOutputStream(extractedApkPath)) {
          ByteStreams.copy(inputStream, outputApk);
          builder.add(extractedApkPath);
        } catch (IOException e) {
          throw new UncheckedIOException(
              String.format(""Error while extracting APK '%s' from the APK Set."", matchedApk), e);
        }
      }
      if (getIncludeMetadata()) {
        produceCommandMetadata(generatedApks, toc, outputDirectoryPath);
      }
    } catch (IOException e) {
      throw new UncheckedIOException(
          String.format(""Error while processing the APK Set archive '%s'."", getApksArchivePath()),
          e);
    }
    System.err.printf(
        ""The APKs have been extracted in the directory: %s%n"", outputDirectoryPath.toString());
    return builder.build();
  }",0
bundletool-1.15.1,RESOURCE_LEAK,src/main/java/com/android/tools/build/bundletool/commands/BuildSdkApksForAppCommand.java,com.android.tools.build.bundletool.commands.BuildSdkApksForAppCommand.executeForSdkBundle():void,316,"resource of type `java.util.zip.ZipFile` acquired by call to `ZipFile(...)` at line 317 is not released after line 316.
**Note**: potential exception at line 319",https://github.com/google/bundletool/blob/1.15.1/src/main/java/com/android/tools/build/bundletool/commands/BuildSdkApksForAppCommand.java,"private void executeForSdkBundle() {
    try (TempDirectory tempDir = new TempDirectory(getClass().getSimpleName());
        ZipFile sdkBundleZip = new ZipFile(getSdkBundlePath().get().toFile())) {
      Path modulesPath = tempDir.getPath().resolve(EXTRACTED_SDK_MODULES_FILE_NAME);
      try (ZipFile modulesZip = getModulesZip(sdkBundleZip, modulesPath)) {
        SdkBundleValidator sdkBundleValidator = SdkBundleValidator.create();
        sdkBundleValidator.validateModulesFile(modulesZip);
        // SdkBundle#getVersionCode is not used in `build-apks`. It does not matter what
        // value we set here, so we are just setting 0.
        SdkBundle sdkBundle =
            SdkBundle.buildFromZip(sdkBundleZip, modulesZip, /* versionCode= */ 0);
        sdkBundleValidator.validate(sdkBundle);
        generateAppApks(sdkBundle.getModule(), tempDir);
      }
    } catch (ZipException e) {
      throw CommandExecutionException.builder()
          .withInternalMessage(""ASB is not a valid zip file."")
          .withCause(e)
          .build();
    } catch (IOException e) {
      throw new UncheckedIOException(""An error occurred when processing the SDK bundle."", e);
    }
  }",1
bundletool-1.15.1,RESOURCE_LEAK,src/main/java/com/android/tools/build/bundletool/commands/BuildSdkApksForAppCommand.java,com.android.tools.build.bundletool.commands.BuildSdkApksForAppCommand.executeForSdkBundle():void,316,"resource of type `java.util.zip.ZipFile` acquired by call to `getModulesZip(...)` at line 319 is not released after line 316.
**Note**: potential exception at line 325",https://github.com/google/bundletool/blob/1.15.1/src/main/java/com/android/tools/build/bundletool/commands/BuildSdkApksForAppCommand.java,"private void executeForSdkBundle() {
    try (TempDirectory tempDir = new TempDirectory(getClass().getSimpleName());
        ZipFile sdkBundleZip = new ZipFile(getSdkBundlePath().get().toFile())) {
      Path modulesPath = tempDir.getPath().resolve(EXTRACTED_SDK_MODULES_FILE_NAME);
      try (ZipFile modulesZip = getModulesZip(sdkBundleZip, modulesPath)) {
        SdkBundleValidator sdkBundleValidator = SdkBundleValidator.create();
        sdkBundleValidator.validateModulesFile(modulesZip);
        // SdkBundle#getVersionCode is not used in `build-apks`. It does not matter what
        // value we set here, so we are just setting 0.
        SdkBundle sdkBundle =
            SdkBundle.buildFromZip(sdkBundleZip, modulesZip, /* versionCode= */ 0);
        sdkBundleValidator.validate(sdkBundle);
        generateAppApks(sdkBundle.getModule(), tempDir);
      }
    } catch (ZipException e) {
      throw CommandExecutionException.builder()
          .withInternalMessage(""ASB is not a valid zip file."")
          .withCause(e)
          .build();
    } catch (IOException e) {
      throw new UncheckedIOException(""An error occurred when processing the SDK bundle."", e);
    }
  }",0
bundletool-1.15.1,RESOURCE_LEAK,src/main/java/com/android/tools/build/bundletool/commands/BuildSdkApksForAppCommand.java,com.android.tools.build.bundletool.commands.BuildSdkApksForAppCommand.executeForSdkBundle():void,329,"resource of type `com.android.tools.build.bundletool.io.TempDirectory` acquired by call to `new()` at line 316 is not released after line 329.
**Note**: potential exception at line 317",https://github.com/google/bundletool/blob/1.15.1/src/main/java/com/android/tools/build/bundletool/commands/BuildSdkApksForAppCommand.java,"private void executeForSdkBundle() {
    try (TempDirectory tempDir = new TempDirectory(getClass().getSimpleName());
        ZipFile sdkBundleZip = new ZipFile(getSdkBundlePath().get().toFile())) {
      Path modulesPath = tempDir.getPath().resolve(EXTRACTED_SDK_MODULES_FILE_NAME);
      try (ZipFile modulesZip = getModulesZip(sdkBundleZip, modulesPath)) {
        SdkBundleValidator sdkBundleValidator = SdkBundleValidator.create();
        sdkBundleValidator.validateModulesFile(modulesZip);
        // SdkBundle#getVersionCode is not used in `build-apks`. It does not matter what
        // value we set here, so we are just setting 0.
        SdkBundle sdkBundle =
            SdkBundle.buildFromZip(sdkBundleZip, modulesZip, /* versionCode= */ 0);
        sdkBundleValidator.validate(sdkBundle);
        generateAppApks(sdkBundle.getModule(), tempDir);
      }
    } catch (ZipException e) {
      throw CommandExecutionException.builder()
          .withInternalMessage(""ASB is not a valid zip file."")
          .withCause(e)
          .build();
    } catch (IOException e) {
      throw new UncheckedIOException(""An error occurred when processing the SDK bundle."", e);
    }
  }",0
bundletool-1.15.1,RESOURCE_LEAK,src/main/java/com/android/tools/build/bundletool/commands/BuildSdkApksForAppCommand.java,com.android.tools.build.bundletool.commands.BuildSdkApksForAppCommand.executeForSdkBundle():void,329,"resource of type `java.util.zip.ZipFile` acquired by call to `ZipFile(...)` at line 317 is not released after line 329.
**Note**: potential exception at line 319",https://github.com/google/bundletool/blob/1.15.1/src/main/java/com/android/tools/build/bundletool/commands/BuildSdkApksForAppCommand.java,"private void executeForSdkBundle() {
    try (TempDirectory tempDir = new TempDirectory(getClass().getSimpleName());
        ZipFile sdkBundleZip = new ZipFile(getSdkBundlePath().get().toFile())) {
      Path modulesPath = tempDir.getPath().resolve(EXTRACTED_SDK_MODULES_FILE_NAME);
      try (ZipFile modulesZip = getModulesZip(sdkBundleZip, modulesPath)) {
        SdkBundleValidator sdkBundleValidator = SdkBundleValidator.create();
        sdkBundleValidator.validateModulesFile(modulesZip);
        // SdkBundle#getVersionCode is not used in `build-apks`. It does not matter what
        // value we set here, so we are just setting 0.
        SdkBundle sdkBundle =
            SdkBundle.buildFromZip(sdkBundleZip, modulesZip, /* versionCode= */ 0);
        sdkBundleValidator.validate(sdkBundle);
        generateAppApks(sdkBundle.getModule(), tempDir);
      }
    } catch (ZipException e) {
      throw CommandExecutionException.builder()
          .withInternalMessage(""ASB is not a valid zip file."")
          .withCause(e)
          .build();
    } catch (IOException e) {
      throw new UncheckedIOException(""An error occurred when processing the SDK bundle."", e);
    }
  }",1
bundletool-1.15.1,RESOURCE_LEAK,src/main/java/com/android/tools/build/bundletool/commands/BuildSdkApksForAppCommand.java,com.android.tools.build.bundletool.commands.BuildSdkApksForAppCommand.executeForSdkBundle():void,329,"resource of type `java.util.zip.ZipFile` acquired by call to `getModulesZip(...)` at line 319 is not released after line 329.
**Note**: potential exception at line 325",https://github.com/google/bundletool/blob/1.15.1/src/main/java/com/android/tools/build/bundletool/commands/BuildSdkApksForAppCommand.java,"private void executeForSdkBundle() {
    try (TempDirectory tempDir = new TempDirectory(getClass().getSimpleName());
        ZipFile sdkBundleZip = new ZipFile(getSdkBundlePath().get().toFile())) {
      Path modulesPath = tempDir.getPath().resolve(EXTRACTED_SDK_MODULES_FILE_NAME);
      try (ZipFile modulesZip = getModulesZip(sdkBundleZip, modulesPath)) {
        SdkBundleValidator sdkBundleValidator = SdkBundleValidator.create();
        sdkBundleValidator.validateModulesFile(modulesZip);
        // SdkBundle#getVersionCode is not used in `build-apks`. It does not matter what
        // value we set here, so we are just setting 0.
        SdkBundle sdkBundle =
            SdkBundle.buildFromZip(sdkBundleZip, modulesZip, /* versionCode= */ 0);
        sdkBundleValidator.validate(sdkBundle);
        generateAppApks(sdkBundle.getModule(), tempDir);
      }
    } catch (ZipException e) {
      throw CommandExecutionException.builder()
          .withInternalMessage(""ASB is not a valid zip file."")
          .withCause(e)
          .build();
    } catch (IOException e) {
      throw new UncheckedIOException(""An error occurred when processing the SDK bundle."", e);
    }
  }",0
bundletool-1.15.1,RESOURCE_LEAK,src/main/java/com/android/tools/build/bundletool/commands/BuildSdkApksForAppCommand.java,com.android.tools.build.bundletool.commands.BuildSdkApksForAppCommand.executeForSdkBundle():void,334,"resource of type `com.android.tools.build.bundletool.io.TempDirectory` acquired by call to `new()` at line 316 is not released after line 334.
**Note**: potential exception at line 317",https://github.com/google/bundletool/blob/1.15.1/src/main/java/com/android/tools/build/bundletool/commands/BuildSdkApksForAppCommand.java,"private void executeForSdkBundle() {
    try (TempDirectory tempDir = new TempDirectory(getClass().getSimpleName());
        ZipFile sdkBundleZip = new ZipFile(getSdkBundlePath().get().toFile())) {
      Path modulesPath = tempDir.getPath().resolve(EXTRACTED_SDK_MODULES_FILE_NAME);
      try (ZipFile modulesZip = getModulesZip(sdkBundleZip, modulesPath)) {
        SdkBundleValidator sdkBundleValidator = SdkBundleValidator.create();
        sdkBundleValidator.validateModulesFile(modulesZip);
        // SdkBundle#getVersionCode is not used in `build-apks`. It does not matter what
        // value we set here, so we are just setting 0.
        SdkBundle sdkBundle =
            SdkBundle.buildFromZip(sdkBundleZip, modulesZip, /* versionCode= */ 0);
        sdkBundleValidator.validate(sdkBundle);
        generateAppApks(sdkBundle.getModule(), tempDir);
      }
    } catch (ZipException e) {
      throw CommandExecutionException.builder()
          .withInternalMessage(""ASB is not a valid zip file."")
          .withCause(e)
          .build();
    } catch (IOException e) {
      throw new UncheckedIOException(""An error occurred when processing the SDK bundle."", e);
    }
  }",0
bundletool-1.15.1,RESOURCE_LEAK,src/main/java/com/android/tools/build/bundletool/commands/BuildSdkApksForAppCommand.java,com.android.tools.build.bundletool.commands.BuildSdkApksForAppCommand.executeForSdkBundle():void,334,"resource of type `java.util.zip.ZipFile` acquired by call to `ZipFile(...)` at line 317 is not released after line 334.
**Note**: potential exception at line 319",https://github.com/google/bundletool/blob/1.15.1/src/main/java/com/android/tools/build/bundletool/commands/BuildSdkApksForAppCommand.java,"private void executeForSdkBundle() {
    try (TempDirectory tempDir = new TempDirectory(getClass().getSimpleName());
        ZipFile sdkBundleZip = new ZipFile(getSdkBundlePath().get().toFile())) {
      Path modulesPath = tempDir.getPath().resolve(EXTRACTED_SDK_MODULES_FILE_NAME);
      try (ZipFile modulesZip = getModulesZip(sdkBundleZip, modulesPath)) {
        SdkBundleValidator sdkBundleValidator = SdkBundleValidator.create();
        sdkBundleValidator.validateModulesFile(modulesZip);
        // SdkBundle#getVersionCode is not used in `build-apks`. It does not matter what
        // value we set here, so we are just setting 0.
        SdkBundle sdkBundle =
            SdkBundle.buildFromZip(sdkBundleZip, modulesZip, /* versionCode= */ 0);
        sdkBundleValidator.validate(sdkBundle);
        generateAppApks(sdkBundle.getModule(), tempDir);
      }
    } catch (ZipException e) {
      throw CommandExecutionException.builder()
          .withInternalMessage(""ASB is not a valid zip file."")
          .withCause(e)
          .build();
    } catch (IOException e) {
      throw new UncheckedIOException(""An error occurred when processing the SDK bundle."", e);
    }
  }",1
bundletool-1.15.1,RESOURCE_LEAK,src/main/java/com/android/tools/build/bundletool/commands/BuildSdkApksForAppCommand.java,com.android.tools.build.bundletool.commands.BuildSdkApksForAppCommand.executeForSdkBundle():void,334,"resource of type `java.util.zip.ZipFile` acquired by call to `getModulesZip(...)` at line 319 is not released after line 334.
**Note**: potential exception at line 325",https://github.com/google/bundletool/blob/1.15.1/src/main/java/com/android/tools/build/bundletool/commands/BuildSdkApksForAppCommand.java,"private void executeForSdkBundle() {
    try (TempDirectory tempDir = new TempDirectory(getClass().getSimpleName());
        ZipFile sdkBundleZip = new ZipFile(getSdkBundlePath().get().toFile())) {
      Path modulesPath = tempDir.getPath().resolve(EXTRACTED_SDK_MODULES_FILE_NAME);
      try (ZipFile modulesZip = getModulesZip(sdkBundleZip, modulesPath)) {
        SdkBundleValidator sdkBundleValidator = SdkBundleValidator.create();
        sdkBundleValidator.validateModulesFile(modulesZip);
        // SdkBundle#getVersionCode is not used in `build-apks`. It does not matter what
        // value we set here, so we are just setting 0.
        SdkBundle sdkBundle =
            SdkBundle.buildFromZip(sdkBundleZip, modulesZip, /* versionCode= */ 0);
        sdkBundleValidator.validate(sdkBundle);
        generateAppApks(sdkBundle.getModule(), tempDir);
      }
    } catch (ZipException e) {
      throw CommandExecutionException.builder()
          .withInternalMessage(""ASB is not a valid zip file."")
          .withCause(e)
          .build();
    } catch (IOException e) {
      throw new UncheckedIOException(""An error occurred when processing the SDK bundle."", e);
    }
  }",0
bundletool-1.15.1,RESOURCE_LEAK,src/main/java/com/android/tools/build/bundletool/commands/BuildSdkApksForAppCommand.java,com.android.tools.build.bundletool.commands.BuildSdkApksForAppCommand.executeForSdkArchive():void,340,"resource of type `java.util.zip.ZipFile` acquired by call to `ZipFile(...)` at line 341 is not released after line 340.
**Note**: potential exception at line 343",https://github.com/google/bundletool/blob/1.15.1/src/main/java/com/android/tools/build/bundletool/commands/BuildSdkApksForAppCommand.java,"private void executeForSdkArchive() {
    try (TempDirectory tempDir = new TempDirectory(getClass().getSimpleName());
        ZipFile asarZip = new ZipFile(getSdkArchivePath().get().toFile())) {
      Path modulesPath = tempDir.getPath().resolve(EXTRACTED_SDK_MODULES_FILE_NAME);
      try (ZipFile modulesZip = getModulesZip(asarZip, modulesPath)) {
        SdkAsarValidator.validateModulesFile(modulesZip);
        SdkAsar sdkAsar = SdkAsar.buildFromZip(asarZip, modulesZip, modulesPath);
        generateAppApks(sdkAsar.getModule(), tempDir);
      }
    } catch (ZipException e) {
      throw CommandExecutionException.builder()
          .withInternalMessage(""ASAR is not a valid zip file."")
          .withCause(e)
          .build();
    } catch (IOException e) {
      throw new UncheckedIOException(""An error occurred when processing the SDK archive."", e);
    }
  }",1
bundletool-1.15.1,RESOURCE_LEAK,src/main/java/com/android/tools/build/bundletool/commands/BuildSdkApksForAppCommand.java,com.android.tools.build.bundletool.commands.BuildSdkApksForAppCommand.executeForSdkArchive():void,340,"resource of type `java.util.zip.ZipFile` acquired by call to `getModulesZip(...)` at line 343 is not released after line 340.
**Note**: potential exception at line 345",https://github.com/google/bundletool/blob/1.15.1/src/main/java/com/android/tools/build/bundletool/commands/BuildSdkApksForAppCommand.java,"private void executeForSdkArchive() {
    try (TempDirectory tempDir = new TempDirectory(getClass().getSimpleName());
        ZipFile asarZip = new ZipFile(getSdkArchivePath().get().toFile())) {
      Path modulesPath = tempDir.getPath().resolve(EXTRACTED_SDK_MODULES_FILE_NAME);
      try (ZipFile modulesZip = getModulesZip(asarZip, modulesPath)) {
        SdkAsarValidator.validateModulesFile(modulesZip);
        SdkAsar sdkAsar = SdkAsar.buildFromZip(asarZip, modulesZip, modulesPath);
        generateAppApks(sdkAsar.getModule(), tempDir);
      }
    } catch (ZipException e) {
      throw CommandExecutionException.builder()
          .withInternalMessage(""ASAR is not a valid zip file."")
          .withCause(e)
          .build();
    } catch (IOException e) {
      throw new UncheckedIOException(""An error occurred when processing the SDK archive."", e);
    }
  }",0
bundletool-1.15.1,RESOURCE_LEAK,src/main/java/com/android/tools/build/bundletool/commands/BuildSdkApksForAppCommand.java,com.android.tools.build.bundletool.commands.BuildSdkApksForAppCommand.executeForSdkArchive():void,348,"resource of type `com.android.tools.build.bundletool.io.TempDirectory` acquired by call to `new()` at line 340 is not released after line 348.
**Note**: potential exception at line 341",https://github.com/google/bundletool/blob/1.15.1/src/main/java/com/android/tools/build/bundletool/commands/BuildSdkApksForAppCommand.java,"private void executeForSdkArchive() {
    try (TempDirectory tempDir = new TempDirectory(getClass().getSimpleName());
        ZipFile asarZip = new ZipFile(getSdkArchivePath().get().toFile())) {
      Path modulesPath = tempDir.getPath().resolve(EXTRACTED_SDK_MODULES_FILE_NAME);
      try (ZipFile modulesZip = getModulesZip(asarZip, modulesPath)) {
        SdkAsarValidator.validateModulesFile(modulesZip);
        SdkAsar sdkAsar = SdkAsar.buildFromZip(asarZip, modulesZip, modulesPath);
        generateAppApks(sdkAsar.getModule(), tempDir);
      }
    } catch (ZipException e) {
      throw CommandExecutionException.builder()
          .withInternalMessage(""ASAR is not a valid zip file."")
          .withCause(e)
          .build();
    } catch (IOException e) {
      throw new UncheckedIOException(""An error occurred when processing the SDK archive."", e);
    }
  }",0
bundletool-1.15.1,RESOURCE_LEAK,src/main/java/com/android/tools/build/bundletool/commands/BuildSdkApksForAppCommand.java,com.android.tools.build.bundletool.commands.BuildSdkApksForAppCommand.executeForSdkArchive():void,348,"resource of type `java.util.zip.ZipFile` acquired by call to `ZipFile(...)` at line 341 is not released after line 348.
**Note**: potential exception at line 343",https://github.com/google/bundletool/blob/1.15.1/src/main/java/com/android/tools/build/bundletool/commands/BuildSdkApksForAppCommand.java,"private void executeForSdkArchive() {
    try (TempDirectory tempDir = new TempDirectory(getClass().getSimpleName());
        ZipFile asarZip = new ZipFile(getSdkArchivePath().get().toFile())) {
      Path modulesPath = tempDir.getPath().resolve(EXTRACTED_SDK_MODULES_FILE_NAME);
      try (ZipFile modulesZip = getModulesZip(asarZip, modulesPath)) {
        SdkAsarValidator.validateModulesFile(modulesZip);
        SdkAsar sdkAsar = SdkAsar.buildFromZip(asarZip, modulesZip, modulesPath);
        generateAppApks(sdkAsar.getModule(), tempDir);
      }
    } catch (ZipException e) {
      throw CommandExecutionException.builder()
          .withInternalMessage(""ASAR is not a valid zip file."")
          .withCause(e)
          .build();
    } catch (IOException e) {
      throw new UncheckedIOException(""An error occurred when processing the SDK archive."", e);
    }
  }",1
bundletool-1.15.1,RESOURCE_LEAK,src/main/java/com/android/tools/build/bundletool/commands/BuildSdkApksForAppCommand.java,com.android.tools.build.bundletool.commands.BuildSdkApksForAppCommand.executeForSdkArchive():void,348,"resource of type `java.util.zip.ZipFile` acquired by call to `getModulesZip(...)` at line 343 is not released after line 348.
**Note**: potential exception at line 345",https://github.com/google/bundletool/blob/1.15.1/src/main/java/com/android/tools/build/bundletool/commands/BuildSdkApksForAppCommand.java,"private void executeForSdkArchive() {
    try (TempDirectory tempDir = new TempDirectory(getClass().getSimpleName());
        ZipFile asarZip = new ZipFile(getSdkArchivePath().get().toFile())) {
      Path modulesPath = tempDir.getPath().resolve(EXTRACTED_SDK_MODULES_FILE_NAME);
      try (ZipFile modulesZip = getModulesZip(asarZip, modulesPath)) {
        SdkAsarValidator.validateModulesFile(modulesZip);
        SdkAsar sdkAsar = SdkAsar.buildFromZip(asarZip, modulesZip, modulesPath);
        generateAppApks(sdkAsar.getModule(), tempDir);
      }
    } catch (ZipException e) {
      throw CommandExecutionException.builder()
          .withInternalMessage(""ASAR is not a valid zip file."")
          .withCause(e)
          .build();
    } catch (IOException e) {
      throw new UncheckedIOException(""An error occurred when processing the SDK archive."", e);
    }
  }",0
bundletool-1.15.1,RESOURCE_LEAK,src/main/java/com/android/tools/build/bundletool/commands/BuildSdkApksForAppCommand.java,com.android.tools.build.bundletool.commands.BuildSdkApksForAppCommand.executeForSdkArchive():void,353,"resource of type `com.android.tools.build.bundletool.io.TempDirectory` acquired by call to `new()` at line 340 is not released after line 353.
**Note**: potential exception at line 341",https://github.com/google/bundletool/blob/1.15.1/src/main/java/com/android/tools/build/bundletool/commands/BuildSdkApksForAppCommand.java,"private void executeForSdkArchive() {
    try (TempDirectory tempDir = new TempDirectory(getClass().getSimpleName());
        ZipFile asarZip = new ZipFile(getSdkArchivePath().get().toFile())) {
      Path modulesPath = tempDir.getPath().resolve(EXTRACTED_SDK_MODULES_FILE_NAME);
      try (ZipFile modulesZip = getModulesZip(asarZip, modulesPath)) {
        SdkAsarValidator.validateModulesFile(modulesZip);
        SdkAsar sdkAsar = SdkAsar.buildFromZip(asarZip, modulesZip, modulesPath);
        generateAppApks(sdkAsar.getModule(), tempDir);
      }
    } catch (ZipException e) {
      throw CommandExecutionException.builder()
          .withInternalMessage(""ASAR is not a valid zip file."")
          .withCause(e)
          .build();
    } catch (IOException e) {
      throw new UncheckedIOException(""An error occurred when processing the SDK archive."", e);
    }
  }",0
bundletool-1.15.1,RESOURCE_LEAK,src/main/java/com/android/tools/build/bundletool/commands/BuildSdkApksForAppCommand.java,com.android.tools.build.bundletool.commands.BuildSdkApksForAppCommand.executeForSdkArchive():void,353,"resource of type `java.util.zip.ZipFile` acquired by call to `ZipFile(...)` at line 341 is not released after line 353.
**Note**: potential exception at line 343",https://github.com/google/bundletool/blob/1.15.1/src/main/java/com/android/tools/build/bundletool/commands/BuildSdkApksForAppCommand.java,"private void executeForSdkArchive() {
    try (TempDirectory tempDir = new TempDirectory(getClass().getSimpleName());
        ZipFile asarZip = new ZipFile(getSdkArchivePath().get().toFile())) {
      Path modulesPath = tempDir.getPath().resolve(EXTRACTED_SDK_MODULES_FILE_NAME);
      try (ZipFile modulesZip = getModulesZip(asarZip, modulesPath)) {
        SdkAsarValidator.validateModulesFile(modulesZip);
        SdkAsar sdkAsar = SdkAsar.buildFromZip(asarZip, modulesZip, modulesPath);
        generateAppApks(sdkAsar.getModule(), tempDir);
      }
    } catch (ZipException e) {
      throw CommandExecutionException.builder()
          .withInternalMessage(""ASAR is not a valid zip file."")
          .withCause(e)
          .build();
    } catch (IOException e) {
      throw new UncheckedIOException(""An error occurred when processing the SDK archive."", e);
    }
  }",1
bundletool-1.15.1,RESOURCE_LEAK,src/main/java/com/android/tools/build/bundletool/commands/BuildSdkApksForAppCommand.java,com.android.tools.build.bundletool.commands.BuildSdkApksForAppCommand.executeForSdkArchive():void,353,"resource of type `java.util.zip.ZipFile` acquired by call to `getModulesZip(...)` at line 343 is not released after line 353.
**Note**: potential exception at line 345",https://github.com/google/bundletool/blob/1.15.1/src/main/java/com/android/tools/build/bundletool/commands/BuildSdkApksForAppCommand.java,"private void executeForSdkArchive() {
    try (TempDirectory tempDir = new TempDirectory(getClass().getSimpleName());
        ZipFile asarZip = new ZipFile(getSdkArchivePath().get().toFile())) {
      Path modulesPath = tempDir.getPath().resolve(EXTRACTED_SDK_MODULES_FILE_NAME);
      try (ZipFile modulesZip = getModulesZip(asarZip, modulesPath)) {
        SdkAsarValidator.validateModulesFile(modulesZip);
        SdkAsar sdkAsar = SdkAsar.buildFromZip(asarZip, modulesZip, modulesPath);
        generateAppApks(sdkAsar.getModule(), tempDir);
      }
    } catch (ZipException e) {
      throw CommandExecutionException.builder()
          .withInternalMessage(""ASAR is not a valid zip file."")
          .withCause(e)
          .build();
    } catch (IOException e) {
      throw new UncheckedIOException(""An error occurred when processing the SDK archive."", e);
    }
  }",0
bundletool-1.15.1,RESOURCE_LEAK,src/main/java/com/android/tools/build/bundletool/commands/InstallMultiApksCommand.java,"com.android.tools.build.bundletool.commands.InstallMultiApksCommand.apksWithPackageName(java.nio.file.Path,com.android.bundle.Devices$DeviceSpec,java.util.function.Supplier):java.util.Optional",366,"resource of type `com.android.tools.build.bundletool.io.TempDirectory` acquired by call to `TempDirectory()` at line 350 is not released after line 366.
**Note**: potential exception at line 357",https://github.com/google/bundletool/blob/1.15.1/src/main/java/com/android/tools/build/bundletool/commands/InstallMultiApksCommand.java,"private static Optional<PackagePathVersion> apksWithPackageName(
      Path apksArchivePath, DeviceSpec deviceSpec, Supplier<Aapt2Command> aapt2CommandSupplier) {
    try (TempDirectory tempDirectory = new TempDirectory()) {
      // Any of the extracted .apk/.apex files will work.
      Path extractedFile =
          ExtractApksCommand.builder()
              .setApksArchivePath(apksArchivePath)
              .setDeviceSpec(deviceSpec)
              .setOutputDirectory(tempDirectory.getPath())
              .build()
              .execute()
              .get(0);

      BadgingInfo badgingInfo =
          BadgingInfoParser.parse(aapt2CommandSupplier.get().dumpBadging(extractedFile));
      return Optional.of(
          PackagePathVersion.create(
              apksArchivePath, badgingInfo.getPackageName(), badgingInfo.getVersionCode()));
    } catch (IncompatibleDeviceException e) {
      logger.warning(
          String.format(
              ""Unable to determine package name of %s, as it is not compatible with the attached""
                  + "" device. Skipping."",
              apksArchivePath));
      return Optional.empty();
    }
  }",0
bundletool-1.15.1,RESOURCE_LEAK,src/main/java/com/android/tools/build/bundletool/commands/InstallMultiApksCommand.java,"com.android.tools.build.bundletool.commands.InstallMultiApksCommand.extractApksFromZip(java.nio.file.Path,com.android.tools.build.bundletool.io.TempDirectory):com.google.common.collect.ImmutableList",463,"resource of type `java.util.zip.ZipFile` acquired to `apksArchiveContainer` by call to `ZipFile(...)` at line 463 is not released after line 463.
**Note**: potential exception at line 485",https://github.com/google/bundletool/blob/1.15.1/src/main/java/com/android/tools/build/bundletool/commands/InstallMultiApksCommand.java,"private static ImmutableList<Path> extractApksFromZip(Path zipPath, TempDirectory tempDirectory)
      throws IOException {
    ImmutableList.Builder<Path> extractedApks = ImmutableList.builder();
    Path zipExtractedSubDirectory = tempDirectory.getPath().resolve(""extracted"");
    Files.createDirectory(zipExtractedSubDirectory);
    try (ZipFile apksArchiveContainer = new ZipFile(zipPath.toFile())) {
      ImmutableList<ZipEntry> apksToExtractList =
          apksArchiveContainer.stream()
              .filter(
                  zipEntry ->
                      !zipEntry.isDirectory()
                          && zipEntry.getName().toLowerCase(Locale.ROOT).endsWith("".apks"")
                          // Compressed .apks cannot be installed via bundletool, only included in
                          // System Images.
                          && !zipEntry
                              .getName()
                              .toLowerCase(Locale.ROOT)
                              .endsWith(""compressed.apks""))
              .collect(toImmutableList());
      for (ZipEntry apksToExtract : apksToExtractList) {
        Path extractedApksPath =
            zipExtractedSubDirectory.resolve(ZipPath.create(apksToExtract.getName()).toString());
        Files.createDirectories(extractedApksPath.getParent());
        try (InputStream inputStream = apksArchiveContainer.getInputStream(apksToExtract);
            OutputStream outputApks = Files.newOutputStream(extractedApksPath)) {
          ByteStreams.copy(inputStream, outputApks);
          extractedApks.add(extractedApksPath);
        }
      }
    }
    return extractedApks.build();
  }",0
bundletool-1.15.1,RESOURCE_LEAK,src/main/java/com/android/tools/build/bundletool/commands/BuildApksCommand.java,com.android.tools.build.bundletool.commands.BuildApksCommand.execute():java.nio.file.Path,924,"resource of type `com.android.tools.build.bundletool.io.TempDirectory` acquired by call to `new()` at line 897 is not released after line 924.
**Note**: potential exception at line 898",https://github.com/google/bundletool/blob/1.15.1/src/main/java/com/android/tools/build/bundletool/commands/BuildApksCommand.java,"public Path execute() {
    validateInput();

    Path outputDirectory =
        getOutputFormat().equals(APK_SET) ? getOutputFile().getParent() : getOutputFile();
    if (outputDirectory != null && Files.notExists(outputDirectory)) {
      logger.info(""Output directory '"" + outputDirectory + ""' does not exist, creating it."");
      FileUtils.createDirectories(outputDirectory);
    }

    try (TempDirectory tempDir = new TempDirectory(getClass().getSimpleName());
        ZipFile bundleZip = new ZipFile(getBundlePath().toFile());
        Closer closer = Closer.create()) {
      AppBundleValidator bundleValidator = AppBundleValidator.create(getExtraValidators());
      bundleValidator.validateFile(bundleZip);

      AppBundle appBundle = AppBundle.buildFromZip(bundleZip);
      bundleValidator.validate(appBundle);
      ImmutableMap<String, BundleModule> sdkBundleModules =
          getValidatedSdkModules(closer, tempDir, appBundle);

      AppBundlePreprocessorManager appBundlePreprocessorManager =
          DaggerAppBundlePreprocessorComponent.builder()
              .setBuildApksCommand(this)
              .setSdkBundleModules(sdkBundleModules)
              .build()
              .create();
      AppBundle preprocessedAppBundle = appBundlePreprocessorManager.processAppBundle(appBundle);

      BuildApksManager buildApksManager =
          DaggerBuildApksManagerComponent.builder()
              .setBuildApksCommand(this)
              .setTempDirectory(tempDir)
              .setAppBundle(preprocessedAppBundle)
              .build()
              .create();
      buildApksManager.execute();
    } catch (ZipException e) {
      throw InvalidBundleException.builder()
          .withCause(e)
          .withUserMessage(""The App Bundle is not a valid zip file."")
          .build();

    } catch (IOException e) {
      throw new UncheckedIOException(""An error occurred when processing the App Bundle."", e);
    } finally {
      if (isExecutorServiceCreatedByBundleTool()) {
        getExecutorService().shutdown();
      }
    }

    return getOutputFile();
  }",0
bundletool-1.15.1,RESOURCE_LEAK,src/main/java/com/android/tools/build/bundletool/commands/BuildApksCommand.java,com.android.tools.build.bundletool.commands.BuildApksCommand.execute():java.nio.file.Path,930,"resource of type `com.android.tools.build.bundletool.io.TempDirectory` acquired by call to `new()` at line 897 is not released after line 930.
**Note**: potential exception at line 898",https://github.com/google/bundletool/blob/1.15.1/src/main/java/com/android/tools/build/bundletool/commands/BuildApksCommand.java,"public Path execute() {
    validateInput();

    Path outputDirectory =
        getOutputFormat().equals(APK_SET) ? getOutputFile().getParent() : getOutputFile();
    if (outputDirectory != null && Files.notExists(outputDirectory)) {
      logger.info(""Output directory '"" + outputDirectory + ""' does not exist, creating it."");
      FileUtils.createDirectories(outputDirectory);
    }

    try (TempDirectory tempDir = new TempDirectory(getClass().getSimpleName());
        ZipFile bundleZip = new ZipFile(getBundlePath().toFile());
        Closer closer = Closer.create()) {
      AppBundleValidator bundleValidator = AppBundleValidator.create(getExtraValidators());
      bundleValidator.validateFile(bundleZip);

      AppBundle appBundle = AppBundle.buildFromZip(bundleZip);
      bundleValidator.validate(appBundle);
      ImmutableMap<String, BundleModule> sdkBundleModules =
          getValidatedSdkModules(closer, tempDir, appBundle);

      AppBundlePreprocessorManager appBundlePreprocessorManager =
          DaggerAppBundlePreprocessorComponent.builder()
              .setBuildApksCommand(this)
              .setSdkBundleModules(sdkBundleModules)
              .build()
              .create();
      AppBundle preprocessedAppBundle = appBundlePreprocessorManager.processAppBundle(appBundle);

      BuildApksManager buildApksManager =
          DaggerBuildApksManagerComponent.builder()
              .setBuildApksCommand(this)
              .setTempDirectory(tempDir)
              .setAppBundle(preprocessedAppBundle)
              .build()
              .create();
      buildApksManager.execute();
    } catch (ZipException e) {
      throw InvalidBundleException.builder()
          .withCause(e)
          .withUserMessage(""The App Bundle is not a valid zip file."")
          .build();

    } catch (IOException e) {
      throw new UncheckedIOException(""An error occurred when processing the App Bundle."", e);
    } finally {
      if (isExecutorServiceCreatedByBundleTool()) {
        getExecutorService().shutdown();
      }
    }

    return getOutputFile();
  }",0
bundletool-1.15.1,RESOURCE_LEAK,src/main/java/com/android/tools/build/bundletool/commands/BuildApksCommand.java,com.android.tools.build.bundletool.commands.BuildApksCommand.getLineageFromInputFile(java.io.File):com.android.apksig.SigningCertificateLineage,1765,"resource of type `java.io.RandomAccessFile` acquired by call to `RandomAccessFile(...)` at line 1748 is not released after line 1765.
**Note**: potential exception at line 1749",https://github.com/google/bundletool/blob/1.15.1/src/main/java/com/android/tools/build/bundletool/commands/BuildApksCommand.java,"private static SigningCertificateLineage getLineageFromInputFile(File inputLineageFile) {
    try (RandomAccessFile f = new RandomAccessFile(inputLineageFile, ""r"")) {
      if (f.length() < 4) {
        throw CommandExecutionException.builder()
            .withInternalMessage(""The input file is not a valid lineage file."")
            .build();
      }
      DataSource apk = DataSources.asDataSource(f);
      int magicValue = apk.getByteBuffer(0, 4).order(ByteOrder.LITTLE_ENDIAN).getInt();
      if (magicValue == SigningCertificateLineage.MAGIC) {
        return SigningCertificateLineage.readFromFile(inputLineageFile);
      } else if (magicValue == ZIP_MAGIC) {
        return SigningCertificateLineage.readFromApkFile(inputLineageFile);
      } else {
        throw CommandExecutionException.builder()
            .withInternalMessage(""The input file is not a valid lineage file."")
            .build();
      }
    } catch (IOException | ApkFormatException | IllegalArgumentException e) {
      throw CommandExecutionException.builder().withCause(e).build();
    }
  }",0
dolphinscheduler-2.0.9,RESOURCE_LEAK,dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/monitor/AbstractMonitor.java,"org.apache.dolphinscheduler.server.monitor.AbstractMonitor.restartServer(java.lang.String,java.lang.Integer,java.lang.String):void",77,resource of type `java.lang.Process` acquired by call to `exec(...)` at line 77 is not released after line 77.,https://github.com/apache/dolphinscheduler/blob/2.0.9-release/dolphinscheduler-server/src/main/java/org/apache/dolphinscheduler/server/monitor/AbstractMonitor.java,"private void restartServer(String path,Integer port,String installPath) throws Exception{

        String type = path.split(""/"")[2];
        String serverName = null;
        String nodes = null;
        if (""masters"".equals(type)){
            serverName = ""master-server"";
            nodes = runConfig.getMasters();
        }else if (""workers"".equals(type)){
            serverName = ""worker-server"";
            nodes = runConfig.getWorkers();
        }

        Map<String, String> activeNodeMap = getActiveNodesByPath(path);

        Set<String> needRestartServer = getNeedRestartServer(getRunConfigServer(nodes),
                activeNodeMap.keySet());

        for (String node : needRestartServer){
            // os.system('ssh -p ' + ssh_port + ' ' + self.get_ip_by_hostname(master) + ' sh ' + install_path + '/bin/dolphinscheduler-daemon.sh start master-server')
            String runCmd = ""ssh -p "" + port + "" "" +  node + "" sh ""  + installPath + ""/bin/dolphinscheduler-daemon.sh start "" + serverName;
            Runtime.getRuntime().exec(runCmd);
        }
    }
",1
dolphinscheduler-2.0.9,RESOURCE_LEAK,dolphinscheduler-dao/src/main/java/org/apache/dolphinscheduler/dao/upgrade/UpgradeDao.java,org.apache.dolphinscheduler.dao.upgrade.UpgradeDao.runInitSql(org.apache.dolphinscheduler.spi.enums.DbType):void,101,resource of type `java.io.InputStreamReader` acquired by call to `new()` at line 100 is not released after line 101.,https://github.com/apache/dolphinscheduler/blob/2.0.9-release/dolphinscheduler-dao/src/main/java/org/apache/dolphinscheduler/dao/upgrade/UpgradeDao.java,"private void runInitSql(DbType dbType) {
        String sqlFile = String.format(""dolphinscheduler_%s.sql"",dbType.getDescp());
        Resource mysqlSQLFilePath = new ClassPathResource(""sql/"" + sqlFile);
        try (Connection conn = dataSource.getConnection()) {
            // Execute the dolphinscheduler_ddl.sql script to create the table structure of dolphinscheduler
            ScriptRunner initScriptRunner = new ScriptRunner(conn, true, true);
            Reader initSqlReader = new InputStreamReader(mysqlSQLFilePath.getInputStream());
            initScriptRunner.runScript(initSqlReader);
        } catch (Exception e) {
            logger.error(e.getMessage(), e);
            throw new RuntimeException(e.getMessage(), e);
        }
    }",1
dolphinscheduler-2.0.9,RESOURCE_LEAK,dolphinscheduler-task-plugin/dolphinscheduler-task-api/src/main/java/org/apache/dolphinscheduler/plugin/task/api/AbstractCommandExecutor.java,org.apache.dolphinscheduler.plugin.task.api.AbstractCommandExecutor.softKill(int):boolean,258,resource of type `java.lang.Process` acquired by call to `exec(...)` at line 258 is not released after line 258.,"249: private boolean softKill(int processId) {
 250: 
 251: if (processId != 0 && process.isAlive()) {
 252: try {
 253: // sudo -u user command to run command
 254: String cmd = String.format(""kill %d"", processId);
 255: cmd = OSUtils.getSudoCmd(taskRequest.getTenantCode(), cmd);
 256: logger.info(""soft kill task:{}, process id:{}, cmd:{}"", taskRequest.getTaskAppId(), processId, cmd);
 257: 
 258: Runtime.getRuntime().exec(cmd);
 259: } catch (IOException e) {
 260: logger.info(""kill attempt failed"", e);
 261: }
 262: }
 263: 
 264: return process.isAlive();","private boolean softKill(int processId) {

        if (processId != 0 && process.isAlive()) {
            try {
                // sudo -u user command to run command
                String cmd = String.format(""kill %d"", processId);
                cmd = OSUtils.getSudoCmd(taskRequest.getTenantCode(), cmd);
                logger.info(""soft kill task:{}, process id:{}, cmd:{}"", taskRequest.getTaskAppId(), processId, cmd);

                Runtime.getRuntime().exec(cmd);
            } catch (IOException e) {
                logger.info(""kill attempt failed"", e);
            }
        }

        return process.isAlive();
    }",1
dolphinscheduler-2.0.9,RESOURCE_LEAK,dolphinscheduler-common/src/main/java/org/apache/dolphinscheduler/common/utils/HadoopUtils.java,"org.apache.dolphinscheduler.common.utils.HadoopUtils.catFile(java.lang.String,int,int):java.util.List",264,resource of type `java.io.InputStreamReader` acquired by call to `new()` at line 263 is not released after line 264.,https://github.com/apache/dolphinscheduler/blob/2.0.9-release/dolphinscheduler-common/src/main/java/org/apache/dolphinscheduler/common/utils/HadoopUtils.java,"public List<String> catFile(String hdfsFilePath, int skipLineNums, int limit) throws IOException {

        if (StringUtils.isBlank(hdfsFilePath)) {
            logger.error(""hdfs file path:{} is blank"", hdfsFilePath);
            return Collections.emptyList();
        }

        try (FSDataInputStream in = fs.open(new Path(hdfsFilePath))) {
            BufferedReader br = new BufferedReader(new InputStreamReader(in, StandardCharsets.UTF_8));
            Stream<String> stream = br.lines().skip(skipLineNums).limit(limit);
            return stream.collect(Collectors.toList());
        }

    }",1
dolphinscheduler-2.0.9,RESOURCE_LEAK,dolphinscheduler-task-plugin/dolphinscheduler-task-api/src/main/java/org/apache/dolphinscheduler/plugin/task/api/AbstractCommandExecutor.java,org.apache.dolphinscheduler.plugin.task.api.AbstractCommandExecutor.hardKill(int):void,279,resource of type `java.lang.Process` acquired by call to `exec(...)` at line 279 is not released after line 279.,https://github.com/apache/dolphinscheduler/blob/2.0.9-release/dolphinscheduler-task-plugin/dolphinscheduler-task-api/src/main/java/org/apache/dolphinscheduler/plugin/task/api/AbstractCommandExecutor.java,"private void hardKill(int processId) {
        if (processId != 0 && process.isAlive()) {
            try {
                String cmd = String.format(""kill -9 %d"", processId);
                cmd = OSUtils.getSudoCmd(taskRequest.getTenantCode(), cmd);
                logger.info(""hard kill task:{}, process id:{}, cmd:{}"", taskRequest.getTaskAppId(), processId, cmd);

                Runtime.getRuntime().exec(cmd);
            } catch (IOException e) {
                logger.error(""kill attempt failed "", e);
            }
        }
    }",1
dolphinscheduler-2.0.9,RESOURCE_LEAK,dolphinscheduler-dao/src/main/java/org/apache/dolphinscheduler/dao/upgrade/UpgradeDao.java,org.apache.dolphinscheduler.dao.upgrade.UpgradeDao.upgradeDolphinSchedulerDML(java.lang.String):void,297,resource of type `java.io.InputStreamReader` acquired by call to `new()` at line 296 is not released after line 297.,https://github.com/apache/dolphinscheduler/blob/2.0.9-release/dolphinscheduler-dao/src/main/java/org/apache/dolphinscheduler/dao/upgrade/UpgradeDao.java,"private void upgradeDolphinSchedulerDML(String schemaDir) {
        String schemaVersion = schemaDir.split(""_"")[0];
        Resource sqlFilePath = new ClassPathResource(String.format(""sql/upgrade/%s/%s/dolphinscheduler_dml.sql"", schemaDir, getDbType().name().toLowerCase()));
        if (!sqlFilePath.exists()) {
            logger.info(""No dml file {}, returning"", sqlFilePath);
            return;
        }
        logger.info(""sqlSQLFilePath"" + sqlFilePath);
        Connection conn = null;
        PreparedStatement pstmt = null;
        try {
            conn = dataSource.getConnection();
            conn.setAutoCommit(false);
            // Execute the upgraded dolphinscheduler dml
            ScriptRunner scriptRunner = new ScriptRunner(conn, false, true);
            Reader sqlReader = new InputStreamReader(sqlFilePath.getInputStream());
            scriptRunner.runScript(sqlReader);
            if (isExistsTable(T_VERSION_NAME)) {
                // Change version in the version table to the new version
                String upgradeSQL = String.format(""update %s set version = ?"", T_VERSION_NAME);
                pstmt = conn.prepareStatement(upgradeSQL);
                pstmt.setString(1, schemaVersion);
                pstmt.executeUpdate();
            } else if (isExistsTable(T_NEW_VERSION_NAME)) {
                // Change version in the version table to the new version
                String upgradeSQL = String.format(""update %s set version = ?"", T_NEW_VERSION_NAME);
                pstmt = conn.prepareStatement(upgradeSQL);
                pstmt.setString(1, schemaVersion);
                pstmt.executeUpdate();
            }
            conn.commit();
        } catch (FileNotFoundException e) {
            try {
                conn.rollback();
            } catch (SQLException e1) {
                logger.error(e1.getMessage(), e1);
            }
            logger.error(e.getMessage(), e);
            throw new RuntimeException(""sql file not found "", e);
        } catch (IOException e) {
            try {
                conn.rollback();
            } catch (SQLException e1) {
                logger.error(e1.getMessage(), e1);
            }
            logger.error(e.getMessage(), e);
            throw new RuntimeException(e.getMessage(), e);
        } catch (Exception e) {
            try {
                if (null != conn) {
                    conn.rollback();
                }
            } catch (SQLException e1) {
                logger.error(e1.getMessage(), e1);
            }
            logger.error(e.getMessage(), e);
            throw new RuntimeException(e.getMessage(), e);
        } finally {
            ConnectionUtils.releaseResource(pstmt, conn);
        }

    }",0
dolphinscheduler-2.0.9,RESOURCE_LEAK,dolphinscheduler-dao/src/main/java/org/apache/dolphinscheduler/dao/upgrade/UpgradeDao.java,"org.apache.dolphinscheduler.dao.upgrade.UpgradeDao.upgradeDolphinSchedulerDDL(java.lang.String,java.lang.String):void",361,resource of type `java.io.InputStreamReader` acquired by call to `new()` at line 360 is not released after line 361.,https://github.com/apache/dolphinscheduler/blob/2.0.9-release/dolphinscheduler-dao/src/main/java/org/apache/dolphinscheduler/dao/upgrade/UpgradeDao.java,"private void upgradeDolphinSchedulerDDL(String schemaDir, String scriptFile) {
        Resource sqlFilePath = new ClassPathResource(String.format(""sql/upgrade/%s/%s/%s"", schemaDir, getDbType().name().toLowerCase(), scriptFile));
        Connection conn = null;
        PreparedStatement pstmt = null;
        try {
            conn = dataSource.getConnection();
            String dbName = conn.getCatalog();
            logger.info(dbName);
            conn.setAutoCommit(true);
            // Execute the dolphinscheduler ddl.sql for the upgrade
            ScriptRunner scriptRunner = new ScriptRunner(conn, true, true);
            Reader sqlReader = new InputStreamReader(sqlFilePath.getInputStream());
            scriptRunner.runScript(sqlReader);

        } catch (FileNotFoundException e) {

            logger.error(e.getMessage(), e);
            throw new RuntimeException(""sql file not found "", e);
        } catch (Exception e) {
            logger.error(e.getMessage(), e);
            throw new RuntimeException(e.getMessage(), e);
        } finally {
            ConnectionUtils.releaseResource(pstmt, conn);
        }
    }",0
dolphinscheduler-2.0.9,RESOURCE_LEAK,dolphinscheduler-api/src/main/java/org/apache/dolphinscheduler/api/service/impl/ProcessInstanceServiceImpl.java,org.apache.dolphinscheduler.api.service.impl.ProcessInstanceServiceImpl.parseLogForDependentResult(java.lang.String):java.util.Map,394,"resource of type `java.io.InputStreamReader` acquired by call to `new()` at line 375 is not released after line 394.
**Note**: potential exception at line 378","369: public Map<String, DependResult> parseLogForDependentResult(String log) throws IOException {
 370: Map<String, DependResult> resultMap = new HashMap<>();
 371: if (StringUtils.isEmpty(log)) {
 372: return resultMap;
 373: }
 374: 
 375: BufferedReader br = new BufferedReader(new InputStreamReader(new ByteArrayInputStream(log.getBytes(
 376: StandardCharsets.UTF_8)), StandardCharsets.UTF_8));
 377: String line;
 378: while ((line = br.readLine()) != null) {
 379: if (line.contains(DEPENDENT_SPLIT)) {
 380: String[] tmpStringArray = line.split("":\\|\\|"");
 381: if (tmpStringArray.length != 2) {
 382: continue;
 383: }
 384: String dependResultString = tmpStringArray[1];
 385: String[] dependStringArray = dependResultString.split("","");
 386: if (dependStringArray.length != 2) {
 387: continue;
 388: }
 389: String key = dependStringArray[0].trim();
 390: DependResult dependResult = DependResult.valueOf(dependStringArray[1].trim());
 391: resultMap.put(key, dependResult);
 392: }
 393: }
 394: return resultMap;","public Map<String, DependResult> parseLogForDependentResult(String log) throws IOException {
        Map<String, DependResult> resultMap = new HashMap<>();
        if (StringUtils.isEmpty(log)) {
            return resultMap;
        }

        BufferedReader br = new BufferedReader(new InputStreamReader(new ByteArrayInputStream(log.getBytes(
                StandardCharsets.UTF_8)), StandardCharsets.UTF_8));
        String line;
        while ((line = br.readLine()) != null) {
            if (line.contains(DEPENDENT_SPLIT)) {
                String[] tmpStringArray = line.split("":\\|\\|"");
                if (tmpStringArray.length != 2) {
                    continue;
                }
                String dependResultString = tmpStringArray[1];
                String[] dependStringArray = dependResultString.split("","");
                if (dependStringArray.length != 2) {
                    continue;
                }
                String key = dependStringArray[0].trim();
                DependResult dependResult = DependResult.valueOf(dependStringArray[1].trim());
                resultMap.put(key, dependResult);
            }
        }
        return resultMap;
    }",1
dubbo-3.2,RESOURCE_LEAK,dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/legacy/LogTelnetHandler.java,"org.apache.dubbo.qos.legacy.LogTelnetHandler.telnet(org.apache.dubbo.remoting.Channel,java.lang.String):java.lang.String",78,"resource of type `java.io.FileInputStream` acquired by call to `FileInputStream(...)` at line 58 is not released after line 78.
**Note**: potential exception at line 71",https://github.com/apache/dubbo/blob/3.2/dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/legacy/LogTelnetHandler.java,"public String telnet(Channel channel, String message) {
        long size;
        File file = LoggerFactory.getFile();
        StringBuilder buf = new StringBuilder();
        if (message == null || message.trim().length() == 0) {
            buf.append(""EXAMPLE: log error / log 100"");
        } else {
            String[] str = message.split("" "");
            if (!StringUtils.isNumber(str[0])) {
                LoggerFactory.setLevel(Level.valueOf(message.toUpperCase()));
            } else {
                int showLogLength = Integer.parseInt(str[0]);

                if (file != null && file.exists()) {
                    try(FileInputStream fis = new FileInputStream(file)) {
                        FileChannel filechannel = fis.getChannel();
                        size = filechannel.size();
                        ByteBuffer bb;
                        if (size <= showLogLength) {
                            bb = ByteBuffer.allocate((int) size);
                            filechannel.read(bb, 0);
                        } else {
                            int pos = (int) (size - showLogLength);
                            bb = ByteBuffer.allocate(showLogLength);
                            filechannel.read(bb, pos);
                        }
                        bb.flip();
                        String content = new String(bb.array()).replace(""<"", ""&lt;"")
                                .replace("">"", ""&gt;"").replace(""\n"", ""<br/><br/>"");
                        buf.append(""\r\ncontent:"").append(content);

                        buf.append(""\r\nmodified:"").append(new SimpleDateFormat(""yyyy-MM-dd HH:mm:ss"")
                                .format(new Date(file.lastModified())));
                        buf.append(""\r\nsize:"").append(size).append(""\r\n"");
                    } catch (Exception e) {
                        buf.append(e.getMessage());
                    }
                } else {
                    buf.append(""\r\nMESSAGE: log file not exists or log appender is console ."");
                }
            }
        }
        buf.append(""\r\nCURRENT LOG LEVEL:"").append(LoggerFactory.getLevel()).append(""\r\nCURRENT LOG APPENDER:"")
                .append(file == null ? ""console"" : file.getAbsolutePath());
        return buf.toString();
    }",0
dubbo-3.2,RESOURCE_LEAK,dubbo-compatible/src/main/java/com/alibaba/dubbo/container/page/pages/LogPageHandler.java,com.alibaba.dubbo.container.page.pages.LogPageHandler.handle(com.alibaba.dubbo.common.URL):com.alibaba.dubbo.container.page.Page,84,resource of type `java.io.FileInputStream` acquired by call to `FileInputStream(...)` at line 78 is not released after line 84.,https://github.com/apache/dubbo/blob/3.2/dubbo-compatible/src/main/java/com/alibaba/dubbo/container/page/pages/LogPageHandler.java,"public Page handle(URL url) {
        long size = 0;
        String content = """";
        String modified = ""Not exist"";
        if (file != null && file.exists()) {
            try {
                FileInputStream fis = new FileInputStream(file);
                FileChannel channel = fis.getChannel();
                size = channel.size();
                ByteBuffer bb;
                if (size <= SHOW_LOG_LENGTH) {
                    bb = ByteBuffer.allocate((int) size);
                    channel.read(bb, 0);
                } else {
                    int pos = (int) (size - SHOW_LOG_LENGTH);
                    bb = ByteBuffer.allocate(SHOW_LOG_LENGTH);
                    channel.read(bb, pos);
                }
                bb.flip();
                content = new String(bb.array()).replace(""<"", ""&lt;"")
                        .replace("">"", ""&gt;"").replace(""\n"", ""<br/><br/>"");
                modified = new SimpleDateFormat(""yyyy-MM-dd HH:mm:ss"")
                        .format(new Date(file.lastModified()));
            } catch (IOException e) {
            }
        }
        Level level = LogManager.getRootLogger().getLevel();
        List<List<String>> rows = new ArrayList<List<String>>();
        List<String> row = new ArrayList<String>();
        row.add(content);
        rows.add(row);
        return new Page(""Log"", ""Log"", new String[]{(file == null ? """" : file.getName()) + "", "" + size + "" bytes, "" + modified + "", "" + level}, rows);
    }",1
dubbo-3.2,RESOURCE_LEAK,dubbo-compatible/src/main/java/com/alibaba/dubbo/container/page/pages/LogPageHandler.java,com.alibaba.dubbo.container.page.pages.LogPageHandler.handle(com.alibaba.dubbo.common.URL):com.alibaba.dubbo.container.page.Page,88,resource of type `java.io.FileInputStream` acquired by call to `FileInputStream(...)` at line 78 is not released after line 88.,https://github.com/apache/dubbo/blob/3.2/dubbo-compatible/src/main/java/com/alibaba/dubbo/container/page/pages/LogPageHandler.java,"public Page handle(URL url) {
        long size = 0;
        String content = """";
        String modified = ""Not exist"";
        if (file != null && file.exists()) {
            try {
                FileInputStream fis = new FileInputStream(file);
                FileChannel channel = fis.getChannel();
                size = channel.size();
                ByteBuffer bb;
                if (size <= SHOW_LOG_LENGTH) {
                    bb = ByteBuffer.allocate((int) size);
                    channel.read(bb, 0);
                } else {
                    int pos = (int) (size - SHOW_LOG_LENGTH);
                    bb = ByteBuffer.allocate(SHOW_LOG_LENGTH);
                    channel.read(bb, pos);
                }
                bb.flip();
                content = new String(bb.array()).replace(""<"", ""&lt;"")
                        .replace("">"", ""&gt;"").replace(""\n"", ""<br/><br/>"");
                modified = new SimpleDateFormat(""yyyy-MM-dd HH:mm:ss"")
                        .format(new Date(file.lastModified()));
            } catch (IOException e) {
            }
        }
        Level level = LogManager.getRootLogger().getLevel();
        List<List<String>> rows = new ArrayList<List<String>>();
        List<String> row = new ArrayList<String>();
        row.add(content);
        rows.add(row);
        return new Page(""Log"", ""Log"", new String[]{(file == null ? """" : file.getName()) + "", "" + size + "" bytes, "" + modified + "", "" + level}, rows);
    }",1
dubbo-3.2,RESOURCE_LEAK,dubbo-metadata/dubbo-metadata-api/src/main/java/org/apache/dubbo/metadata/report/support/AbstractMetadataReport.java,org.apache.dubbo.metadata.report.support.AbstractMetadataReport.doSaveProperties(long):void,204,"resource of type `java.io.FileOutputStream` acquired by call to `FileOutputStream(...)` at line 200 is not released after line 204.
**Note**: potential exception at line 201",https://github.com/apache/dubbo/blob/3.2/dubbo-metadata/dubbo-metadata-api/src/main/java/org/apache/dubbo/metadata/report/support/AbstractMetadataReport.java,"private void doSaveProperties(long version) {
        if (version < lastCacheChanged.get()) {
            return;
        }
        if (file == null) {
            return;
        }
        // Save
        try {
            File lockfile = new File(file.getAbsolutePath() + "".lock"");
            if (!lockfile.exists()) {
                lockfile.createNewFile();
            }
            try (RandomAccessFile raf = new RandomAccessFile(lockfile, ""rw"");
                 FileChannel channel = raf.getChannel()) {
                FileLock lock = channel.tryLock();
                if (lock == null) {
                    throw new IOException(""Can not lock the metadataReport cache file "" + file.getAbsolutePath() + "", ignore and retry later, maybe multi java process use the file, please config: dubbo.metadata.file=xxx.properties"");
                }
                // Save
                try {
                    if (!file.exists()) {
                        file.createNewFile();
                    }

                    Properties tmpProperties;
                    if (!syncReport) {
                        // When syncReport = false, properties.setProperty and properties.store are called from the same
                        // thread(reportCacheExecutor), so deep copy is not required
                        tmpProperties = properties;
                    } else {
                        // Using store method and setProperty method of the this.properties will cause lock contention
                        // under multi-threading, so deep copy a new container
                        tmpProperties = new Properties();
                        Set<Map.Entry<Object, Object>> entries = properties.entrySet();
                        for (Map.Entry<Object, Object> entry : entries) {
                            tmpProperties.setProperty((String) entry.getKey(), (String) entry.getValue());
                        }
                    }

                    try (FileOutputStream outputFile = new FileOutputStream(file)) {
                        tmpProperties.store(outputFile, ""Dubbo metadataReport Cache"");
                    }
                } finally {
                    lock.release();
                }
            }
        } catch (Throwable e) {
            if (version < lastCacheChanged.get()) {
                return;
            } else {
                reportCacheExecutor.execute(new SaveProperties(lastCacheChanged.incrementAndGet()));
            }
            logger.warn(COMMON_UNEXPECTED_EXCEPTION, """", """", ""Failed to save service store file, cause: "" + e.getMessage(), e);
        }
    }",0
dubbo-3.2,RESOURCE_LEAK,dubbo-metadata/dubbo-metadata-api/src/main/java/org/apache/dubbo/metadata/report/support/AbstractMetadataReport.java,org.apache.dubbo.metadata.report.support.AbstractMetadataReport.doSaveProperties(long):void,207,"resource of type `java.io.RandomAccessFile` acquired by call to `RandomAccessFile(...)` at line 173 is not released after line 207.
**Note**: potential exception at line 175",https://github.com/apache/dubbo/blob/3.2/dubbo-metadata/dubbo-metadata-api/src/main/java/org/apache/dubbo/metadata/report/support/AbstractMetadataReport.java,"private void doSaveProperties(long version) {
        if (version < lastCacheChanged.get()) {
            return;
        }
        if (file == null) {
            return;
        }
        // Save
        try {
            File lockfile = new File(file.getAbsolutePath() + "".lock"");
            if (!lockfile.exists()) {
                lockfile.createNewFile();
            }
            try (RandomAccessFile raf = new RandomAccessFile(lockfile, ""rw"");
                 FileChannel channel = raf.getChannel()) {
                FileLock lock = channel.tryLock();
                if (lock == null) {
                    throw new IOException(""Can not lock the metadataReport cache file "" + file.getAbsolutePath() + "", ignore and retry later, maybe multi java process use the file, please config: dubbo.metadata.file=xxx.properties"");
                }
                // Save
                try {
                    if (!file.exists()) {
                        file.createNewFile();
                    }

                    Properties tmpProperties;
                    if (!syncReport) {
                        // When syncReport = false, properties.setProperty and properties.store are called from the same
                        // thread(reportCacheExecutor), so deep copy is not required
                        tmpProperties = properties;
                    } else {
                        // Using store method and setProperty method of the this.properties will cause lock contention
                        // under multi-threading, so deep copy a new container
                        tmpProperties = new Properties();
                        Set<Map.Entry<Object, Object>> entries = properties.entrySet();
                        for (Map.Entry<Object, Object> entry : entries) {
                            tmpProperties.setProperty((String) entry.getKey(), (String) entry.getValue());
                        }
                    }

                    try (FileOutputStream outputFile = new FileOutputStream(file)) {
                        tmpProperties.store(outputFile, ""Dubbo metadataReport Cache"");
                    }
                } finally {
                    lock.release();
                }
            }
        } catch (Throwable e) {
            if (version < lastCacheChanged.get()) {
                return;
            } else {
                reportCacheExecutor.execute(new SaveProperties(lastCacheChanged.incrementAndGet()));
            }
            logger.warn(COMMON_UNEXPECTED_EXCEPTION, """", """", ""Failed to save service store file, cause: "" + e.getMessage(), e);
        }
    }",0
dubbo-3.2,RESOURCE_LEAK,dubbo-common/src/main/java/org/apache/dubbo/common/cache/FileCacheStoreFactory.java,"org.apache.dubbo.common.cache.FileCacheStoreFactory.tryFileLock(org.apache.dubbo.common.cache.FileCacheStore$Builder,java.lang.String):void",181,resource of type `java.io.RandomAccessFile` acquired by call to `RandomAccessFile(...)` at line 180 is not released after line 181.,https://github.com/apache/dubbo/blob/3.2/dubbo-common/src/main/java/org/apache/dubbo/common/cache/FileCacheStoreFactory.java,"private static void tryFileLock(FileCacheStore.Builder builder, String fileName) throws PathNotExclusiveException {
        File lockFile = new File(fileName + "".lock"");

        FileLock dirLock;
        try {
            lockFile.createNewFile();
            if (!lockFile.exists()) {
                throw new AssertionError(""Failed to create lock file "" + lockFile);
            }
            FileChannel lockFileChannel = new RandomAccessFile(lockFile, ""rw"").getChannel();
            dirLock = lockFileChannel.tryLock();
        } catch (OverlappingFileLockException ofle) {
            dirLock = null;
        } catch (IOException ioe) {
            throw new RuntimeException(ioe);
        }

        if (dirLock == null) {
            throw new PathNotExclusiveException(fileName + "" is not exclusive. Maybe multiple Dubbo instances are using the same folder."");
        }

        lockFile.deleteOnExit();
        builder.directoryLock(dirLock).lockFile(lockFile);
    }

    static void removeCache(String cacheFileName) {
        cacheMap.remove(cacheFileName);
    }",1
dubbo-3.2,RESOURCE_LEAK,dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/support/AbstractRegistry.java,org.apache.dubbo.registry.support.AbstractRegistry.doSaveProperties(long):void,265,"resource of type `java.io.FileOutputStream` acquired by call to `FileOutputStream(...)` at line 261 is not released after line 265.
**Note**: potential exception at line 262",https://github.com/apache/dubbo/blob/3.2/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/support/AbstractRegistry.java,"public void doSaveProperties(long version) {
        if (version < lastCacheChanged.get()) {
            return;
        }
        if (file == null) {
            return;
        }
        // Save
        File lockfile = null;
        try {
            lockfile = new File(file.getAbsolutePath() + "".lock"");
            if (!lockfile.exists()) {
                lockfile.createNewFile();
            }

            try (RandomAccessFile raf = new RandomAccessFile(lockfile, ""rw"");
                 FileChannel channel = raf.getChannel()) {
                FileLock lock = channel.tryLock();
                if (lock == null) {

                    IOException ioException = new IOException(""Can not lock the registry cache file "" + file.getAbsolutePath() + "", "" +
                        ""ignore and retry later, maybe multi java process use the file, please config: dubbo.registry.file=xxx.properties"");

                    // 1-9 failed to read / save registry cache file.
                    logger.warn(REGISTRY_FAILED_READ_WRITE_CACHE_FILE, CAUSE_MULTI_DUBBO_USING_SAME_FILE, """",
                        ""Adjust dubbo.registry.file."", ioException);

                    throw ioException;
                }

                // Save
                try {
                    if (!file.exists()) {
                        file.createNewFile();
                    }

                    Properties tmpProperties;
                    if (syncSaveFile) {
                        // When syncReport = true, properties.setProperty and properties.store are called from the same
                        // thread(reportCacheExecutor), so deep copy is not required
                        tmpProperties = properties;
                    } else {
                        // Using properties.setProperty and properties.store method will cause lock contention
                        // under multi-threading, so deep copy a new container
                        tmpProperties = new Properties();
                        Set<Map.Entry<Object, Object>> entries = properties.entrySet();
                        for (Map.Entry<Object, Object> entry : entries) {
                            tmpProperties.setProperty((String) entry.getKey(), (String) entry.getValue());
                        }
                    }

                    try (FileOutputStream outputFile = new FileOutputStream(file)) {
                        tmpProperties.store(outputFile, ""Dubbo Registry Cache"");
                    }
                } finally {
                    lock.release();
                }
            }
        } catch (Throwable e) {
            savePropertiesRetryTimes.incrementAndGet();

            if (savePropertiesRetryTimes.get() >= MAX_RETRY_TIMES_SAVE_PROPERTIES) {
                if (e instanceof OverlappingFileLockException) {
                    // fix #9341, ignore OverlappingFileLockException
                    logger.info(""Failed to save registry cache file for file overlapping lock exception, file name "" + file.getName());
                } else {
                    // 1-9 failed to read / save registry cache file.
                    logger.warn(REGISTRY_FAILED_READ_WRITE_CACHE_FILE, CAUSE_MULTI_DUBBO_USING_SAME_FILE, """",
                        ""Failed to save registry cache file after retrying "" + MAX_RETRY_TIMES_SAVE_PROPERTIES + "" times, cause: "" + e.getMessage(), e);
                }

                savePropertiesRetryTimes.set(0);
                return;
            }

            if (version < lastCacheChanged.get()) {
                savePropertiesRetryTimes.set(0);
                return;
            } else {
                registryCacheExecutor.schedule(() -> doSaveProperties(lastCacheChanged.incrementAndGet()), DEFAULT_INTERVAL_SAVE_PROPERTIES, TimeUnit.MILLISECONDS);
            }

            if (!(e instanceof OverlappingFileLockException)) {
                logger.warn(REGISTRY_FAILED_READ_WRITE_CACHE_FILE, CAUSE_MULTI_DUBBO_USING_SAME_FILE,
                    ""However, the retrying count limit is not exceeded. Dubbo will still try."",
                    ""Failed to save registry cache file, will retry, cause: "" + e.getMessage(), e);
            }
        } finally {
            if (lockfile != null) {
                if (!lockfile.delete()) {
                    // 1-10 Failed to delete lock file.
                    logger.warn(REGISTRY_FAILED_DELETE_LOCKFILE, """", """",
                        String.format(""Failed to delete lock file [%s]"", lockfile.getName()));
                }
            }
        }
    }",0
dubbo-3.2,RESOURCE_LEAK,dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/support/AbstractRegistry.java,org.apache.dubbo.registry.support.AbstractRegistry.doSaveProperties(long):void,268,"resource of type `java.io.RandomAccessFile` acquired by call to `RandomAccessFile(...)` at line 225 is not released after line 268.
**Note**: potential exception at line 227",https://github.com/apache/dubbo/blob/3.2/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/support/AbstractRegistry.java,"public void doSaveProperties(long version) {
        if (version < lastCacheChanged.get()) {
            return;
        }
        if (file == null) {
            return;
        }
        // Save
        File lockfile = null;
        try {
            lockfile = new File(file.getAbsolutePath() + "".lock"");
            if (!lockfile.exists()) {
                lockfile.createNewFile();
            }

            try (RandomAccessFile raf = new RandomAccessFile(lockfile, ""rw"");
                 FileChannel channel = raf.getChannel()) {
                FileLock lock = channel.tryLock();
                if (lock == null) {

                    IOException ioException = new IOException(""Can not lock the registry cache file "" + file.getAbsolutePath() + "", "" +
                        ""ignore and retry later, maybe multi java process use the file, please config: dubbo.registry.file=xxx.properties"");

                    // 1-9 failed to read / save registry cache file.
                    logger.warn(REGISTRY_FAILED_READ_WRITE_CACHE_FILE, CAUSE_MULTI_DUBBO_USING_SAME_FILE, """",
                        ""Adjust dubbo.registry.file."", ioException);

                    throw ioException;
                }

                // Save
                try {
                    if (!file.exists()) {
                        file.createNewFile();
                    }

                    Properties tmpProperties;
                    if (syncSaveFile) {
                        // When syncReport = true, properties.setProperty and properties.store are called from the same
                        // thread(reportCacheExecutor), so deep copy is not required
                        tmpProperties = properties;
                    } else {
                        // Using properties.setProperty and properties.store method will cause lock contention
                        // under multi-threading, so deep copy a new container
                        tmpProperties = new Properties();
                        Set<Map.Entry<Object, Object>> entries = properties.entrySet();
                        for (Map.Entry<Object, Object> entry : entries) {
                            tmpProperties.setProperty((String) entry.getKey(), (String) entry.getValue());
                        }
                    }

                    try (FileOutputStream outputFile = new FileOutputStream(file)) {
                        tmpProperties.store(outputFile, ""Dubbo Registry Cache"");
                    }
                } finally {
                    lock.release();
                }
            }
        } catch (Throwable e) {
            savePropertiesRetryTimes.incrementAndGet();

            if (savePropertiesRetryTimes.get() >= MAX_RETRY_TIMES_SAVE_PROPERTIES) {
                if (e instanceof OverlappingFileLockException) {
                    // fix #9341, ignore OverlappingFileLockException
                    logger.info(""Failed to save registry cache file for file overlapping lock exception, file name "" + file.getName());
                } else {
                    // 1-9 failed to read / save registry cache file.
                    logger.warn(REGISTRY_FAILED_READ_WRITE_CACHE_FILE, CAUSE_MULTI_DUBBO_USING_SAME_FILE, """",
                        ""Failed to save registry cache file after retrying "" + MAX_RETRY_TIMES_SAVE_PROPERTIES + "" times, cause: "" + e.getMessage(), e);
                }

                savePropertiesRetryTimes.set(0);
                return;
            }

            if (version < lastCacheChanged.get()) {
                savePropertiesRetryTimes.set(0);
                return;
            } else {
                registryCacheExecutor.schedule(() -> doSaveProperties(lastCacheChanged.incrementAndGet()), DEFAULT_INTERVAL_SAVE_PROPERTIES, TimeUnit.MILLISECONDS);
            }

            if (!(e instanceof OverlappingFileLockException)) {
                logger.warn(REGISTRY_FAILED_READ_WRITE_CACHE_FILE, CAUSE_MULTI_DUBBO_USING_SAME_FILE,
                    ""However, the retrying count limit is not exceeded. Dubbo will still try."",
                    ""Failed to save registry cache file, will retry, cause: "" + e.getMessage(), e);
            }
        } finally {
            if (lockfile != null) {
                if (!lockfile.delete()) {
                    // 1-10 Failed to delete lock file.
                    logger.warn(REGISTRY_FAILED_DELETE_LOCKFILE, """", """",
                        String.format(""Failed to delete lock file [%s]"", lockfile.getName()));
                }
            }
        }
    }",0
dubbo-3.2,RESOURCE_LEAK,dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/support/AbstractRegistry.java,org.apache.dubbo.registry.support.AbstractRegistry.doSaveProperties(long):void,298,"resource of type `java.io.RandomAccessFile` acquired by call to `RandomAccessFile(...)` at line 225 is not released after line 298.
**Note**: potential exception at line 227",https://github.com/apache/dubbo/blob/3.2/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/support/AbstractRegistry.java,"public void doSaveProperties(long version) {
        if (version < lastCacheChanged.get()) {
            return;
        }
        if (file == null) {
            return;
        }
        // Save
        File lockfile = null;
        try {
            lockfile = new File(file.getAbsolutePath() + "".lock"");
            if (!lockfile.exists()) {
                lockfile.createNewFile();
            }

            try (RandomAccessFile raf = new RandomAccessFile(lockfile, ""rw"");
                 FileChannel channel = raf.getChannel()) {
                FileLock lock = channel.tryLock();
                if (lock == null) {

                    IOException ioException = new IOException(""Can not lock the registry cache file "" + file.getAbsolutePath() + "", "" +
                        ""ignore and retry later, maybe multi java process use the file, please config: dubbo.registry.file=xxx.properties"");

                    // 1-9 failed to read / save registry cache file.
                    logger.warn(REGISTRY_FAILED_READ_WRITE_CACHE_FILE, CAUSE_MULTI_DUBBO_USING_SAME_FILE, """",
                        ""Adjust dubbo.registry.file."", ioException);

                    throw ioException;
                }

                // Save
                try {
                    if (!file.exists()) {
                        file.createNewFile();
                    }

                    Properties tmpProperties;
                    if (syncSaveFile) {
                        // When syncReport = true, properties.setProperty and properties.store are called from the same
                        // thread(reportCacheExecutor), so deep copy is not required
                        tmpProperties = properties;
                    } else {
                        // Using properties.setProperty and properties.store method will cause lock contention
                        // under multi-threading, so deep copy a new container
                        tmpProperties = new Properties();
                        Set<Map.Entry<Object, Object>> entries = properties.entrySet();
                        for (Map.Entry<Object, Object> entry : entries) {
                            tmpProperties.setProperty((String) entry.getKey(), (String) entry.getValue());
                        }
                    }

                    try (FileOutputStream outputFile = new FileOutputStream(file)) {
                        tmpProperties.store(outputFile, ""Dubbo Registry Cache"");
                    }
                } finally {
                    lock.release();
                }
            }
        } catch (Throwable e) {
            savePropertiesRetryTimes.incrementAndGet();

            if (savePropertiesRetryTimes.get() >= MAX_RETRY_TIMES_SAVE_PROPERTIES) {
                if (e instanceof OverlappingFileLockException) {
                    // fix #9341, ignore OverlappingFileLockException
                    logger.info(""Failed to save registry cache file for file overlapping lock exception, file name "" + file.getName());
                } else {
                    // 1-9 failed to read / save registry cache file.
                    logger.warn(REGISTRY_FAILED_READ_WRITE_CACHE_FILE, CAUSE_MULTI_DUBBO_USING_SAME_FILE, """",
                        ""Failed to save registry cache file after retrying "" + MAX_RETRY_TIMES_SAVE_PROPERTIES + "" times, cause: "" + e.getMessage(), e);
                }

                savePropertiesRetryTimes.set(0);
                return;
            }

            if (version < lastCacheChanged.get()) {
                savePropertiesRetryTimes.set(0);
                return;
            } else {
                registryCacheExecutor.schedule(() -> doSaveProperties(lastCacheChanged.incrementAndGet()), DEFAULT_INTERVAL_SAVE_PROPERTIES, TimeUnit.MILLISECONDS);
            }

            if (!(e instanceof OverlappingFileLockException)) {
                logger.warn(REGISTRY_FAILED_READ_WRITE_CACHE_FILE, CAUSE_MULTI_DUBBO_USING_SAME_FILE,
                    ""However, the retrying count limit is not exceeded. Dubbo will still try."",
                    ""Failed to save registry cache file, will retry, cause: "" + e.getMessage(), e);
            }
        } finally {
            if (lockfile != null) {
                if (!lockfile.delete()) {
                    // 1-10 Failed to delete lock file.
                    logger.warn(REGISTRY_FAILED_DELETE_LOCKFILE, """", """",
                        String.format(""Failed to delete lock file [%s]"", lockfile.getName()));
                }
            }
        }
    }",0
dubbo-3.2,RESOURCE_LEAK,dubbo-metadata/dubbo-metadata-api/src/main/java/org/apache/dubbo/metadata/report/support/AbstractMetadataReport.java,org.apache.dubbo.metadata.report.support.AbstractMetadataReport.loadProperties():void,224,"resource of type `java.io.FileInputStream` acquired by call to `FileInputStream(...)` at line 219 is not released after line 224.
**Note**: potential exception at line 220",https://github.com/apache/dubbo/blob/3.2/dubbo-metadata/dubbo-metadata-api/src/main/java/org/apache/dubbo/metadata/report/support/AbstractMetadataReport.java,"void loadProperties() {
        if (file != null && file.exists()) {
            try (InputStream in = new FileInputStream(file)) {
                properties.load(in);
                if (logger.isInfoEnabled()) {
                    logger.info(""Load service store file "" + file + "", data: "" + properties);
                }
            } catch (Throwable e) {
                logger.warn(COMMON_UNEXPECTED_EXCEPTION, """", """", ""Failed to load service store file"" + file, e);
            }
        }
    }",0
guava-32.1.1,RESOURCE_LEAK,guava/src/com/google/common/io/CharStreams.java,"com.google.common.io.CharStreams.copy(com.google.common.io.CharStreamsTest$4,java.lang.StringBuilder):long",79,"resource of type `com.google.common.io.AppendableWriter` acquired by call to `asWriter(...)` at line 79 is not released after line 79.
**Note**: potential exception at line 79",https://github.com/google/guava/blob/v32.1.1/guava/src/com/google/common/io/CharStreams.java,"public static long copy(Readable from, Appendable to) throws IOException {
    // The most common case is that from is a Reader (like InputStreamReader or StringReader) so
    // take advantage of that.
    if (from instanceof Reader) {
      // optimize for common output types which are optimized to deal with char[]
      if (to instanceof StringBuilder) {
        return copyReaderToBuilder((Reader) from, (StringBuilder) to);
      } else {
        return copyReaderToWriter((Reader) from, asWriter(to));
      }
    }

    checkNotNull(from);
    checkNotNull(to);
    long total = 0;
    CharBuffer buf = createBuffer();
    while (from.read(buf) != -1) {
      Java8Compatibility.flip(buf);
      to.append(buf);
      total += buf.remaining();
      Java8Compatibility.clear(buf);
    }
    return total;
  }",1
guava-32.1.1,RESOURCE_LEAK,guava/src/com/google/common/io/ByteSink.java,com.google.common.io.ByteSink.writeFrom(java.io.ByteArrayInputStream):long,129,resource of type `com.google.common.io.TestByteSink$Out` acquired by call to `openStream()` at line 127 is not released after line 129.,https://github.com/google/guava/blob/v32.1.1/guava/src/com/google/common/io/ByteSink.java,"public long writeFrom(InputStream input) throws IOException {
    checkNotNull(input);

    Closer closer = Closer.create();
    try {
      OutputStream out = closer.register(openStream());
      long written = ByteStreams.copy(input, out);
      out.flush(); // https://code.google.com/p/guava-libraries/issues/detail?id=1330
      return written;
    } catch (Throwable e) {
      throw closer.rethrow(e);
    } finally {
      closer.close();
    }
  }",0
guava-32.1.1,RESOURCE_LEAK,guava/src/com/google/common/io/ByteSink.java,com.google.common.io.ByteSink.writeFrom(java.io.ByteArrayInputStream):long,131,"resource of type `com.google.common.io.TestByteSink$Out` acquired by call to `openStream()` at line 127 is not released after line 131.
**Note**: potential exception at line 128",https://github.com/google/guava/blob/v32.1.1/guava/src/com/google/common/io/ByteSink.java,"public long writeFrom(InputStream input) throws IOException {
    checkNotNull(input);

    Closer closer = Closer.create();
    try {
      OutputStream out = closer.register(openStream());
      long written = ByteStreams.copy(input, out);
      out.flush(); // https://code.google.com/p/guava-libraries/issues/detail?id=1330
      return written;
    } catch (Throwable e) {
      throw closer.rethrow(e);
    } finally {
      closer.close();
    }
  }",0
guava-32.1.1,RESOURCE_LEAK,guava/src/com/google/common/io/Files.java,com.google.common.io.Files$FileByteSource.read():byte[],159,resource of type `java.io.FileInputStream` acquired by call to `openStream()` at line 158 is not released after line 159.,https://github.com/google/guava/blob/v32.1.1/guava/src/com/google/common/io/Files.java,"public byte[] read() throws IOException {
      Closer closer = Closer.create();
      try {
        FileInputStream in = closer.register(openStream());
        return ByteStreams.toByteArray(in, in.getChannel().size());
      } catch (Throwable e) {
        throw closer.rethrow(e);
      } finally {
        closer.close();
      }
    }",0
guava-32.1.1,RESOURCE_LEAK,guava/src/com/google/common/io/CharSink.java,com.google.common.io.CharSink.writeFrom(java.io.StringReader):long,182,resource of type `com.google.common.io.TestCharSink$1` acquired by call to `openStream()` at line 180 is not released after line 182.,https://github.com/google/guava/blob/v32.1.1/guava/src/com/google/common/io/CharSink.java,"public long writeFrom(Readable readable) throws IOException {
    checkNotNull(readable);

    Closer closer = Closer.create();
    try {
      Writer out = closer.register(openStream());
      long written = CharStreams.copy(readable, out);
      out.flush(); // https://code.google.com/p/guava-libraries/issues/detail?id=1330
      return written;
    } catch (Throwable e) {
      throw closer.rethrow(e);
    } finally {
      closer.close();
    }
  }",0
guava-32.1.1,RESOURCE_LEAK,guava/src/com/google/common/io/CharSink.java,com.google.common.io.CharSink.writeFrom(java.io.StringReader):long,184,"resource of type `com.google.common.io.TestCharSink$1` acquired by call to `openStream()` at line 180 is not released after line 184.
**Note**: potential exception at line 181",https://github.com/google/guava/blob/v32.1.1/guava/src/com/google/common/io/CharSink.java,"public long writeFrom(Readable readable) throws IOException {
    checkNotNull(readable);

    Closer closer = Closer.create();
    try {
      Writer out = closer.register(openStream());
      long written = CharStreams.copy(readable, out);
      out.flush(); // https://code.google.com/p/guava-libraries/issues/detail?id=1330
      return written;
    } catch (Throwable e) {
      throw closer.rethrow(e);
    } finally {
      closer.close();
    }
  }",0
guava-32.1.1,RESOURCE_LEAK,guava/src/com/google/common/io/LittleEndianDataInputStream.java,com.google.common.io.LittleEndianDataInputStream.readUTF():java.lang.String,180,resource of type `java.io.DataInputStream` acquired by call to `new()` at line 180 is not released after line 180.,https://github.com/google/guava/blob/v32.1.1/guava/src/com/google/common/io/LittleEndianDataInputStream.java,"public String readUTF() throws IOException {
    return new DataInputStream(in).readUTF();
  }",1
guava-32.1.1,RESOURCE_LEAK,guava/src/com/google/common/io/FileBackedOutputStream.java,com.google.common.io.FileBackedOutputStream.update(int):void,250,"resource of type `java.io.FileOutputStream` acquired to `transfer` by call to `FileOutputStream(...)` at line 245 is not released after line 250.
**Note**: potential exception at line 246",https://github.com/google/guava/blob/v32.1.1/guava/src/com/google/common/io/FileBackedOutputStream.java,"private void update(int len) throws IOException {
    if (memory != null && (memory.getCount() + len > fileThreshold)) {
      File temp = TempFileCreator.INSTANCE.createTempFile(""FileBackedOutputStream"");
      if (resetOnFinalize) {
        // Finalizers are not guaranteed to be called on system shutdown;
        // this is insurance.
        temp.deleteOnExit();
      }
      try {
        FileOutputStream transfer = new FileOutputStream(temp);
        transfer.write(memory.getBuffer(), 0, memory.getCount());
        transfer.flush();
        // We've successfully transferred the data; switch to writing to file
        out = transfer;
      } catch (IOException e) {
        temp.delete();
        throw e;
      }

      file = temp;
      memory = null;
    }
  }",1
guava-32.1.1,RESOURCE_LEAK,guava/src/com/google/common/io/ByteSource.java,com.google.common.io.ByteSource.copyTo(java.io.ByteArrayOutputStream):long,257,resource of type `com.google.common.io.RandomAmountInputStream` acquired by call to `openStream()` at line 256 is not released after line 257.,https://github.com/google/guava/blob/v32.1.1/guava/src/com/google/common/io/ByteSource.java,"public long copyTo(OutputStream output) throws IOException {
    checkNotNull(output);

    Closer closer = Closer.create();
    try {
      InputStream in = closer.register(openStream());
      return ByteStreams.copy(in, output);
    } catch (Throwable e) {
      throw closer.rethrow(e);
    } finally {
      closer.close();
    }
  }",0
guava-32.1.1,RESOURCE_LEAK,guava/src/com/google/common/base/FinalizableReferenceQueue.java,com.google.common.base.FinalizableReferenceQueue$DecoupledLoader.loadFinalizer():java.lang.Class,299,resource of type `java.net.URLClassLoader` acquired by call to `newLoader(...)` at line 298 is not released after line 299.,https://github.com/google/guava/blob/v32.1.1/guava/src/com/google/common/base/FinalizableReferenceQueue.java,"public Class<?> loadFinalizer() {
      try {
        /*
         * We use URLClassLoader because it's the only concrete class loader implementation in the
         * JDK. If we used our own ClassLoader subclass, Finalizer would indirectly reference this
         * class loader:
         *
         * Finalizer.class -> CustomClassLoader -> CustomClassLoader.class -> This class loader
         *
         * System class loader will (and must) be the parent.
         */
        ClassLoader finalizerLoader = newLoader(getBaseUrl());
        return finalizerLoader.loadClass(FINALIZER_CLASS_NAME);
      } catch (Exception e) {
        logger.log(Level.WARNING, LOADING_ERROR, e);
        return null;
      }
    }",1
guava-32.1.1,RESOURCE_LEAK,guava/src/com/google/common/io/ByteSource.java,com.google.common.io.ByteSource.read(com.google.common.io.ByteSourceTest$1):java.lang.Object,325,resource of type `com.google.common.io.RandomAmountInputStream` acquired by call to `openStream()` at line 324 is not released after line 325.,https://github.com/google/guava/blob/v32.1.1/guava/src/com/google/common/io/ByteSource.java,"public <T extends @Nullable Object> T read(ByteProcessor<T> processor) throws IOException {
    checkNotNull(processor);

    Closer closer = Closer.create();
    try {
      InputStream in = closer.register(openStream());
      return ByteStreams.readBytes(in, processor);
    } catch (Throwable e) {
      throw closer.rethrow(e);
    } finally {
      closer.close();
    }
  }",0
guava-32.1.1,RESOURCE_LEAK,guava/src/com/google/common/io/ByteSource.java,com.google.common.io.ByteSource.contentEquals(com.google.common.io.Files$FileByteSource):boolean,369,"resource of type `java.io.FileInputStream` acquired by call to `openStream()` at line 358 is not released after line 369.
**Note**: potential exception at line 359",https://github.com/google/guava/blob/v32.1.1/guava/src/com/google/common/io/ByteSource.java,"public boolean contentEquals(ByteSource other) throws IOException {
    checkNotNull(other);

    byte[] buf1 = createBuffer();
    byte[] buf2 = createBuffer();

    Closer closer = Closer.create();
    try {
      InputStream in1 = closer.register(openStream());
      InputStream in2 = closer.register(other.openStream());
      while (true) {
        int read1 = ByteStreams.read(in1, buf1, 0, buf1.length);
        int read2 = ByteStreams.read(in2, buf2, 0, buf2.length);
        if (read1 != read2 || !Arrays.equals(buf1, buf2)) {
          return false;
        } else if (read1 != buf1.length) {
          return true;
        }
      }
    } catch (Throwable e) {
      throw closer.rethrow(e);
    } finally {
      closer.close();
    }
  }",0
guava-32.1.1,RESOURCE_LEAK,guava/src/com/google/common/io/CharSource.java,com.google.common.io.CharSource.readLines(com.google.common.io.Files$1):java.lang.Object,372,resource of type `java.io.InputStreamReader` acquired by call to `openStream()` at line 371 is not released after line 372.,https://github.com/google/guava/blob/v32.1.1/guava/src/com/google/common/io/CharSource.java,"public <T extends @Nullable Object> T readLines(LineProcessor<T> processor) throws IOException {
    checkNotNull(processor);

    Closer closer = Closer.create();
    try {
      Reader reader = closer.register(openStream());
      return CharStreams.readLines(reader, processor);
    } catch (Throwable e) {
      throw closer.rethrow(e);
    } finally {
      closer.close();
    }
  }",0
guava-32.1.1,RESOURCE_LEAK,guava/src/com/google/common/io/ByteSource.java,com.google.common.io.ByteSource$SlicedByteSource.openBufferedStream():java.io.InputStream,515,resource of type `java.io.BufferedInputStream` acquired by call to `openBufferedStream()` at line 515 is not released after line 515.,https://github.com/google/guava/blob/v32.1.1/guava/src/com/google/common/io/ByteSource.java,"public InputStream openBufferedStream() throws IOException {
      return sliceStream(ByteSource.this.openBufferedStream());
    }",1
guava-32.1.1,RESOURCE_LEAK,guava/src/com/google/common/hash/BloomFilter.java,"com.google.common.hash.BloomFilter.readFrom(java.io.ByteArrayInputStream,com.google.common.hash.Funnel):com.google.common.hash.BloomFilter",624,"resource of type `java.io.DataInputStream` acquired to `din` by call to `new()` at line 608 is not released after line 624.
**Note**: potential exception at line 614",https://github.com/google/guava/blob/v32.1.1/guava/src/com/google/common/hash/BloomFilter.java,"public static <T extends @Nullable Object> BloomFilter<T> readFrom(
      InputStream in, Funnel<? super T> funnel) throws IOException {
    checkNotNull(in, ""InputStream"");
    checkNotNull(funnel, ""Funnel"");
    int strategyOrdinal = -1;
    int numHashFunctions = -1;
    int dataLength = -1;
    try {
      DataInputStream din = new DataInputStream(in);
      // currently this assumes there is no negative ordinal; will have to be updated if we
      // add non-stateless strategies (for which we've reserved negative ordinals; see
      // Strategy.ordinal()).
      strategyOrdinal = din.readByte();
      numHashFunctions = UnsignedBytes.toInt(din.readByte());
      dataLength = din.readInt();

      Strategy strategy = BloomFilterStrategies.values()[strategyOrdinal];

      LockFreeBitArray dataArray = new LockFreeBitArray(LongMath.checkedMultiply(dataLength, 64L));
      for (int i = 0; i < dataLength; i++) {
        dataArray.putData(i, din.readLong());
      }

      return new BloomFilter<T>(dataArray, numHashFunctions, funnel, strategy);
    } catch (RuntimeException e) {
      String message =
          ""Unable to deserialize BloomFilter from InputStream.""
              + "" strategyOrdinal: ""
              + strategyOrdinal
              + "" numHashFunctions: ""
              + numHashFunctions
              + "" dataLength: ""
              + dataLength;
      throw new IOException(message, e);
    }
  }",1
guava-32.1.1,RESOURCE_LEAK,guava/src/com/google/common/util/concurrent/ClosingFuture.java,com.google.common.util.concurrent.ClosingFuture$3.call():com.google.common.util.concurrent.ListenableFuture,632,"resource of type `com.google.common.util.concurrent.ClosingFuture$CloseableList` acquired by call to `ClosingFuture$CloseableList()` at line 626 is not released after line 632.
**Note**: potential exception at line 629",https://github.com/google/guava/blob/v32.1.1/guava/src/com/google/common/util/concurrent/ClosingFuture.java,"private ClosingFuture(final AsyncClosingCallable<V> callable, Executor executor) {
    checkNotNull(callable);
    TrustedListenableFutureTask<V> task =
        TrustedListenableFutureTask.create(
            new AsyncCallable<V>() {
              @Override
              public ListenableFuture<V> call() throws Exception {
                CloseableList newCloseables = new CloseableList();
                try {
                  ClosingFuture<V> closingFuture = callable.call(newCloseables.closer);
                  closingFuture.becomeSubsumedInto(closeables);
                  return closingFuture.future;
                } finally {
                  closeables.add(newCloseables, directExecutor());
                }
              }

              @Override
              public String toString() {
                return callable.toString();
              }
            });
    executor.execute(task);
    this.future = task;
  }",1
guava-32.1.1,RESOURCE_LEAK,guava/src/com/google/common/net/InetAddresses.java,com.google.common.net.InetAddresses.getTeredoInfo(java.net.Inet6Address):com.google.common.net.InetAddresses$TeredoInfo,749,resource of type `java.io.DataInputStream` acquired by call to `newDataInput(...)` at line 749 is not released after line 749.,"743: public static TeredoInfo getTeredoInfo(Inet6Address ip) {
 744: checkArgument(isTeredoAddress(ip), ""Address '%s' is not a Teredo address."", toAddrString(ip));
 745: 
 746: byte[] bytes = ip.getAddress();
 747: Inet4Address server = getInet4Address(Arrays.copyOfRange(bytes, 4, 8));
 748: 
 749: int flags = ByteStreams.newDataInput(bytes, 8).readShort() & 0xffff;
 750: 
 751: // Teredo obfuscates the mapped client port, per section 4 of the RFC.
 752: int port = ~ByteStreams.newDataInput(bytes, 10).readShort() & 0xffff;
 753: 
 754: byte[] clientBytes = Arrays.copyOfRange(bytes, 12, 16);
 755: for (int i = 0; i < clientBytes.length; i++) {
 756: // Teredo obfuscates the mapped client IP, per section 4 of the RFC.
 757: clientBytes[i] = (byte) ~clientBytes[i];
 758: }
 759: Inet4Address client = getInet4Address(clientBytes);
 760: 
 761: return new TeredoInfo(server, client, port, flags);","public static TeredoInfo getTeredoInfo(Inet6Address ip) {
    checkArgument(isTeredoAddress(ip), ""Address '%s' is not a Teredo address."", toAddrString(ip));

    byte[] bytes = ip.getAddress();
    Inet4Address server = getInet4Address(Arrays.copyOfRange(bytes, 4, 8));

    int flags = ByteStreams.newDataInput(bytes, 8).readShort() & 0xffff;

    // Teredo obfuscates the mapped client port, per section 4 of the RFC.
    int port = ~ByteStreams.newDataInput(bytes, 10).readShort() & 0xffff;

    byte[] clientBytes = Arrays.copyOfRange(bytes, 12, 16);
    for (int i = 0; i < clientBytes.length; i++) {
      // Teredo obfuscates the mapped client IP, per section 4 of the RFC.
      clientBytes[i] = (byte) ~clientBytes[i];
    }
    Inet4Address client = getInet4Address(clientBytes);

    return new TeredoInfo(server, client, port, flags);
  }",1
guava-32.1.1,RESOURCE_LEAK,guava/src/com/google/common/net/InetAddresses.java,com.google.common.net.InetAddresses.getTeredoInfo(java.net.Inet6Address):com.google.common.net.InetAddresses$TeredoInfo,752,resource of type `java.io.DataInputStream` acquired by call to `newDataInput(...)` at line 752 is not released after line 752.,"743: public static TeredoInfo getTeredoInfo(Inet6Address ip) {
 744: checkArgument(isTeredoAddress(ip), ""Address '%s' is not a Teredo address."", toAddrString(ip));
 745: 
 746: byte[] bytes = ip.getAddress();
 747: Inet4Address server = getInet4Address(Arrays.copyOfRange(bytes, 4, 8));
 748: 
 749: int flags = ByteStreams.newDataInput(bytes, 8).readShort() & 0xffff;
 750: 
 751: // Teredo obfuscates the mapped client port, per section 4 of the RFC.
 752: int port = ~ByteStreams.newDataInput(bytes, 10).readShort() & 0xffff;
 753: 
 754: byte[] clientBytes = Arrays.copyOfRange(bytes, 12, 16);
 755: for (int i = 0; i < clientBytes.length; i++) {
 756: // Teredo obfuscates the mapped client IP, per section 4 of the RFC.
 757: clientBytes[i] = (byte) ~clientBytes[i];
 758: }
 759: Inet4Address client = getInet4Address(clientBytes);
 760: 
 761: return new TeredoInfo(server, client, port, flags);","public static TeredoInfo getTeredoInfo(Inet6Address ip) {
    checkArgument(isTeredoAddress(ip), ""Address '%s' is not a Teredo address."", toAddrString(ip));

    byte[] bytes = ip.getAddress();
    Inet4Address server = getInet4Address(Arrays.copyOfRange(bytes, 4, 8));

    int flags = ByteStreams.newDataInput(bytes, 8).readShort() & 0xffff;

    // Teredo obfuscates the mapped client port, per section 4 of the RFC.
    int port = ~ByteStreams.newDataInput(bytes, 10).readShort() & 0xffff;

    byte[] clientBytes = Arrays.copyOfRange(bytes, 12, 16);
    for (int i = 0; i < clientBytes.length; i++) {
      // Teredo obfuscates the mapped client IP, per section 4 of the RFC.
      clientBytes[i] = (byte) ~clientBytes[i];
    }
    Inet4Address client = getInet4Address(clientBytes);

    return new TeredoInfo(server, client, port, flags);
  }",1
guava-32.1.1,RESOURCE_LEAK,guava/src/com/google/common/net/InetAddresses.java,com.google.common.net.InetAddresses.coerceToInteger(java.net.InetAddress):int,980,resource of type `java.io.DataInputStream` acquired by call to `newDataInput(...)` at line 980 is not released after line 980.,"979: public static int coerceToInteger(InetAddress ip) {
 980: return ByteStreams.newDataInput(getCoercedIPv4Address(ip).getAddress()).readInt();","public static int coerceToInteger(InetAddress ip) {
    return ByteStreams.newDataInput(getCoercedIPv4Address(ip).getAddress()).readInt();
  }",1
guava-32.1.1,RESOURCE_LEAK,guava/src/com/google/common/util/concurrent/ClosingFuture.java,com.google.common.util.concurrent.ClosingFuture.derive(com.google.common.util.concurrent.AbstractCatchingFuture$AsyncCatchingFuture):com.google.common.util.concurrent.ClosingFuture,1140,"resource of type `com.google.common.util.concurrent.ClosingFuture$CloseableList` acquired by call to `ClosingFuture(...)` at line 1138 is not released after line 1140.
**Note**: potential exception at line 1139",https://github.com/google/guava/blob/v32.1.1/guava/src/com/google/common/util/concurrent/ClosingFuture.java,"private <U extends @Nullable Object> ClosingFuture<U> derive(FluentFuture<U> future) {
    ClosingFuture<U> derived = new ClosingFuture<>(future);
    becomeSubsumedInto(derived.closeables);
    return derived;
  }",0
guava-32.1.1,RESOURCE_LEAK,guava/src/com/google/common/util/concurrent/ClosingFuture.java,"com.google.common.util.concurrent.ClosingFuture$Peeker.call(com.google.common.util.concurrent.ClosingFuture$Combiner$CombiningCallable,com.google.common.util.concurrent.ClosingFuture$CloseableList):java.lang.Object",1189,resource of type `com.google.common.util.concurrent.ClosingFuture$CloseableList` acquired by call to `ClosingFuture$CloseableList()` at line 1185 is not released after line 1189.,https://github.com/google/guava/blob/v32.1.1/guava/src/com/google/common/util/concurrent/ClosingFuture.java,"private <V extends @Nullable Object> V call(
        CombiningCallable<V> combiner, CloseableList closeables) throws Exception {
      beingCalled = true;
      CloseableList newCloseables = new CloseableList();
      try {
        return combiner.call(newCloseables.closer, this);
      } finally {
        closeables.add(newCloseables, directExecutor());
        beingCalled = false;
      }
    }",0
guava-32.1.1,RESOURCE_LEAK,guava/src/com/google/common/util/concurrent/ClosingFuture.java,"com.google.common.util.concurrent.ClosingFuture$Peeker.callAsync(com.google.common.util.concurrent.ClosingFuture$Combiner$AsyncCombiningCallable,com.google.common.util.concurrent.ClosingFuture$CloseableList):com.google.common.util.concurrent.FluentFuture",1203,"resource of type `com.google.common.util.concurrent.ClosingFuture$CloseableList` acquired by call to `ClosingFuture$CloseableList()` at line 1197 is not released after line 1203.
**Note**: potential exception at line 1200",https://github.com/google/guava/blob/v32.1.1/guava/src/com/google/common/util/concurrent/ClosingFuture.java,"private <V extends @Nullable Object> FluentFuture<V> callAsync(
        AsyncCombiningCallable<V> combiner, CloseableList closeables) throws Exception {
      beingCalled = true;
      CloseableList newCloseables = new CloseableList();
      try {
        ClosingFuture<V> closingFuture = combiner.call(newCloseables.closer, this);
        closingFuture.becomeSubsumedInto(closeables);
        return closingFuture.future;
      } finally {
        closeables.add(newCloseables, directExecutor());
        beingCalled = false;
      }
    }
  }",0
guava-32.1.1,RESOURCE_LEAK,guava/src/com/google/common/util/concurrent/ClosingFuture.java,"com.google.common.util.concurrent.ClosingFuture$CloseableList.applyClosingFunction(com.google.common.util.concurrent.ClosingFuture$ClosingFunction,java.lang.Object):com.google.common.util.concurrent.ListenableFuture",2203,resource of type `com.google.common.util.concurrent.ClosingFuture$CloseableList` acquired by call to `ClosingFuture$CloseableList()` at line 2199 is not released after line 2203.,https://github.com/google/guava/blob/v32.1.1/guava/src/com/google/common/util/concurrent/ClosingFuture.java,"<V extends @Nullable Object, U extends @Nullable Object>
        ListenableFuture<U> applyClosingFunction(
            ClosingFunction<? super V, U> transformation, @ParametricNullness V input)
            throws Exception {
      // TODO(dpb): Consider ways to defer closing without creating a separate CloseableList.
      CloseableList newCloseables = new CloseableList();
      try {
        return immediateFuture(transformation.apply(newCloseables.closer, input));
      } finally {
        add(newCloseables, directExecutor());
      }
    }",0
guava-32.1.1,RESOURCE_LEAK,guava/src/com/google/common/util/concurrent/ClosingFuture.java,"com.google.common.util.concurrent.ClosingFuture$CloseableList.applyAsyncClosingFunction(com.google.common.util.concurrent.ClosingFuture$AsyncClosingFunction,java.lang.Object):com.google.common.util.concurrent.FluentFuture",2218,"resource of type `com.google.common.util.concurrent.ClosingFuture$CloseableList` acquired by call to `ClosingFuture$CloseableList()` at line 2212 is not released after line 2218.
**Note**: potential exception at line 2215",https://github.com/google/guava/blob/v32.1.1/guava/src/com/google/common/util/concurrent/ClosingFuture.java,"<V extends @Nullable Object, U extends @Nullable Object>
        FluentFuture<U> applyAsyncClosingFunction(
            AsyncClosingFunction<V, U> transformation, @ParametricNullness V input)
            throws Exception {
      // TODO(dpb): Consider ways to defer closing without creating a separate CloseableList.
      CloseableList newCloseables = new CloseableList();
      try {
        ClosingFuture<U> closingFuture = transformation.apply(newCloseables.closer, input);
        closingFuture.becomeSubsumedInto(newCloseables);
        return closingFuture.future;
      } finally {
        add(newCloseables, directExecutor());
      }
    }",0
java-debug-0.47.0,RESOURCE_LEAK,com.microsoft.java.debug.core/src/main/java/com/microsoft/java/debug/core/adapter/handler/LaunchUtils.java,"com.microsoft.java.debug.core.adapter.handler.LaunchUtils.findJavaProcessByCygwinPsCommand(java.lang.ProcessHandle,java.lang.String):long",217,resource of type `java.lang.Process` acquired by call to `exec(...)` at line 216 is not released after line 217.,"199: private static long findJavaProcessByCygwinPsCommand(ProcessHandle shellProcess, String javaCommand) {
 200: String psCommand = detectPsCommandPath(shellProcess.info().command().orElse(null));
 201: if (psCommand == null) {
 202: return -1;
 203: }
 204: 
 205: BufferedReader psReader = null;
 206: List<PsProcess> psProcs = new ArrayList<>();
 207: List<PsProcess> javaCandidates = new ArrayList<>();
 208: try {
 209: String[] headers = null;
 210: int pidIndex = -1;
 211: int ppidIndex = -1;
 212: int winpidIndex = -1;
 213: String line;
 214: String javaExeName = Paths.get(javaCommand).toFile().getName().replaceFirst(""\\.exe$"", """");
 215: 
 216: Process p = Runtime.getRuntime().exec(new String[] {psCommand, ""-l""});
 217: psReader = new BufferedReader(new InputStreamReader(p.getInputStream()));
 218: /**
 219: * Here is a sample output when running ps command in Cygwin/MINGW64 shell.
 220: * PID PPID PGID WINPID TTY UID STIME COMMAND
 221: * 1869 1 1869 7852 cons2 4096 15:29:27 /usr/bin/bash
 222: * 2271 1 2271 30820 cons4 4096 19:38:30 /usr/bin/bash
 223: * 1812 1 1812 21540 cons1 4096 15:05:03 /usr/bin/bash
 224: * 2216 1 2216 11328 cons3 4096 19:38:18 /usr/bin/bash
 225: * 1720 1 1720 5404 cons0 4096 13:46:42 /usr/bin/bash
 226: * 2269 2216 2269 6676 cons3 4096 19:38:21 /c/Program Files/Microsoft/jdk-11.0.14.9-hotspot/bin/java
 227: * 1911 1869 1869 29708 cons2 4096 15:29:31 /c/Program Files/nodejs/node
 228: * 2315 2271 2315 18064 cons4 4096 19:38:34 /usr/bin/ps
 229: */
 230: while ((line = psReader.readLine()) != null) {
 231: String[] cols = line.strip().split(""\\s+"");
 232: if (headers == null) {
 233: headers = cols;
 234: pidIndex = ArrayUtils.indexOf(headers, ""PID"");
 235: ppidIndex = ArrayUtils.indexOf(headers, ""PPID"");
 236: winpidIndex = ArrayUtils.indexOf(headers, ""WINPID"");
 237: if (pidIndex < 0 || ppidIndex < 0 || winpidIndex < 0) {
 238: logger.warning(""Failed to find Java process because ps command is not the standard Cygwin ps command."");
 239: return -1;
 240: }
 241: } else if (cols.length >= headers.length) {
 242: long pid = Long.parseLong(cols[pidIndex]);
 243: long ppid = Long.parseLong(cols[ppidIndex]);
 244: long winpid = Long.parseLong(cols[winpidIndex]);
 245: PsProcess process = new PsProcess(pid, ppid, winpid);
 246: psProcs.add(process);
 247: if (cols[cols.length - 1].endsWith(""/"" + javaExeName) || cols[cols.length - 1].endsWith(""/java"")) {
 248: javaCandidates.add(process);
 249: }
 250: }
 251: }
 252: } catch (Exception err) {
 253: logger.log(Level.WARNING, ""Failed to find Java process by Cygwin ps command."", err);
 254: } finally {
 255: if (psReader != null) {
 256: try {
 257: psReader.close();
 258: } catch (IOException e) {
 259: // ignore
 260: }
 261: }
 262: }
 263: 
 264: if (!javaCandidates.isEmpty()) {
 265: Set<Long> descendantWinpids = shellProcess.descendants().map(proc -> proc.pid()).collect(Collectors.toSet());
 266: long shellWinpid = shellProcess.pid();
 267: for (PsProcess javaCandidate: javaCandidates) {
 268: if (descendantWinpids.contains(javaCandidate.winpid)) {
 269: return javaCandidate.winpid;
 270: }
 271: 
 272: for (PsProcess psProc : psProcs) {
 273: if (javaCandidate.ppid != psProc.pid) {
 274: continue;
 275: }
 276: 
 277: if (descendantWinpids.contains(psProc.winpid) || psProc.winpid == shellWinpid) {
 278: return javaCandidate.winpid;
 279: }
 280: 
 281: break;
 282: }
 283: }
 284: }
 285: 
 286: return -1;","private static long findJavaProcessByCygwinPsCommand(ProcessHandle shellProcess, String javaCommand) {
        String psCommand = detectPsCommandPath(shellProcess.info().command().orElse(null));
        if (psCommand == null) {
            return -1;
        }

        BufferedReader psReader = null;
        List<PsProcess> psProcs = new ArrayList<>();
        List<PsProcess> javaCandidates = new ArrayList<>();
        try {
            String[] headers = null;
            int pidIndex = -1;
            int ppidIndex = -1;
            int winpidIndex = -1;
            String line;
            String javaExeName = Paths.get(javaCommand).toFile().getName().replaceFirst(""\\.exe$"", """");

            Process p = Runtime.getRuntime().exec(new String[] {psCommand, ""-l""});
            psReader = new BufferedReader(new InputStreamReader(p.getInputStream()));
            /**
             * Here is a sample output when running ps command in Cygwin/MINGW64 shell.
             *       PID    PPID    PGID     WINPID   TTY         UID    STIME COMMAND
             *      1869       1    1869       7852  cons2       4096 15:29:27 /usr/bin/bash
             *      2271       1    2271      30820  cons4       4096 19:38:30 /usr/bin/bash
             *      1812       1    1812      21540  cons1       4096 15:05:03 /usr/bin/bash
             *      2216       1    2216      11328  cons3       4096 19:38:18 /usr/bin/bash
             *      1720       1    1720       5404  cons0       4096 13:46:42 /usr/bin/bash
             *      2269    2216    2269       6676  cons3       4096 19:38:21 /c/Program Files/Microsoft/jdk-11.0.14.9-hotspot/bin/java
             *      1911    1869    1869      29708  cons2       4096 15:29:31 /c/Program Files/nodejs/node
             *      2315    2271    2315      18064  cons4       4096 19:38:34 /usr/bin/ps
             */
            while ((line = psReader.readLine()) != null) {
                String[] cols = line.strip().split(""\\s+"");
                if (headers == null) {
                    headers = cols;
                    pidIndex = ArrayUtils.indexOf(headers, ""PID"");
                    ppidIndex = ArrayUtils.indexOf(headers, ""PPID"");
                    winpidIndex = ArrayUtils.indexOf(headers, ""WINPID"");
                    if (pidIndex < 0 || ppidIndex < 0 || winpidIndex < 0) {
                        logger.warning(""Failed to find Java process because ps command is not the standard Cygwin ps command."");
                        return -1;
                    }
                } else if (cols.length >= headers.length) {
                    long pid = Long.parseLong(cols[pidIndex]);
                    long ppid = Long.parseLong(cols[ppidIndex]);
                    long winpid = Long.parseLong(cols[winpidIndex]);
                    PsProcess process = new PsProcess(pid, ppid, winpid);
                    psProcs.add(process);
                    if (cols[cols.length - 1].endsWith(""/"" + javaExeName) || cols[cols.length - 1].endsWith(""/java"")) {
                        javaCandidates.add(process);
                    }
                }
            }
        } catch (Exception err) {
            logger.log(Level.WARNING, ""Failed to find Java process by Cygwin ps command."", err);
        } finally {
            if (psReader != null) {
                try {
                    psReader.close();
                } catch (IOException e) {
                    // ignore
                }
            }
        }

        if (!javaCandidates.isEmpty()) {
            Set<Long> descendantWinpids = shellProcess.descendants().map(proc -> proc.pid()).collect(Collectors.toSet());
            long shellWinpid = shellProcess.pid();
            for (PsProcess javaCandidate: javaCandidates) {
                if (descendantWinpids.contains(javaCandidate.winpid)) {
                    return javaCandidate.winpid;
                }

                for (PsProcess psProc : psProcs) {
                    if (javaCandidate.ppid != psProc.pid) {
                        continue;
                    }

                    if (descendantWinpids.contains(psProc.winpid) || psProc.winpid == shellWinpid) {
                        return javaCandidate.winpid;
                    }

                    break;
                }
            }
        }

        return -1;
    }",1
jreleaser-1.7.0,RESOURCE_LEAK,plugins/jreleaser-ant-tasks/src/main/java/org/jreleaser/ant/tasks/Banner.java,org.jreleaser.ant.tasks.Banner.display(java.io.PrintWriter):void,56,resource of type `java.io.FileOutputStream` acquired by call to `FileOutputStream(...)` at line 56 is not released after line 56.,https://github.com/jreleaser/jreleaser/blob/v1.7.0/plugins/jreleaser-ant-tasks/src/main/java/org/jreleaser/ant/tasks/Banner.java,"public static void display(PrintWriter writer) {
        try {
            File parent = new File(System.getProperty(""user.home""), ""/.ant/caches"");
            File markerFile = getMarkerFile(parent, INSTANCE);
            if (!markerFile.exists()) {
                writer.println(INSTANCE.message);
                markerFile.getParentFile().mkdirs();
                PrintStream out = newPrintStream(new FileOutputStream(markerFile));
                out.println(""1"");
                out.close();
                writeQuietly(markerFile, ""1"");
            } else {
                try {
                    int count = Integer.parseInt(readQuietly(markerFile));
                    if (count < 3) {
                        writer.println(INSTANCE.message);
                    }
                    writeQuietly(markerFile, (count + 1) + """");
                } catch (NumberFormatException e) {
                    writeQuietly(markerFile, ""1"");
                    writer.println(INSTANCE.message);
                }
            }
        } catch (IOException ignored) {
            // noop
        }
    }
",0
jreleaser-1.7.0,RESOURCE_LEAK,plugins/jdks-maven-plugin/src/main/java/org/jreleaser/jdks/maven/plugin/Banner.java,"org.jreleaser.jdks.maven.plugin.Banner.display(org.apache.maven.project.MavenProject,org.apache.maven.plugin.logging.Log):void",72,resource of type `java.io.FileOutputStream` acquired by call to `FileOutputStream(...)` at line 72 is not released after line 72.,https://github.com/jreleaser/jreleaser/blob/v1.7.0/plugins/jdks-maven-plugin/src/main/java/org/jreleaser/jdks/maven/plugin/Banner.java,"public static void display(MavenProject project, Log log) {
        if (INSTANCE.visited.contains(project.getName())) {
            return;
        }

        INSTANCE.visited.add(project.getName());

        boolean quiet = log.isErrorEnabled() &&
            !log.isWarnEnabled() &&
            !log.isInfoEnabled() &&
            !log.isDebugEnabled();

        try {
            File parent = new File(System.getProperty(""user.home""), ""/.m2/caches"");
            File markerFile = getMarkerFile(parent);
            if (!markerFile.exists()) {
                if (!quiet) log.info(INSTANCE.message);
                markerFile.getParentFile().mkdirs();
                PrintStream out = newPrintStream(new FileOutputStream(markerFile));
                out.println(""1"");
                out.close();
                writeQuietly(markerFile, ""1"");
            } else {
                try {
                    int count = Integer.parseInt(readQuietly(markerFile));
                    if (count < 3 && !quiet) log.info(INSTANCE.message);
                    writeQuietly(markerFile, (count + 1) + """");
                } catch (NumberFormatException e) {
                    writeQuietly(markerFile, ""1"");
                    if (!quiet) log.info(INSTANCE.message);
                }
            }
        } catch (IOException ignored) {
            // noop
        }
    }",0
jreleaser-1.7.0,RESOURCE_LEAK,plugins/jreleaser-maven-plugin/src/main/java/org/jreleaser/maven/plugin/Banner.java,"org.jreleaser.maven.plugin.Banner.display(org.apache.maven.project.MavenProject,org.apache.maven.plugin.logging.Log):void",72,resource of type `java.io.FileOutputStream` acquired by call to `FileOutputStream(...)` at line 72 is not released after line 72.,https://github.com/jreleaser/jreleaser/blob/v1.7.0/plugins/jreleaser-maven-plugin/src/main/java/org/jreleaser/maven/plugin/Banner.java,"public static void display(MavenProject project, Log log) {
        if (INSTANCE.visited.contains(project.getName())) {
            return;
        }

        INSTANCE.visited.add(project.getName());

        boolean quiet = log.isErrorEnabled() &&
            !log.isWarnEnabled() &&
            !log.isInfoEnabled() &&
            !log.isDebugEnabled();

        try {
            File parent = new File(System.getProperty(""user.home""), ""/.m2/caches"");
            File markerFile = getMarkerFile(parent);
            if (!markerFile.exists()) {
                if (!quiet) log.info(INSTANCE.message);
                markerFile.getParentFile().mkdirs();
                PrintStream out = newPrintStream(new FileOutputStream(markerFile));
                out.println(""1"");
                out.close();
                writeQuietly(markerFile, ""1"");
            } else {
                try {
                    int count = Integer.parseInt(readQuietly(markerFile));
                    if (count < 3 && !quiet) log.info(INSTANCE.message);
                    writeQuietly(markerFile, (count + 1) + """");
                } catch (NumberFormatException e) {
                    writeQuietly(markerFile, ""1"");
                    if (!quiet) log.info(INSTANCE.message);
                }
            }
        } catch (IOException ignored) {
            // noop
        }
    }",0
jreleaser-1.7.0,RESOURCE_LEAK,plugins/jreleaser-ant-tasks/src/main/java/org/jreleaser/ant/tasks/JReleaserInitTask.java,org.jreleaser.ant.tasks.JReleaserInitTask.createTracer():java.io.PrintWriter,72,resource of type `java.io.FileOutputStream` acquired by call to `FileOutputStream(...)` at line 73 is not released after line 72.,https://github.com/jreleaser/jreleaser/blob/v1.7.0/plugins/jreleaser-ant-tasks/src/main/java/org/jreleaser/ant/tasks/JReleaserInitTask.java,"private PrintWriter createTracer() {
        try {
            Path outputDirectory = getOutputDirectory()
                .resolve(""out"")
                .resolve(""jreleaser"");
            Files.createDirectories(outputDirectory);
            return newPrintWriter(new FileOutputStream(
                outputDirectory.resolve(""trace.log"").toFile()));
        } catch (IOException e) {
            throw new IllegalStateException(""Could not initialize trace file"", e);
        }
    }",1
jreleaser-1.7.0,RESOURCE_LEAK,plugins/jreleaser-ant-tasks/src/main/java/org/jreleaser/ant/tasks/Banner.java,"org.jreleaser.ant.tasks.Banner.writeQuietly(java.io.File,java.lang.String):void",79,resource of type `java.io.FileOutputStream` acquired by call to `FileOutputStream(...)` at line 79 is not released after line 79.,https://github.com/jreleaser/jreleaser/blob/v1.7.0/plugins/jreleaser-ant-tasks/src/main/java/org/jreleaser/ant/tasks/Banner.java,"private static void writeQuietly(File file, String text) {
        try {
            PrintStream out = newPrintStream(new FileOutputStream(file));
            out.println(text);
            out.close();
        } catch (IOException ignored) {
            // ignored
        }
    }",0
jreleaser-1.7.0,RESOURCE_LEAK,plugins/jreleaser/src/main/java/org/jreleaser/cli/Banner.java,"org.jreleaser.cli.Banner.writeQuietly(java.io.File,java.lang.String):void",81,resource of type `java.io.FileOutputStream` acquired by call to `FileOutputStream(...)` at line 81 is not released after line 81.,https://github.com/jreleaser/jreleaser/blob/v1.7.0/plugins/jreleaser/src/main/java/org/jreleaser/cli/Banner.java,"private static void writeQuietly(File file, String text) {
        try {
            PrintStream out = newPrintStream(new FileOutputStream(file));
            out.println(text);
            out.close();
        } catch (IOException ignored) {
            // ignored
        }
    }",0
jreleaser-1.7.0,RESOURCE_LEAK,plugins/jdks-maven-plugin/src/main/java/org/jreleaser/jdks/maven/plugin/Banner.java,"org.jreleaser.jdks.maven.plugin.Banner.writeQuietly(java.io.File,java.lang.String):void",93,resource of type `java.io.FileOutputStream` acquired by call to `FileOutputStream(...)` at line 93 is not released after line 93.,https://github.com/jreleaser/jreleaser/blob/v1.7.0/plugins/jdks-maven-plugin/src/main/java/org/jreleaser/jdks/maven/plugin/Banner.java,"private static void writeQuietly(File file, String text) {
        try {
            PrintStream out = newPrintStream(new FileOutputStream(file));
            out.println(text);
            out.close();
        } catch (IOException ignored) {
            // ignored
        }
    }",0
jreleaser-1.7.0,RESOURCE_LEAK,plugins/jreleaser-maven-plugin/src/main/java/org/jreleaser/maven/plugin/Banner.java,"org.jreleaser.maven.plugin.Banner.writeQuietly(java.io.File,java.lang.String):void",93,resource of type `java.io.FileOutputStream` acquired by call to `FileOutputStream(...)` at line 93 is not released after line 93.,https://github.com/jreleaser/jreleaser/blob/v1.7.0/plugins/jreleaser-maven-plugin/src/main/java/org/jreleaser/maven/plugin/Banner.java,"private static void writeQuietly(File file, String text) {
        try {
            PrintStream out = newPrintStream(new FileOutputStream(file));
            out.println(text);
            out.close();
        } catch (IOException ignored) {
            // ignored
        }
    }",0
jreleaser-1.7.0,RESOURCE_LEAK,plugins/jreleaser-maven-plugin/src/main/java/org/jreleaser/maven/plugin/JReleaserInitMojo.java,org.jreleaser.maven.plugin.JReleaserInitMojo.createTracer():java.io.PrintWriter,99,resource of type `java.io.FileOutputStream` acquired by call to `FileOutputStream(...)` at line 99 is not released after line 99.,https://github.com/jreleaser/jreleaser/blob/v1.7.0/plugins/jreleaser-maven-plugin/src/main/java/org/jreleaser/maven/plugin/JReleaserInitMojo.java,"protected PrintWriter createTracer() throws MojoExecutionException {
        try {
            java.nio.file.Files.createDirectories(outputDirectory.toPath());
            return newPrintWriter(new FileOutputStream(outputDirectory.toPath().resolve(""trace.log"").toFile()));
        } catch (IOException e) {
            throw new MojoExecutionException(""Could not initialize trace file"", e);
        }
    }",1
jreleaser-1.7.0,RESOURCE_LEAK,plugins/jreleaser/src/main/java/org/jreleaser/cli/AbstractLoggingCommand.java,org.jreleaser.cli.AbstractLoggingCommand.createTracer():java.io.PrintWriter,99,resource of type `java.io.FileOutputStream` acquired by call to `FileOutputStream(...)` at line 100 is not released after line 99.,https://github.com/jreleaser/jreleaser/blob/v1.7.0/plugins/jreleaser/src/main/java/org/jreleaser/cli/AbstractLoggingCommand.java,"protected PrintWriter createTracer() {
        try {
            Files.createDirectories(getOutputDirectory());
            return newPrintWriter(new FileOutputStream(
                    getOutputDirectory().resolve(""trace.log"").toFile()));
        } catch (IOException e) {
            throw new IllegalStateException($(""ERROR_trace_file_init""), e);
        }
    }",1
jreleaser-1.7.0,RESOURCE_LEAK,plugins/jreleaser-maven-plugin/src/main/java/org/jreleaser/maven/plugin/AbstractJReleaserMojo.java,org.jreleaser.maven.plugin.AbstractJReleaserMojo.createTracer():java.io.PrintWriter,130,resource of type `java.io.FileOutputStream` acquired by call to `FileOutputStream(...)` at line 131 is not released after line 130.,https://github.com/jreleaser/jreleaser/blob/v1.7.0/plugins/jreleaser-maven-plugin/src/main/java/org/jreleaser/maven/plugin/AbstractJReleaserMojo.java,"protected PrintWriter createTracer() throws MojoExecutionException {
        try {
            java.nio.file.Files.createDirectories(outputDirectory.toPath());
            return newPrintWriter(new FileOutputStream(
                outputDirectory.toPath().resolve(""trace.log"").toFile()));
        } catch (IOException e) {
            throw new MojoExecutionException(""Could not initialize trace file"", e);
        }
    }",1
jreleaser-1.7.0,RESOURCE_LEAK,core/jreleaser-templates/src/main/java/org/jreleaser/templates/TemplateUtils.java,org.jreleaser.templates.TemplateUtils.resolveTemplate(java.nio.file.Path):org.jreleaser.templates.TemplateResource,141,resource of type `java.io.FileInputStream` acquired by call to `FileInputStream(...)` at line 136 is not released after line 141.,"135: public static TemplateResource resolveTemplate(Path file) throws IOException {
 136: FileInputStream inputStream = new FileInputStream(file.toFile());
 137: if (file.getFileName().toString().endsWith(TPL)) {
 138: return new ReaderTemplateResource(new InputStreamReader(inputStream, StandardCharsets.UTF_8));
 139: }
 140: 
 141: return new InputStreamTemplateResource(inputStream);","public static TemplateResource resolveTemplate(Path file) throws IOException {
        FileInputStream inputStream = new FileInputStream(file.toFile());
        if (file.getFileName().toString().endsWith(TPL)) {
            return new ReaderTemplateResource(new InputStreamReader(inputStream, StandardCharsets.UTF_8));
        }

        return new InputStreamTemplateResource(inputStream);
    }",0
jreleaser-1.7.0,RESOURCE_LEAK,plugins/jreleaser-ant-tasks/src/main/java/org/jreleaser/ant/tasks/JReleaserTemplateGenerateTask.java,org.jreleaser.ant.tasks.JReleaserTemplateGenerateTask.createTracer():java.io.PrintWriter,149,resource of type `java.io.FileOutputStream` acquired by call to `FileOutputStream(...)` at line 151 is not released after line 149.,https://github.com/jreleaser/jreleaser/blob/v1.7.0/plugins/jreleaser-ant-tasks/src/main/java/org/jreleaser/ant/tasks/JReleaserTemplateGenerateTask.java,"private PrintWriter createTracer() {
        try {
            Path outputDirectory = getOutputDirectory().resolve(""out"")
                .resolve(""jreleaser"");
            Files.createDirectories(outputDirectory);
            return newPrintWriter(new FileOutputStream(
                outputDirectory
                    .resolve(""trace.log"").toFile()));
        } catch (IOException e) {
            throw new IllegalStateException(""Could not initialize trace file"", e);
        }
    }",1
jreleaser-1.7.0,RESOURCE_LEAK,plugins/jreleaser-maven-plugin/src/main/java/org/jreleaser/maven/plugin/JReleaserTemplateGenerateMojo.java,org.jreleaser.maven.plugin.JReleaserTemplateGenerateMojo.createTracer():java.io.PrintWriter,156,resource of type `java.io.FileOutputStream` acquired by call to `FileOutputStream(...)` at line 156 is not released after line 156.,https://github.com/jreleaser/jreleaser/blob/v1.7.0/plugins/jreleaser-maven-plugin/src/main/java/org/jreleaser/maven/plugin/JReleaserTemplateGenerateMojo.java,"protected PrintWriter createTracer() throws MojoExecutionException {
        try {
            java.nio.file.Files.createDirectories(outputDirectory.toPath());
            return newPrintWriter(new FileOutputStream(outputDirectory.toPath().resolve(""trace.log"").toFile()));
        } catch (IOException e) {
            throw new MojoExecutionException(""Could not initialize trace file"", e);
        }
    }",1
jreleaser-1.7.0,RESOURCE_LEAK,plugins/jreleaser-ant-tasks/src/main/java/org/jreleaser/ant/tasks/AbstractJReleaserTask.java,org.jreleaser.ant.tasks.AbstractJReleaserTask.createTracer():java.io.PrintWriter,159,resource of type `java.io.FileOutputStream` acquired by call to `FileOutputStream(...)` at line 160 is not released after line 159.,https://github.com/jreleaser/jreleaser/blob/v1.7.0/plugins/jreleaser-ant-tasks/src/main/java/org/jreleaser/ant/tasks/AbstractJReleaserTask.java,"protected PrintWriter createTracer() {
        try {
            Files.createDirectories(getOutputDirectory());
            return newPrintWriter(new FileOutputStream(
                getOutputDirectory().resolve(""trace.log"").toFile()));
        } catch (IOException e) {
            throw new IllegalStateException(""Could not initialize trace file"", e);
        }
    }",1
jreleaser-1.7.0,RESOURCE_LEAK,sdks/jreleaser-signing-java-sdk/src/main/java/org/jreleaser/sdk/signing/SigningUtils.java,"org.jreleaser.sdk.signing.SigningUtils.sign(org.jreleaser.model.api.JReleaserContext,org.bouncycastle.openpgp.PGPSignatureGenerator,java.nio.file.Path,java.nio.file.Path):void",270,"resource of type `java.io.FileInputStream` acquired by call to `FileInputStream(...)` at line 272 is not released after line 270.
**Note**: potential exception at line 276",https://github.com/jreleaser/jreleaser/blob/v1.7.0/sdks/jreleaser-signing-java-sdk/src/main/java/org/jreleaser/sdk/signing/SigningUtils.java,"public static void sign(JReleaserContext context, PGPSignatureGenerator signatureGenerator, Path input, Path output) throws SigningException {
        context.getLogger().info(""{}"", context.relativizeToBasedir(input));

        if (null == signatureGenerator) return;

        PGPCompressedDataGenerator compressionStreamGenerator = new PGPCompressedDataGenerator(UNCOMPRESSED);
        try (OutputStream out = createOutputStream(context, output);
             BCPGOutputStream bOut = new BCPGOutputStream(compressionStreamGenerator.open(out));
             FileInputStream in = new FileInputStream(input.toFile())) {

            byte[] buffer = new byte[8192];
            int length = 0;
            while ((length = in.read(buffer)) >= 0) {
                signatureGenerator.update(buffer, 0, length);
            }

            signatureGenerator.generate().encode(bOut);
            compressionStreamGenerator.close();
        } catch (IOException | PGPException e) {
            throw new SigningException(RB.$(""ERROR_unexpected_error_signing"", input.toAbsolutePath()), e);
        }
    }",1
jreleaser-1.7.0,RESOURCE_LEAK,sdks/jreleaser-signing-java-sdk/src/main/java/org/jreleaser/sdk/signing/SigningUtils.java,"org.jreleaser.sdk.signing.SigningUtils.sign(org.jreleaser.model.api.JReleaserContext,org.bouncycastle.openpgp.PGPSignatureGenerator,java.nio.file.Path,java.nio.file.Path):void",282,"resource of type `java.io.FileInputStream` acquired by call to `FileInputStream(...)` at line 272 is not released after line 282.
**Note**: potential exception at line 276",https://github.com/jreleaser/jreleaser/blob/v1.7.0/sdks/jreleaser-signing-java-sdk/src/main/java/org/jreleaser/sdk/signing/SigningUtils.java,"public static void sign(JReleaserContext context, PGPSignatureGenerator signatureGenerator, Path input, Path output) throws SigningException {
        context.getLogger().info(""{}"", context.relativizeToBasedir(input));

        if (null == signatureGenerator) return;

        PGPCompressedDataGenerator compressionStreamGenerator = new PGPCompressedDataGenerator(UNCOMPRESSED);
        try (OutputStream out = createOutputStream(context, output);
             BCPGOutputStream bOut = new BCPGOutputStream(compressionStreamGenerator.open(out));
             FileInputStream in = new FileInputStream(input.toFile())) {

            byte[] buffer = new byte[8192];
            int length = 0;
            while ((length = in.read(buffer)) >= 0) {
                signatureGenerator.update(buffer, 0, length);
            }

            signatureGenerator.generate().encode(bOut);
            compressionStreamGenerator.close();
        } catch (IOException | PGPException e) {
            throw new SigningException(RB.$(""ERROR_unexpected_error_signing"", input.toAbsolutePath()), e);
        }
    }",1
jreleaser-1.7.0,RESOURCE_LEAK,plugins/jreleaser-maven-plugin/src/main/java/org/jreleaser/maven/plugin/JReleaserAutoConfigReleaseMojo.java,org.jreleaser.maven.plugin.JReleaserAutoConfigReleaseMojo.createTracer():java.io.PrintWriter,327,resource of type `java.io.FileOutputStream` acquired by call to `FileOutputStream(...)` at line 328 is not released after line 327.,https://github.com/jreleaser/jreleaser/blob/v1.7.0/plugins/jreleaser-maven-plugin/src/main/java/org/jreleaser/maven/plugin/JReleaserAutoConfigReleaseMojo.java,"private PrintWriter createTracer() throws MojoExecutionException {
        try {
            java.nio.file.Files.createDirectories(outputDirectory.toPath());
            return newPrintWriter(new FileOutputStream(
                outputDirectory.toPath().resolve(""trace.log"").toFile()));
        } catch (IOException e) {
            throw new MojoExecutionException(""Could not initialize trace file"", e);
        }
    }",1
jreleaser-1.7.0,RESOURCE_LEAK,plugins/jreleaser-ant-tasks/src/main/java/org/jreleaser/ant/tasks/JReleaserAutoConfigReleaseTask.java,org.jreleaser.ant.tasks.JReleaserAutoConfigReleaseTask.createTracer():java.io.PrintWriter,363,resource of type `java.io.FileOutputStream` acquired by call to `FileOutputStream(...)` at line 364 is not released after line 363.,https://github.com/jreleaser/jreleaser/blob/v1.7.0/plugins/jreleaser-ant-tasks/src/main/java/org/jreleaser/ant/tasks/JReleaserAutoConfigReleaseTask.java,"private PrintWriter createTracer() {
        try {
            Files.createDirectories(getOutputDirectory());
            return newPrintWriter(new FileOutputStream(
                getOutputDirectory().resolve(""trace.log"").toFile()));
        } catch (IOException e) {
            throw new IllegalStateException(""Could not initialize trace file"", e);
        }
    }",1
jsoup 1.16.1,RESOURCE_LEAK,src/main/java/org/jsoup/helper/DataUtil.java,"org.jsoup.helper.DataUtil.load(java.io.File,java.lang.String,java.lang.String,org.jsoup.parser.Parser):org.jsoup.nodes.Document",95,resource of type `java.io.FileInputStream` acquired by call to `FileInputStream(...)` at line 95 is not released after line 95.,"83: public static Document load(File file, @Nullable String charsetName, String baseUri, Parser parser) throws IOException {
 84: InputStream stream = new FileInputStream(file);
 85: String name = Normalizer.lowerCase(file.getName());
 86: if (name.endsWith("".gz"") || name.endsWith("".z"")) {
 87: // unfortunately file input streams don't support marks (why not?), so we will close and reopen after read
 88: boolean zipped;
 89: try {
 90: zipped = (stream.read() == 0x1f && stream.read() == 0x8b); // gzip magic bytes
 91: } finally {
 92: stream.close();
 93: 
 94: }
 95: stream = zipped ? new GZIPInputStream(new FileInputStream(file)) : new FileInputStream(file);
 96: }
 97: return parseInputStream(stream, charsetName, baseUri, parser);","public static Document load(File file, @Nullable String charsetName, String baseUri, Parser parser) throws IOException {
        InputStream stream = new FileInputStream(file);
        String name = Normalizer.lowerCase(file.getName());
        if (name.endsWith("".gz"") || name.endsWith("".z"")) {
            // unfortunately file input streams don't support marks (why not?), so we will close and reopen after read
            boolean zipped;
            try {
                zipped = (stream.read() == 0x1f && stream.read() == 0x8b); // gzip magic bytes
            } finally {
                stream.close();

            }
            stream = zipped ? new GZIPInputStream(new FileInputStream(file)) : new FileInputStream(file);
        }
        return parseInputStream(stream, charsetName, baseUri, parser);
    }",1
azure-maven-plugins-2.2.2,NULL_DEREFERENCE,azure-toolkit-libs/azure-toolkit-common-lib/src/main/java/com/microsoft/azure/toolkit/lib/common/form/Validatable.java,com.microsoft.azure.toolkit.lib.common.form.Validatable.doValidate():com.microsoft.azure.toolkit.lib.common.form.AzureValidationInfo,15,object `validator` last assigned on line 13 could be null and is dereferenced at line 15.,https://github.com/microsoft/azure-maven-plugins/blob/azure-webapp-maven-plugin-v2.2.2/azure-toolkit-libs/azure-toolkit-common-lib/src/main/java/com/microsoft/azure/toolkit/lib/common/form/Validatable.java,"public interface Validatable {
    default AzureValidationInfo doValidate() {
        final Validator validator = this.getValidator();
        if (Objects.nonNull(validator)) {
            return validator.doValidate();
        }
        return AzureValidationInfo.OK;
    }

    @Nullable
    default Validator getValidator() {
        return null;
    }

    @FunctionalInterface
    interface Validator {
        AzureValidationInfo doValidate();
    }
}",0
azure-maven-plugins-2.2.2,NULL_DEREFERENCE,azure-toolkit-libs/azure-toolkit-appservice-lib/src/main/java/com/microsoft/azure/toolkit/lib/appservice/utils/AppServiceConfigUtils.java,"com.microsoft.azure.toolkit.lib.appservice.utils.AppServiceConfigUtils.fromAppService(com.microsoft.azure.toolkit.lib.appservice.service.impl.FunctionApp,com.microsoft.azure.toolkit.lib.appservice.service.impl.AppServicePlan):com.microsoft.azure.toolkit.lib.appservice.config.AppServiceConfig",54,object returned by `appService.getRuntime()` could be null and is dereferenced at line 54.,https://github.com/microsoft/azure-maven-plugins/blob/azure-webapp-maven-plugin-v2.2.2/azure-toolkit-libs/azure-toolkit-appservice-lib/src/main/java/com/microsoft/azure/toolkit/lib/appservice/utils/AppServiceConfigUtils.java,"public static AppServiceConfig fromAppService(IAppService<?> appService, IAppServicePlan servicePlan) {
        AppServiceConfig config = new AppServiceConfig();
        config.appName(appService.name());

        config.resourceGroup(appService.entity().getResourceGroup());
        config.subscriptionId(Utils.getSubscriptionId(appService.id()));
        config.region(appService.entity().getRegion());
        config.pricingTier(servicePlan.entity().getPricingTier());
        RuntimeConfig runtimeConfig = new RuntimeConfig();
        if (AppServiceUtils.isDockerAppService(appService)) {
            runtimeConfig.os(OperatingSystem.DOCKER);
            final Map<String, String> settings = appService.entity().getAppSettings();

            final String imageSetting = settings.get(SETTING_DOCKER_IMAGE);
            if (StringUtils.isNotBlank(imageSetting)) {
                runtimeConfig.image(imageSetting);
            } else {
                runtimeConfig.image(appService.entity().getDockerImageName());
            }
            final String registryServerSetting = settings.get(SETTING_REGISTRY_SERVER);
            if (StringUtils.isNotBlank(registryServerSetting)) {
                runtimeConfig.registryUrl(registryServerSetting);
            }
        } else {
            runtimeConfig.os(appService.getRuntime().getOperatingSystem());
            runtimeConfig.webContainer(appService.getRuntime().getWebContainer());
            runtimeConfig.javaVersion(appService.getRuntime().getJavaVersion());
        }
        config.runtime(runtimeConfig);
        if (servicePlan.entity() != null) {
            config.pricingTier(servicePlan.entity().getPricingTier());
            config.servicePlanName(servicePlan.name());
            config.servicePlanResourceGroup(servicePlan.entity().getResourceGroup());
        }
        return config;
    }",1
azure-maven-plugins-2.2.2,NULL_DEREFERENCE,azure-toolkit-libs/azure-toolkit-appservice-lib/src/main/java/com/microsoft/azure/toolkit/lib/appservice/utils/AppServiceConfigUtils.java,"com.microsoft.azure.toolkit.lib.appservice.utils.AppServiceConfigUtils.fromAppService(com.microsoft.azure.toolkit.lib.appservice.service.impl.WebApp,com.microsoft.azure.toolkit.lib.appservice.service.impl.AppServicePlan):com.microsoft.azure.toolkit.lib.appservice.config.AppServiceConfig",54,object returned by `getRuntime(appService)` could be null and is dereferenced at line 54.,https://github.com/microsoft/azure-maven-plugins/blob/azure-webapp-maven-plugin-v2.2.2/azure-toolkit-libs/azure-toolkit-appservice-lib/src/main/java/com/microsoft/azure/toolkit/lib/appservice/utils/AppServiceConfigUtils.java,"public static AppServiceConfig fromAppService(IAppService<?> appService, IAppServicePlan servicePlan) {
        AppServiceConfig config = new AppServiceConfig();
        config.appName(appService.name());

        config.resourceGroup(appService.entity().getResourceGroup());
        config.subscriptionId(Utils.getSubscriptionId(appService.id()));
        config.region(appService.entity().getRegion());
        config.pricingTier(servicePlan.entity().getPricingTier());
        RuntimeConfig runtimeConfig = new RuntimeConfig();
        if (AppServiceUtils.isDockerAppService(appService)) {
            runtimeConfig.os(OperatingSystem.DOCKER);
            final Map<String, String> settings = appService.entity().getAppSettings();

            final String imageSetting = settings.get(SETTING_DOCKER_IMAGE);
            if (StringUtils.isNotBlank(imageSetting)) {
                runtimeConfig.image(imageSetting);
            } else {
                runtimeConfig.image(appService.entity().getDockerImageName());
            }
            final String registryServerSetting = settings.get(SETTING_REGISTRY_SERVER);
            if (StringUtils.isNotBlank(registryServerSetting)) {
                runtimeConfig.registryUrl(registryServerSetting);
            }
        } else {
            runtimeConfig.os(appService.getRuntime().getOperatingSystem());
            runtimeConfig.webContainer(appService.getRuntime().getWebContainer());
            runtimeConfig.javaVersion(appService.getRuntime().getJavaVersion());
        }
        config.runtime(runtimeConfig);
        if (servicePlan.entity() != null) {
            config.pricingTier(servicePlan.entity().getPricingTier());
            config.servicePlanName(servicePlan.name());
            config.servicePlanResourceGroup(servicePlan.entity().getResourceGroup());
        }
        return config;
    }",1
azure-maven-plugins-2.2.2,NULL_DEREFERENCE,azure-toolkit-libs/azure-toolkit-appservice-lib/src/main/java/com/microsoft/azure/toolkit/lib/appservice/task/CreateOrUpdateAppServicePlanTask.java,com.microsoft.azure.toolkit.lib.appservice.task.CreateOrUpdateAppServicePlanTask.execute():com.microsoft.azure.toolkit.lib.appservice.service.IAppServicePlan,50,object returned by `appServicePlan.entity()` could be null and is dereferenced at line 50.,https://github.com/microsoft/azure-maven-plugins/blob/azure-webapp-maven-plugin-v2.2.2/azure-toolkit-libs/azure-toolkit-appservice-lib/src/main/java/com/microsoft/azure/toolkit/lib/appservice/task/CreateOrUpdateAppServicePlanTask.java,"public IAppServicePlan execute() {
        SchemaValidator.getInstance().validateAndThrow(""appservice/AppServicePlan"", config);
        final AzureAppService az = Azure.az(AzureAppService.class).subscription(config.subscriptionId());
        final IAppServicePlan appServicePlan = az.appServicePlan(config.servicePlanResourceGroup(), config.servicePlanName());
        final String servicePlanName = config.servicePlanName();
        if (!appServicePlan.exists()) {
            SchemaValidator.getInstance().validateAndThrow(""appservice/CreateAppServicePlan"", config);
            AzureMessager.getMessager().info(String.format(CREATE_APP_SERVICE_PLAN, servicePlanName));
            AzureTelemetry.getActionContext().setProperty(CREATE_NEW_APP_SERVICE_PLAN, String.valueOf(true));
            new CreateResourceGroupTask(this.config.subscriptionId(), config.servicePlanResourceGroup(), config.region()).execute();
            appServicePlan.create()
                .withName(servicePlanName)
                .withResourceGroup(config.servicePlanResourceGroup())
                .withPricingTier(config.pricingTier())
                .withRegion(config.region())
                .withOperatingSystem(config.os())
                .commit();
            AzureMessager.getMessager().info(String.format(CREATE_APP_SERVICE_PLAN_DONE, appServicePlan.name()));
        } else {
            if (config.region() != null && !Objects.equals(config.region(), Region.fromName(appServicePlan.entity().getRegion()))) {
                AzureMessager.getMessager().warning(String.format(""Skip region update for existing service plan '%s' since it is not allowed."",
                    appServicePlan.name()));
            }
            if (config.pricingTier() != null && !Objects.equals(config.pricingTier(), appServicePlan.entity().getPricingTier())) {
                // apply pricing tier to service plan
                appServicePlan.update().withPricingTier(config.pricingTier()).commit();
            }
        }

        return appServicePlan;
    }",1
azure-maven-plugins-2.2.2,NULL_DEREFERENCE,azure-toolkit-libs/azure-toolkit-appservice-lib/src/main/java/com/microsoft/azure/toolkit/lib/appservice/task/CreateOrUpdateAppServicePlanTask.java,com.microsoft.azure.toolkit.lib.appservice.task.CreateOrUpdateAppServicePlanTask.execute():com.microsoft.azure.toolkit.lib.appservice.service.IAppServicePlan,54,object returned by `appServicePlan.entity()` could be null and is dereferenced at line 54.,https://github.com/microsoft/azure-maven-plugins/blob/azure-webapp-maven-plugin-v2.2.2/azure-toolkit-libs/azure-toolkit-appservice-lib/src/main/java/com/microsoft/azure/toolkit/lib/appservice/task/CreateOrUpdateAppServicePlanTask.java,"public IAppServicePlan execute() {
        SchemaValidator.getInstance().validateAndThrow(""appservice/AppServicePlan"", config);
        final AzureAppService az = Azure.az(AzureAppService.class).subscription(config.subscriptionId());
        final IAppServicePlan appServicePlan = az.appServicePlan(config.servicePlanResourceGroup(), config.servicePlanName());
        final String servicePlanName = config.servicePlanName();
        if (!appServicePlan.exists()) {
            SchemaValidator.getInstance().validateAndThrow(""appservice/CreateAppServicePlan"", config);
            AzureMessager.getMessager().info(String.format(CREATE_APP_SERVICE_PLAN, servicePlanName));
            AzureTelemetry.getActionContext().setProperty(CREATE_NEW_APP_SERVICE_PLAN, String.valueOf(true));
            new CreateResourceGroupTask(this.config.subscriptionId(), config.servicePlanResourceGroup(), config.region()).execute();
            appServicePlan.create()
                .withName(servicePlanName)
                .withResourceGroup(config.servicePlanResourceGroup())
                .withPricingTier(config.pricingTier())
                .withRegion(config.region())
                .withOperatingSystem(config.os())
                .commit();
            AzureMessager.getMessager().info(String.format(CREATE_APP_SERVICE_PLAN_DONE, appServicePlan.name()));
        } else {
            if (config.region() != null && !Objects.equals(config.region(), Region.fromName(appServicePlan.entity().getRegion()))) {
                AzureMessager.getMessager().warning(String.format(""Skip region update for existing service plan '%s' since it is not allowed."",
                    appServicePlan.name()));
            }
            if (config.pricingTier() != null && !Objects.equals(config.pricingTier(), appServicePlan.entity().getPricingTier())) {
                // apply pricing tier to service plan
                appServicePlan.update().withPricingTier(config.pricingTier()).commit();
            }
        }

        return appServicePlan;
    }",1
azure-maven-plugins-2.2.2,NULL_DEREFERENCE,azure-toolkit-libs/azure-toolkit-resource-lib/src/main/java/com/microsoft/azure/toolkit/lib/resource/AzureGroup.java,com.microsoft.azure.toolkit.lib.resource.AzureGroup.list(boolean[]):java.util.List,34,object returned by `getSubscriptions()` could be null and is dereferenced at line 34.,https://github.com/microsoft/azure-maven-plugins/blob/azure-webapp-maven-plugin-v2.2.2/azure-toolkit-libs/azure-toolkit-resource-lib/src/main/java/com/microsoft/azure/toolkit/lib/resource/AzureGroup.java,"public List<ResourceGroup> list(boolean... force) {
        return getSubscriptions().stream().parallel()
                .flatMap(s -> list(s.getId(), force).stream())
                .collect(Collectors.toList());
    }",1
azure-maven-plugins-2.2.2,NULL_DEREFERENCE,azure-maven-plugin-lib/src/main/java/com/microsoft/azure/maven/utils/TemplateUtils.java,"com.microsoft.azure.maven.utils.TemplateUtils.evalText(java.lang.String,java.util.HashMap):java.lang.String",39,"object returned by `evalPlainText(expr,variableMap)` could be null and is dereferenced at line 39.",https://github.com/microsoft/azure-maven-plugins/blob/azure-webapp-maven-plugin-v2.2.2/azure-maven-plugin-lib/src/main/java/com/microsoft/azure/maven/utils/TemplateUtils.java,"public static String evalText(String expr, Map<String, Object> variableMap) {
        // convert *** to blue color
        return evalPlainText(expr, variableMap).replaceAll(""\\*\\*\\*(.*?)\\*\\*\\*"", TextUtils.blue(""$1""));
    }",1
azure-maven-plugins-2.2.2,NULL_DEREFERENCE,azure-toolkit-libs/azure-toolkit-redis-lib/src/main/java/com/microsoft/azure/toolkit/redis/AzureRedis.java,com.microsoft.azure.toolkit.redis.AzureRedis.list():java.util.List,40,object returned by `getSubscriptions()` could be null and is dereferenced at line 40.,https://github.com/microsoft/azure-maven-plugins/blob/azure-webapp-maven-plugin-v2.2.2/azure-toolkit-libs/azure-toolkit-redis-lib/src/main/java/com/microsoft/azure/toolkit/redis/AzureRedis.java,"public List<RedisCache> list() {
        return getSubscriptions().stream()
            .map(subscription -> RedisManagerFactory.create(subscription.getId()))
            .flatMap(manager -> manager.redisCaches().list().stream())
            .map(redis -> new RedisCache(redis.manager(), redis))
            .collect(Collectors.toList());
    }",1
azure-maven-plugins-2.2.2,NULL_DEREFERENCE,azure-toolkit-libs/azure-toolkit-mysql-lib/src/main/java/com/microsoft/azure/toolkit/lib/mysql/AzureMySql.java,com.microsoft.azure.toolkit.lib.mysql.AzureMySql.list():java.util.List,44,object returned by `getSubscriptions()` could be null and is dereferenced at line 44.,https://github.com/microsoft/azure-maven-plugins/blob/azure-webapp-maven-plugin-v2.2.2/azure-toolkit-libs/azure-toolkit-mysql-lib/src/main/java/com/microsoft/azure/toolkit/lib/mysql/AzureMySql.java,"public List<MySqlServer> list() {
        return getSubscriptions().stream()
            .map(subscription -> MySqlManagerFactory.create(subscription.getId()))
            .flatMap(manager -> manager.servers().list().stream().map(server -> new MySqlServer(manager, server)))
            .collect(Collectors.toList());
    }",1
azure-maven-plugins-2.2.2,NULL_DEREFERENCE,azure-toolkit-libs/azure-toolkit-compute-lib/src/main/java/com/microsoft/azure/toolkit/lib/compute/AbstractAzureResourceModule.java,com.microsoft.azure.toolkit.lib.compute.AbstractAzureResourceModule.list():java.util.List,45,object returned by `getSubscriptions()` could be null and is dereferenced at line 45.,https://github.com/microsoft/azure-maven-plugins/blob/azure-webapp-maven-plugin-v2.2.2/azure-toolkit-libs/azure-toolkit-compute-lib/src/main/java/com/microsoft/azure/toolkit/lib/compute/AbstractAzureResourceModule.java,"public List<T> list() {
        return getSubscriptions().stream().parallel()
                .flatMap(subscription -> list(subscription.getId()).stream())
                .collect(Collectors.toList());
    }",1
azure-maven-plugins-2.2.2,NULL_DEREFERENCE,azure-toolkit-libs/azure-toolkit-common-lib/src/main/java/com/microsoft/azure/toolkit/lib/common/bundle/AzureString.java,com.microsoft.azure.toolkit.lib.common.bundle.AzureString.getString(java.lang.Object[]):java.lang.String,50,object `AzureString.bundle` last accessed on line 50 could be null and is dereferenced at line 50.,https://github.com/microsoft/azure-maven-plugins/blob/azure-webapp-maven-plugin-v2.2.2/azure-toolkit-libs/azure-toolkit-common-lib/src/main/java/com/microsoft/azure/toolkit/lib/common/bundle/AzureString.java,"public String getString(Object... params) {
        final String pattern = Objects.nonNull(bundle) ? bundle.pattern(name) : name;
        try {
            if (StringUtils.isBlank(pattern)) {
                return String.format(""!%s!"", name);
            }
            if (pattern.contains(""{0}"")) {
                return MessageFormat.format(pattern, params);
            }
            return String.format(pattern, params);
        } catch (final IllegalArgumentException e) {
            return pattern;
        }
    }",0
azure-maven-plugins-2.2.2,NULL_DEREFERENCE,azure-toolkit-libs/azure-toolkit-common-lib/src/main/java/com/microsoft/azure/toolkit/lib/common/messager/IAzureMessage.java,"com.microsoft.azure.toolkit.lib.common.messager.IAzureMessage.decorateValue(com.microsoft.azure.toolkit.lib.common.bundle.CustomDecoratable,com.microsoft.azure.toolkit.lib.common.messager.IAzureMessage$Lambda$_4_8):java.lang.String",56,object `dft` could be null and is dereferenced at line 56.,https://github.com/microsoft/azure-maven-plugins/blob/azure-webapp-maven-plugin-v2.2.2/azure-toolkit-libs/azure-toolkit-common-lib/src/main/java/com/microsoft/azure/toolkit/lib/common/messager/IAzureMessage.java,"default String decorateValue(@Nonnull Object p, @Nullable Supplier<String> dft) {
        String result = null;
        if (p instanceof CustomDecoratable) {
            result = ((CustomDecoratable) p).decorate(this);
        }
        return Objects.isNull(result) && Objects.nonNull(dft) ? dft.get() : result;
    }",0
azure-maven-plugins-2.2.2,NULL_DEREFERENCE,azure-toolkit-libs/azure-toolkit-sqlserver-lib/src/main/java/com/microsoft/azure/toolkit/lib/sqlserver/AzureSqlServer.java,com.microsoft.azure.toolkit.lib.sqlserver.AzureSqlServer.list():java.util.List,55,object returned by `getSubscriptions()` could be null and is dereferenced at line 55.,https://github.com/microsoft/azure-maven-plugins/blob/azure-webapp-maven-plugin-v2.2.2/azure-toolkit-libs/azure-toolkit-sqlserver-lib/src/main/java/com/microsoft/azure/toolkit/lib/sqlserver/AzureSqlServer.java,"public List<SqlServer> list() {
        return getSubscriptions().stream()
                .map(subscription -> SqlServerManagerFactory.create(subscription.getId()))
                .flatMap(manager -> manager.sqlServers().list().stream())
                .collect(Collectors.toList()).stream()
                .map(remote -> new SqlServer(remote.manager(), remote))
                .collect(Collectors.toList());
    }",1
azure-maven-plugins-2.2.2,NULL_DEREFERENCE,azure-toolkit-libs/azure-toolkit-storage-lib/src/main/java/com/microsoft/azure/toolkit/lib/storage/service/AzureStorageAccount.java,com.microsoft.azure.toolkit.lib.storage.service.AzureStorageAccount.list():java.util.List,55,object returned by `getSubscriptions()` could be null and is dereferenced at line 55.,https://github.com/microsoft/azure-maven-plugins/blob/azure-webapp-maven-plugin-v2.2.2/azure-toolkit-libs/azure-toolkit-storage-lib/src/main/java/com/microsoft/azure/toolkit/lib/storage/service/AzureStorageAccount.java,"public List<StorageAccount> list() {
        return getSubscriptions().stream()
                .flatMap(s -> list(s.getId()).stream())
                .collect(Collectors.toList());
    }",1
azure-maven-plugins-2.2.2,NULL_DEREFERENCE,azure-spring-cloud-maven-plugin/src/main/java/com/microsoft/azure/maven/springcloud/DeployMojo.java,com.microsoft.azure.maven.springcloud.DeployMojo.doExecute():void,73,object `deployment` last assigned on line 71 could be null and is dereferenced at line 73.,https://github.com/microsoft/azure-maven-plugins/blob/azure-webapp-maven-plugin-v2.2.2/azure-spring-cloud-maven-plugin/src/main/java/com/microsoft/azure/maven/springcloud/DeployMojo.java,"protected void doExecute() {
        // set up account and select subscription here in `deploy`, since in some cases, `config` will not need to sign in
        getAzureAccount();
        selectSubscription();

        // Init spring clients, and prompt users to confirm
        final SpringCloudAppConfig appConfig = this.getConfiguration();
        final DeploySpringCloudAppTask task = new DeploySpringCloudAppTask(appConfig);

        final List<AzureTask<?>> tasks = task.getSubTasks();
        final boolean shouldSkipConfirm = !prompt || (this.settings != null && !this.settings.isInteractiveMode());
        if (!shouldSkipConfirm && !this.confirm(tasks)) {
            log.warn(""Deployment is cancelled!"");
            return;
        }
        final SpringCloudDeployment deployment = task.execute();
        if (!noWait) {
            if (!deployment.waitUntilReady(GET_STATUS_TIMEOUT)) {
                log.warn(GET_DEPLOYMENT_STATUS_TIMEOUT);
            }
        }
        printStatus(deployment);
        printPublicUrl(deployment.app());
    }",1
azure-maven-plugins-2.2.2,NULL_DEREFERENCE,azure-spring-cloud-maven-plugin/src/main/java/com/microsoft/azure/maven/springcloud/DeployMojo.java,com.microsoft.azure.maven.springcloud.DeployMojo.doExecute():void,78,object `deployment` last assigned on line 71 could be null and is dereferenced at line 78.,https://github.com/microsoft/azure-maven-plugins/blob/azure-webapp-maven-plugin-v2.2.2/azure-spring-cloud-maven-plugin/src/main/java/com/microsoft/azure/maven/springcloud/DeployMojo.java,"protected void doExecute() {
        // set up account and select subscription here in `deploy`, since in some cases, `config` will not need to sign in
        getAzureAccount();
        selectSubscription();

        // Init spring clients, and prompt users to confirm
        final SpringCloudAppConfig appConfig = this.getConfiguration();
        final DeploySpringCloudAppTask task = new DeploySpringCloudAppTask(appConfig);

        final List<AzureTask<?>> tasks = task.getSubTasks();
        final boolean shouldSkipConfirm = !prompt || (this.settings != null && !this.settings.isInteractiveMode());
        if (!shouldSkipConfirm && !this.confirm(tasks)) {
            log.warn(""Deployment is cancelled!"");
            return;
        }
        final SpringCloudDeployment deployment = task.execute();
        if (!noWait) {
            if (!deployment.waitUntilReady(GET_STATUS_TIMEOUT)) {
                log.warn(GET_DEPLOYMENT_STATUS_TIMEOUT);
            }
        }
        printStatus(deployment);
        printPublicUrl(deployment.app());
    }",1
azure-maven-plugins-2.2.2,NULL_DEREFERENCE,azure-toolkit-libs/azure-toolkit-common-lib/src/main/java/com/microsoft/azure/toolkit/lib/common/messager/IAzureMessage.java,"com.microsoft.azure.toolkit.lib.common.messager.IAzureMessage.decorateText(com.microsoft.azure.toolkit.lib.common.bundle.AzureString,com.microsoft.azure.toolkit.lib.common.messager.AzureMessage$Lambda$_22_20):java.lang.String",74,object `dft` could be null and is dereferenced at line 74.,https://github.com/microsoft/azure-maven-plugins/blob/azure-webapp-maven-plugin-v2.2.2/azure-toolkit-libs/azure-toolkit-common-lib/src/main/java/com/microsoft/azure/toolkit/lib/common/messager/IAzureMessage.java,"default String decorateText(@Nonnull AzureString text, @Nullable Supplier<String> dft) {
        String result = null;
        if (text instanceof CustomDecoratable) {
            result = ((CustomDecoratable) text).decorate(this);
        }
        if (Objects.isNull(result)) {
            final Object[] params = Arrays.stream(text.getParams())
                    .map((p) -> this.decorateValue(p, p::toString))
                    .toArray();
            result = text.getString(params);
        }
        return Objects.isNull(result) && Objects.nonNull(dft) ? dft.get() : result;
    }",0
azure-maven-plugins-2.2.2,NULL_DEREFERENCE,azure-toolkit-libs/azure-toolkit-common-lib/src/main/java/com/microsoft/azure/toolkit/lib/SubscriptionScoped.java,com.microsoft.azure.toolkit.lib.SubscriptionScoped.getDefaultSubscription():com.microsoft.azure.toolkit.lib.common.model.Subscription,66,object returned by `getSubscriptions()` could be null and is dereferenced at line 66.,https://github.com/microsoft/azure-maven-plugins/blob/azure-webapp-maven-plugin-v2.2.2/azure-toolkit-libs/azure-toolkit-common-lib/src/main/java/com/microsoft/azure/toolkit/lib/SubscriptionScoped.java,"public Subscription getDefaultSubscription() {
        return Optional.ofNullable(CollectionUtils.size(getSubscriptions()) == 1 ? getSubscriptions().get(0) : null)
                .orElseThrow(() -> new AzureToolkitRuntimeException(""Multiple subscriptions found in current account, please set the subscription id""));
    }",0
azure-maven-plugins-2.2.2,NULL_DEREFERENCE,azure-toolkit-libs/azure-toolkit-common-lib/src/main/java/com/microsoft/azure/toolkit/lib/common/messager/AzureHtmlMessage.java,"com.microsoft.azure.toolkit.lib.common.messager.AzureHtmlMessage.decorateValue(java.lang.Object,java.util.function.Supplier):java.lang.String",74,object `dft` could be null and is dereferenced at line 74.,https://github.com/microsoft/azure-maven-plugins/blob/azure-webapp-maven-plugin-v2.2.2/azure-toolkit-libs/azure-toolkit-common-lib/src/main/java/com/microsoft/azure/toolkit/lib/common/messager/AzureHtmlMessage.java,"public String decorateValue(@Nonnull Object p, @Nullable Supplier<String> dft) {
        String result = super.decorateValue(p, null);
        if (Objects.isNull(result)) {
            final String color = getValueColor();
            final String font = ""'JetBrains Mono', Consolas, 'Liberation Mono', Menlo, Courier, monospace"";
            result = String.format(""<span style=\""color: %s;font-family: %s;\"">%s</span>"", color, font, p);
        }
        return Objects.isNull(result) && Objects.nonNull(dft) ? dft.get() : result;
    }",0
azure-maven-plugins-2.2.2,NULL_DEREFERENCE,azure-toolkit-libs/azure-toolkit-common-lib/src/main/java/com/microsoft/azure/toolkit/lib/common/action/Action.java,com.microsoft.azure.toolkit.lib.common.action.Action.view(java.lang.Object):com.microsoft.azure.toolkit.lib.common.view.IView$Label,74,object `Action.view` last accessed on line 74 could be null and is dereferenced at line 74.,https://github.com/microsoft/azure-maven-plugins/blob/azure-webapp-maven-plugin-v2.2.2/azure-toolkit-libs/azure-toolkit-common-lib/src/main/java/com/microsoft/azure/toolkit/lib/common/action/Action.java,"public IView.Label view(D source) {
        return Objects.nonNull(this.view) ? this.view.toActionView(source) : null;
    }",0
azure-maven-plugins-2.2.2,NULL_DEREFERENCE,azure-toolkit-libs/azure-toolkit-springcloud-lib/src/main/java/com/microsoft/azure/toolkit/lib/springcloud/AzureSpringCloud.java,com.microsoft.azure.toolkit.lib.springcloud.AzureSpringCloud.clusters():java.util.List,75,object returned by `getSubscriptions()` could be null and is dereferenced at line 75.,https://github.com/microsoft/azure-maven-plugins/blob/azure-webapp-maven-plugin-v2.2.2/azure-toolkit-libs/azure-toolkit-springcloud-lib/src/main/java/com/microsoft/azure/toolkit/lib/springcloud/AzureSpringCloud.java,"public List<SpringCloudCluster> clusters() {
        return this.getSubscriptions().stream().parallel()
                .flatMap(s -> clusters(s.getId()).stream())
                .collect(Collectors.toList());
    }",1
azure-maven-plugins-2.2.2,NULL_DEREFERENCE,azure-toolkit-libs/azure-toolkit-appservice-lib/src/main/java/com/microsoft/azure/toolkit/lib/appservice/AzureAppService.java,com.microsoft.azure.toolkit.lib.appservice.AzureAppService.functionApps(boolean[]):java.util.List,82,object returned by `getSubscriptions()` could be null and is dereferenced at line 82.,https://github.com/microsoft/azure-maven-plugins/blob/azure-webapp-maven-plugin-v2.2.2/azure-toolkit-libs/azure-toolkit-appservice-lib/src/main/java/com/microsoft/azure/toolkit/lib/appservice/AzureAppService.java,"public List<IFunctionApp> functionApps(boolean... force) {
        return getSubscriptions().stream().parallel()
                .flatMap(subscription -> functionApps(subscription.getId(), force).stream())
                .collect(Collectors.toList());
    }",1
azure-maven-plugins-2.2.2,NULL_DEREFERENCE,azure-toolkit-libs/azure-toolkit-redis-lib/src/main/java/com/microsoft/azure/toolkit/redis/AzureRedis.java,com.microsoft.azure.toolkit.redis.AzureRedis$Creator.commit():com.microsoft.azure.toolkit.redis.RedisCache,95,object `withCreate` last assigned on line 86 could be null and is dereferenced at line 95.,https://github.com/microsoft/azure-maven-plugins/blob/azure-webapp-maven-plugin-v2.2.2/azure-toolkit-libs/azure-toolkit-redis-lib/src/main/java/com/microsoft/azure/toolkit/redis/AzureRedis.java,"public RedisCache commit() {
            final com.azure.resourcemanager.redis.models.RedisCache.DefinitionStages.WithSku toCreate =
                RedisManagerFactory.create(config.getSubscription().getId()).redisCaches().define(config.getName())
                .withRegion(config.getRegion().getName())
                .withExistingResourceGroup(config.getResourceGroup().getName());
            com.azure.resourcemanager.redis.models.RedisCache.DefinitionStages.WithCreate withCreate = null;
            if (config.getPricingTier().isBasic()) {
                withCreate = toCreate.withBasicSku(config.getPricingTier().getSize());
            } else if (config.getPricingTier().isStandard()) {
                withCreate = toCreate.withStandardSku(config.getPricingTier().getSize());
            } else if (config.getPricingTier().isPremium()) {
                withCreate = toCreate.withPremiumSku(config.getPricingTier().getSize());
            }
            if (config.isEnableNonSslPort()) {
                withCreate = withCreate.withNonSslPort();
            }
            final com.azure.resourcemanager.redis.models.RedisCache redisCache = withCreate.create();
            return new RedisCache(redisCache.manager(), redisCache);
        }",1
azure-maven-plugins-2.2.2,NULL_DEREFERENCE,azure-toolkit-libs/azure-toolkit-redis-lib/src/main/java/com/microsoft/azure/toolkit/redis/AzureRedis.java,com.microsoft.azure.toolkit.redis.AzureRedis$Creator.commit():com.microsoft.azure.toolkit.redis.RedisCache,97,object `withCreate` last assigned on line 86 could be null and is dereferenced at line 97.,https://github.com/microsoft/azure-maven-plugins/blob/azure-webapp-maven-plugin-v2.2.2/azure-toolkit-libs/azure-toolkit-redis-lib/src/main/java/com/microsoft/azure/toolkit/redis/AzureRedis.java,"public RedisCache commit() {
            final com.azure.resourcemanager.redis.models.RedisCache.DefinitionStages.WithSku toCreate =
                RedisManagerFactory.create(config.getSubscription().getId()).redisCaches().define(config.getName())
                .withRegion(config.getRegion().getName())
                .withExistingResourceGroup(config.getResourceGroup().getName());
            com.azure.resourcemanager.redis.models.RedisCache.DefinitionStages.WithCreate withCreate = null;
            if (config.getPricingTier().isBasic()) {
                withCreate = toCreate.withBasicSku(config.getPricingTier().getSize());
            } else if (config.getPricingTier().isStandard()) {
                withCreate = toCreate.withStandardSku(config.getPricingTier().getSize());
            } else if (config.getPricingTier().isPremium()) {
                withCreate = toCreate.withPremiumSku(config.getPricingTier().getSize());
            }
            if (config.isEnableNonSslPort()) {
                withCreate = withCreate.withNonSslPort();
            }
            final com.azure.resourcemanager.redis.models.RedisCache redisCache = withCreate.create();
            return new RedisCache(redisCache.manager(), redisCache);
        }",1
azure-maven-plugins-2.2.2,NULL_DEREFERENCE,azure-spring-cloud-maven-plugin/src/main/java/com/microsoft/azure/maven/springcloud/DeployMojo.java,com.microsoft.azure.maven.springcloud.DeployMojo.lambda$confirm$0(com.microsoft.azure.toolkit.lib.common.task.AzureTask):boolean,85,object returned by `t.getTitle()` could be null and is dereferenced at line 85.,https://github.com/microsoft/azure-maven-plugins/blob/azure-webapp-maven-plugin-v2.2.2/azure-spring-cloud-maven-plugin/src/main/java/com/microsoft/azure/maven/springcloud/DeployMojo.java,"protected boolean confirm(List<AzureTask<?>> tasks) throws MojoFailureException {
        try {
            final IPrompter prompter = new DefaultPrompter();
            System.out.println(CONFIRM_PROMPT_START);
            tasks.stream().filter(t -> StringUtils.isNotBlank(t.getTitle().toString())).forEach((t) -> System.out.printf(""\t- %s%n"", t.getTitle()));
            return prompter.promoteYesNo(CONFIRM_PROMPT_CONFIRM, true, true);
        } catch (IOException e) {
            throw new MojoFailureException(e.getMessage(), e);
        }
    }",0
azure-maven-plugins-2.2.2,NULL_DEREFERENCE,azure-toolkit-libs/azure-toolkit-applicationinsights-lib/src/main/java/com/microsoft/azure/toolkit/lib/applicationinsights/ApplicationInsights.java,com.microsoft.azure.toolkit.lib.applicationinsights.ApplicationInsights.list():java.util.List,86,object returned by `getSubscriptions()` could be null and is dereferenced at line 86.,https://github.com/microsoft/azure-maven-plugins/blob/azure-webapp-maven-plugin-v2.2.2/azure-toolkit-libs/azure-toolkit-applicationinsights-lib/src/main/java/com/microsoft/azure/toolkit/lib/applicationinsights/ApplicationInsights.java,"public List<ApplicationInsightsEntity> list() {
        return getSubscriptions().stream().parallel()
                .map(subscription -> getApplicationInsightsManager(subscription.getId()))
                .flatMap(manager -> manager.components().list().stream())
                .map(ApplicationInsights::getFromApplicationInsightsComponent)
                .collect(Collectors.toList());
    }",1
azure-maven-plugins-2.2.2,NULL_DEREFERENCE,azure-toolkit-libs/azure-toolkit-springcloud-lib/src/main/java/com/microsoft/azure/toolkit/lib/springcloud/config/SpringCloudDeploymentConfig.java,com.microsoft.azure.toolkit.lib.springcloud.config.SpringCloudDeploymentConfig.fromDeployment(com.microsoft.azure.toolkit.lib.springcloud.SpringCloudDeploymentEntity):com.microsoft.azure.toolkit.lib.springcloud.config.SpringCloudDeploymentConfig,93,object `disk` last assigned on line 90 could be null and is dereferenced at line 93.,https://github.com/microsoft/azure-maven-plugins/blob/azure-webapp-maven-plugin-v2.2.2/azure-toolkit-libs/azure-toolkit-springcloud-lib/src/main/java/com/microsoft/azure/toolkit/lib/springcloud/config/SpringCloudDeploymentConfig.java,"public static SpringCloudDeploymentConfig fromDeployment(@Nonnull SpringCloudDeploymentEntity deploymentEntity) { // get config from deployment
        final List<SpringCloudDeploymentInstanceEntity> instances = deploymentEntity.getInstances();
        final SpringCloudPersistentDisk disk = deploymentEntity.getApp().getPersistentDisk();
        final SpringCloudDeploymentConfig deploymentConfig = SpringCloudDeploymentConfig.builder().build();
        deploymentConfig.setRuntimeVersion(deploymentEntity.getRuntimeVersion());
        deploymentConfig.setEnablePersistentStorage(Objects.nonNull(disk) && disk.getSizeInGB() > 0);
        deploymentConfig.setCpu(deploymentEntity.getCpu());
        deploymentConfig.setMemoryInGB(deploymentEntity.getMemoryInGB());
        deploymentConfig.setInstanceCount(instances.size());
        deploymentConfig.setJvmOptions(Optional.ofNullable(deploymentEntity.getJvmOptions()).map(String::trim).orElse(""""));
        deploymentConfig.setEnvironment(Optional.ofNullable(deploymentEntity.getEnvironmentVariables()).orElse(new HashMap<>()));
        return deploymentConfig;
    }",0
azure-maven-plugins-2.2.2,NULL_DEREFERENCE,azure-toolkit-libs/azure-toolkit-common-lib/src/main/java/com/microsoft/azure/toolkit/lib/common/messager/AzureMessage.java,"com.microsoft.azure.toolkit.lib.common.messager.AzureMessage.decorateValue(com.microsoft.azure.toolkit.lib.common.bundle.CustomDecoratable,java.util.function.Supplier):java.lang.String",95,object `dft` could be null and is dereferenced at line 95.,https://github.com/microsoft/azure-maven-plugins/blob/azure-webapp-maven-plugin-v2.2.2/azure-toolkit-libs/azure-toolkit-common-lib/src/main/java/com/microsoft/azure/toolkit/lib/common/messager/AzureMessage.java,"public String decorateValue(@Nonnull Object p, @Nullable Supplier<String> dft) {
        String result = IAzureMessage.super.decorateValue(p, null);
        if (Objects.isNull(result) && Objects.nonNull(this.valueDecorator)) {
            result = this.valueDecorator.decorateValue(p, this);
        }
        return Objects.isNull(result) && Objects.nonNull(dft) ? dft.get() : result;
    }",0
azure-maven-plugins-2.2.2,NULL_DEREFERENCE,azure-toolkit-libs/azure-toolkit-common-lib/src/main/java/com/microsoft/azure/toolkit/lib/common/bundle/AzureBundle.java,"com.microsoft.azure.toolkit.lib.common.bundle.AzureBundle.getPattern(java.lang.String,java.util.ResourceBundle):java.lang.String",100,object `bundle` could be null and is dereferenced at line 100.,https://github.com/microsoft/azure-maven-plugins/blob/azure-webapp-maven-plugin-v2.2.2/azure-toolkit-libs/azure-toolkit-common-lib/src/main/java/com/microsoft/azure/toolkit/lib/common/bundle/AzureBundle.java,"private static String getPattern(@Nonnull String key, @Nullable ResourceBundle bundle) {
        if (StringUtils.isBlank(key) || Objects.isNull(bundle)) {
            return null;
        }
        try {
            return bundle.getString(key);
        } catch (final MissingResourceException e) {
            return null;
        }
    }",0
azure-maven-plugins-2.2.2,NULL_DEREFERENCE,azure-toolkit-libs/azure-toolkit-common-lib/src/main/java/com/microsoft/azure/toolkit/lib/common/messager/AzureMessage.java,com.microsoft.azure.toolkit.lib.common.messager.AzureMessage.getCause(java.lang.Throwable):java.lang.String,110,object `root` last assigned on line 100 could be null and is dereferenced at line 110.,https://github.com/microsoft/azure-maven-plugins/blob/azure-webapp-maven-plugin-v2.2.2/azure-toolkit-libs/azure-toolkit-common-lib/src/main/java/com/microsoft/azure/toolkit/lib/common/messager/AzureMessage.java,"protected String getCause(@Nonnull Throwable throwable) {
        final Throwable root = getRecognizableCause(throwable);
        if (Objects.isNull(root)) {
            return ExceptionUtils.getRootCause(throwable).toString();
        }
        String cause = null;
        if (root instanceof ManagementException) {
            cause = ((ManagementException) root).getValue().getMessage();
        } else if (root instanceof HttpResponseException) {
            cause = ((HttpResponseException) root).getResponse().getBodyAsString().block();
        }
        final String causeMsg = StringUtils.firstNonBlank(cause, root.getMessage());
        return Optional.ofNullable(causeMsg)
                .filter(StringUtils::isNotBlank)
                .map(StringUtils::uncapitalize)
                .map(c -> c.endsWith(""."") ? c : c + '.')
                .orElse(null);
    }",0
azure-maven-plugins-2.2.2,NULL_DEREFERENCE,azure-toolkit-libs/azure-toolkit-common-lib/src/main/java/com/microsoft/azure/toolkit/lib/common/utils/NetUtils.java,com.microsoft.azure.toolkit.lib.common.utils.NetUtils.getMacsByCommand():java.util.List,104,"object returned by `getProperty(""os.name"")` could be null and is dereferenced at line 104.",https://github.com/microsoft/azure-maven-plugins/blob/azure-webapp-maven-plugin-v2.2.2/azure-toolkit-libs/azure-toolkit-common-lib/src/main/java/com/microsoft/azure/toolkit/lib/common/utils/NetUtils.java,"private static List<String> getMacsByCommand() {
        List<String> macs = new ArrayList<>();
        final StringBuilder ret = new StringBuilder();
        try {
            final String os = System.getProperty(""os.name"").toLowerCase();
            final String[] command = StringUtils.startsWithIgnoreCase(os, ""win"") ?
                    WINDOWS_COMMAND : UNIX_COMMAND;
            final ProcessBuilder probuilder = new ProcessBuilder(command);
            final Process process = probuilder.start();
            try (final InputStream inputStream = process.getInputStream();
                 final InputStreamReader inputStreamReader = new InputStreamReader(inputStream);
                 final BufferedReader br = new BufferedReader(inputStreamReader)) {
                String tmp;
                while ((tmp = br.readLine()) != null) {
                    ret.append(tmp);
                }
            }
            if (process.waitFor() != 0) {
                throw new IOException(String.format(""Command %s execute fail."", String.join("" "", command)));
            }
        } catch (IOException | InterruptedException ex) {
            return macs;
        }
        String commandMacsString = ret.toString();

        Matcher matcher = MAC_PATTERN.matcher(commandMacsString);
        while (matcher.find()) {
            String mac = matcher.group(0);
            if (isValidMac(mac)) {
                macs.add(mac);
            }
        }
        return macs;
    }",0
azure-maven-plugins-2.2.2,NULL_DEREFERENCE,azure-toolkit-libs/azure-toolkit-appservice-lib/src/main/java/com/microsoft/azure/toolkit/lib/appservice/AzureAppService.java,com.microsoft.azure.toolkit.lib.appservice.AzureAppService.webapps(boolean[]):java.util.List,122,object returned by `getSubscriptions()` could be null and is dereferenced at line 122.,https://github.com/microsoft/azure-maven-plugins/blob/azure-webapp-maven-plugin-v2.2.2/azure-toolkit-libs/azure-toolkit-appservice-lib/src/main/java/com/microsoft/azure/toolkit/lib/appservice/AzureAppService.java,"public List<IWebApp> webapps(boolean... force) {
        return getSubscriptions().stream().parallel()
                .flatMap(subscription -> webapps(subscription.getId(), force).stream())
                .collect(Collectors.toList());
    }",1
azure-maven-plugins-2.2.2,NULL_DEREFERENCE,azure-maven-plugin-lib/src/main/java/com/microsoft/azure/maven/prompt/DefaultPrompter.java,"com.microsoft.azure.maven.prompt.DefaultPrompter.lambda$promoteSingleEntity$2(java.util.List,java.lang.String):com.microsoft.azure.maven.prompt.InputValidateResult",133,object returned by `selectIndex.getObj()` could be null and is dereferenced at line 133.,https://github.com/microsoft/azure-maven-plugins/blob/azure-webapp-maven-plugin-v2.2.2/azure-maven-plugin-lib/src/main/java/com/microsoft/azure/maven/prompt/DefaultPrompter.java,"public <T> T promoteSingleEntity(String header, String message, List<T> entities, T defaultEntity, Function<T, String> getNameFunc,
            boolean isRequired) throws IOException {
        final boolean hasDefaultValue = defaultEntity != null;

        printOptionList(header, entities, defaultEntity, getNameFunc);

        final int selectedIndex = entities.indexOf(defaultEntity);

        final String defaultValueMessage = selectedIndex >= 0 ? "" ("" + TextUtils.blue(Integer.toString(selectedIndex + 1)) + "")"" : """";
        final String hintMessage = String.format(""[1-%d]%s"", entities.size(), defaultValueMessage);
        final String promoteMessage = String.format(""%s %s: "", message, hintMessage);
        System.out.print(promoteMessage);
        System.out.flush();

        return loopInput(defaultEntity, hasDefaultValue, isRequired, null, promoteMessage, input -> {
            final InputValidateResult<Integer> selectIndex = validateUserInputAsInteger(input, entities.size(),
                    String.format(""You have input a wrong value %s."", TextUtils.red(input)));
            if (selectIndex.getErrorMessage() == null) {
                return InputValidateResult.wrap(entities.get(selectIndex.getObj() - 1));
            }
            return InputValidateResult.error(selectIndex.getErrorMessage());
        });
    }",1
azure-maven-plugins-2.2.2,NULL_DEREFERENCE,azure-sfmesh-maven-plugin/src/main/java/com/microsoft/azure/maven/servicefabric/Utils.java,com.microsoft.azure.maven.servicefabric.Utils.getOS():java.lang.String,135,"object returned by `getProperty(""os.name"")` could be null and is dereferenced at line 135.",https://github.com/microsoft/azure-maven-plugins/blob/azure-webapp-maven-plugin-v2.2.2/azure-sfmesh-maven-plugin/src/main/java/com/microsoft/azure/maven/servicefabric/Utils.java,"public static String getOS(){
        return System.getProperty(""os.name"").toLowerCase();
    }",1
azure-maven-plugins-2.2.2,NULL_DEREFERENCE,azure-toolkit-libs/azure-toolkit-springcloud-lib/src/main/java/com/microsoft/azure/toolkit/lib/springcloud/SpringCloudDeployment.java,com.microsoft.azure.toolkit.lib.springcloud.SpringCloudDeployment$Modifier.configEnvironmentVariables(java.util.Map):com.microsoft.azure.toolkit.lib.springcloud.SpringCloudDeployment$Modifier,151,object `env` could be null and is dereferenced at line 151.,https://github.com/microsoft/azure-maven-plugins/blob/azure-webapp-maven-plugin-v2.2.2/azure-toolkit-libs/azure-toolkit-springcloud-lib/src/main/java/com/microsoft/azure/toolkit/lib/springcloud/SpringCloudDeployment.java,"public Modifier configEnvironmentVariables(@Nullable Map<String, String> env) {
            final Map<String, String> oldEnv = Optional.ofNullable(this.modifier.settings()).map(DeploymentSettings::environmentVariables).orElse(null);
            final boolean allEmpty = MapUtils.isEmpty(env) && MapUtils.isEmpty(oldEnv);
            if (!allEmpty && !Objects.equals(env, oldEnv) && Objects.nonNull(env)) {
                this.skippable = false;
                env.forEach((key, value) -> {
                    if (StringUtils.isBlank(value)) {
                        this.modifier.withoutEnvironment(key);
                    } else {
                        this.modifier.withEnvironment(key, value);
                    }
                });
            }
            return this;
        }",0
azure-maven-plugins-2.2.2,NULL_DEREFERENCE,azure-toolkit-libs/azure-toolkit-appservice-lib/src/main/java/com/microsoft/azure/toolkit/lib/appservice/AzureAppService.java,com.microsoft.azure.toolkit.lib.appservice.AzureAppService.appServicePlans(boolean[]):java.util.List,178,object returned by `getSubscriptions()` could be null and is dereferenced at line 178.,https://github.com/microsoft/azure-maven-plugins/blob/azure-webapp-maven-plugin-v2.2.2/azure-toolkit-libs/azure-toolkit-appservice-lib/src/main/java/com/microsoft/azure/toolkit/lib/appservice/AzureAppService.java,"public List<IAppServicePlan> appServicePlans(boolean... force) {
        return getSubscriptions().stream().parallel()
                .flatMap(subscription -> appServicePlans(subscription.getId(), force).stream())
                .collect(Collectors.toList());
    }",1
azure-maven-plugins-2.2.2,NULL_DEREFERENCE,azure-functions-maven-plugin/src/main/java/com/microsoft/azure/maven/function/DeployMojo.java,com.microsoft.azure.maven.function.DeployMojo.validateArtifactCompileVersion():void,188,object `runtimeConfig` last assigned on line 187 could be null and is dereferenced at line 188.,https://github.com/microsoft/azure-maven-plugins/blob/azure-webapp-maven-plugin-v2.2.2/azure-functions-maven-plugin/src/main/java/com/microsoft/azure/maven/function/DeployMojo.java,"protected void validateArtifactCompileVersion() throws AzureExecutionException {
        final RuntimeConfig runtimeConfig = getParser().getRuntimeConfig();
        if (runtimeConfig.os() == OperatingSystem.DOCKER) {
            return;
        }
        final JavaVersion javaVersion = Optional.ofNullable(runtimeConfig.javaVersion()).orElse(CreateOrUpdateFunctionAppTask.DEFAULT_FUNCTION_JAVA_VERSION);
        final ComparableVersion runtimeVersion = new ComparableVersion(javaVersion.getValue());
        final ComparableVersion artifactVersion = new ComparableVersion(Utils.getArtifactCompileVersion(getArtifactToDeploy()));
        if (runtimeVersion.compareTo(artifactVersion) >= 0) {
            return;
        }
        if (javaVersion.isExpandedValue()) {
            AzureMessager.getMessager().warning(AzureString.format(ARTIFACT_INCOMPATIBLE_WARNING, artifactVersion.toString(), runtimeVersion.toString()));
        } else {
            final String errorMessage = AzureString.format(ARTIFACT_INCOMPATIBLE_ERROR, artifactVersion.toString(), runtimeVersion.toString()).toString();
            throw new AzureExecutionException(errorMessage);
        }
    }",1
azure-maven-plugins-2.2.2,NULL_DEREFERENCE,azure-toolkit-libs/azure-toolkit-appservice-lib/src/main/java/com/microsoft/azure/toolkit/lib/appservice/AzureAppService.java,"com.microsoft.azure.toolkit.lib.appservice.AzureAppService.appServicePlansByResourceGroup(java.lang.String,boolean[]):java.util.List",195,object returned by `getSubscriptions()` could be null and is dereferenced at line 195.,https://github.com/microsoft/azure-maven-plugins/blob/azure-webapp-maven-plugin-v2.2.2/azure-toolkit-libs/azure-toolkit-appservice-lib/src/main/java/com/microsoft/azure/toolkit/lib/appservice/AzureAppService.java,"public List<IAppServicePlan> appServicePlansByResourceGroup(String rg, boolean... force) {
        return getSubscriptions().stream().parallel()
                .map(subscription -> getAppServiceManager(subscription.getId()))
                .flatMap(azureResourceManager -> azureResourceManager.appServicePlans().listByResourceGroup(rg).stream()
                        .map(appServicePlan -> new AppServicePlan(appServicePlan, azureResourceManager)))
                .collect(Collectors.toList());
    }",1
azure-maven-plugins-2.2.2,NULL_DEREFERENCE,azure-spring-cloud-maven-plugin/src/main/java/com/microsoft/azure/maven/springcloud/ConfigMojo.java,com.microsoft.azure.maven.springcloud.ConfigMojo.saveConfigurationToPom():java.lang.Integer,265,object `null` is dereferenced by call to `updateAppConfigToPom(...)` at line 265.,https://github.com/microsoft/azure-maven-plugins/blob/azure-webapp-maven-plugin-v2.2.2/azure-spring-cloud-maven-plugin/src/main/java/com/microsoft/azure/maven/springcloud/ConfigMojo.java,"private Integer saveConfigurationToPom() {
        telemetries.put(TELEMETRY_KEY_POM_FILE_MODIFIED, String.valueOf(true));
        this.appSettings.setSubscriptionId(this.subscriptionId);
        try {
            for (final MavenProject proj : targetProjects) {

                if (this.parentMode) {
                    this.appSettings.setAppName(this.appNameByProject.get(proj));
                    this.appSettings.setIsPublic((publicProjects != null && publicProjects.contains(proj)) ? ""true"" : ""false"");
                }
                saveConfigurationToProject(proj);
            }
            // add plugin to parent pom
            if (this.parentMode) {
                ConfigurationUpdater.updateAppConfigToPom(null, this.project, plugin);
            }
        } catch (DocumentException | IOException e) {
            throw Lombok.sneakyThrow(e);
        }
        return targetProjects.size();
    }",0
azure-maven-plugins-2.2.2,NULL_DEREFERENCE,azure-functions-maven-plugin/src/main/java/com/microsoft/azure/maven/function/AddMojo.java,"com.microsoft.azure.maven.function.AddMojo.getStringInputFromUser(java.lang.String,java.lang.String,com.microsoft.azure.toolkit.lib.legacy.function.template.FunctionSettingTemplate):java.lang.String",301,object returned by `validator.apply(initValue)` could be null and is dereferenced at line 301.,https://github.com/microsoft/azure-maven-plugins/blob/azure-webapp-maven-plugin-v2.2.2/azure-functions-maven-plugin/src/main/java/com/microsoft/azure/maven/function/AddMojo.java,"protected String getStringInputFromUser(String attributeName, String initValue, FunctionSettingTemplate template) {
        final String defaultValue = template == null ? null : template.getDefaultValue();
        final Function<String, Boolean> validator = getStringInputValidator(template);

        if (validator.apply(initValue)) {
            Log.info(FOUND_VALID_VALUE);
            return initValue;
        }

        final Scanner scanner = getScanner();
        while (true) {
            out.printf(getStringInputPromptString(attributeName, defaultValue));
            out.flush();
            final String input = scanner.nextLine();
            if (validator.apply(input)) {
                return input;
            } else if (StringUtils.isNotEmpty(defaultValue) && StringUtils.isEmpty(input)) {
                return defaultValue;
            }
            Log.warn(getStringInputErrorMessage(template));
        }
    }",1
azure-maven-plugins-2.2.2,NULL_DEREFERENCE,azure-functions-maven-plugin/src/main/java/com/microsoft/azure/maven/function/AddMojo.java,"com.microsoft.azure.maven.function.AddMojo.getStringInputFromUser(java.lang.String,java.lang.String,com.microsoft.azure.toolkit.lib.legacy.function.template.FunctionSettingTemplate):java.lang.String",311,object returned by `validator.apply(input)` could be null and is dereferenced at line 311.,https://github.com/microsoft/azure-maven-plugins/blob/azure-webapp-maven-plugin-v2.2.2/azure-functions-maven-plugin/src/main/java/com/microsoft/azure/maven/function/AddMojo.java,"protected String getStringInputFromUser(String attributeName, String initValue, FunctionSettingTemplate template) {
        final String defaultValue = template == null ? null : template.getDefaultValue();
        final Function<String, Boolean> validator = getStringInputValidator(template);

        if (validator.apply(initValue)) {
            Log.info(FOUND_VALID_VALUE);
            return initValue;
        }

        final Scanner scanner = getScanner();
        while (true) {
            out.printf(getStringInputPromptString(attributeName, defaultValue));
            out.flush();
            final String input = scanner.nextLine();
            if (validator.apply(input)) {
                return input;
            } else if (StringUtils.isNotEmpty(defaultValue) && StringUtils.isEmpty(input)) {
                return defaultValue;
            }
            Log.warn(getStringInputErrorMessage(template));
        }
    }",0
azure-maven-plugins-2.2.2,RESOURCE_LEAK,azure-sfmesh-maven-plugin/src/main/java/com/microsoft/azure/maven/servicefabric/YamlContent.java,"com.microsoft.azure.maven.servicefabric.YamlContent$Builder.build(org.apache.maven.plugin.logging.Log,java.lang.String):java.lang.String",45,"resource of type `java.io.InputStreamReader` acquired by call to `new()` at line 30 is not released after line 45.
**Note**: potential exception at line 31",https://github.com/microsoft/azure-maven-plugins/blob/azure-webapp-maven-plugin-v2.2.2/azure-sfmesh-maven-plugin/src/main/java/com/microsoft/azure/maven/servicefabric/YamlContent.java,"public String build(Log logger, String resourceName) throws MojoFailureException {
            final StringBuilder replacedYamlContent = new StringBuilder();
            try {
                final InputStream inputStream = this.getClass().getClassLoader().getResourceAsStream(resourceName);
                final BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));
                while (reader.ready()){
                    final String line = reader.readLine().replace(""\n"", """");
                    final String wordToReplace = line.substring(line.lastIndexOf("" "") + 1);
                    if (properties.containsKey(wordToReplace)){
                        logger.debug(String.format(""Replacing %s with %s"", wordToReplace,
                            properties.get(wordToReplace)));
                        replacedYamlContent.append(line.replace(wordToReplace, properties.get(wordToReplace)));
                    } else {
                        replacedYamlContent.append(line);
                    }
                    replacedYamlContent.append(""\n"");
                }
                reader.close();
                inputStream.close();
            } catch (IOException e){
                logger.error(e);
                throw new MojoFailureException(String.format(""Error while building "" +
                    ""%s resource"", resourceName));
            }
            return replacedYamlContent.toString();
        }",1
azure-maven-plugins-2.2.2,RESOURCE_LEAK,azure-sfmesh-maven-plugin/src/main/java/com/microsoft/azure/maven/servicefabric/Utils.java,"com.microsoft.azure.maven.servicefabric.Utils.executeCommand(org.apache.maven.plugin.logging.Log,java.lang.String):java.lang.String",83,resource of type `java.lang.Process` acquired by call to `exec(...)` at line 76 is not released after line 83.,https://github.com/microsoft/azure-maven-plugins/blob/azure-webapp-maven-plugin-v2.2.2/azure-sfmesh-maven-plugin/src/main/java/com/microsoft/azure/maven/servicefabric/Utils.java,"public static String executeCommand(Log logger, String command) throws MojoFailureException{
        try {
            logger.info(String.format(""Executing command %s"", command));
            final Process p;
            if (Utils.isWindows()){
                p = Runtime.getRuntime().exec(""cmd.exe /C"" + command);
            } else {
                p = Runtime.getRuntime().exec(command);
            }
            p.waitFor();
            final int exitCode = p.exitValue();
            final String stderr = IOUtil.toString(p.getErrorStream(), ""UTF-8"");
            final String stdout = IOUtil.toString(p.getInputStream(), ""UTF-8"");
            logger.debug(String.format(""STDOUT: %s"", stdout));
            if (stderr != null && stderr.length() > 0){
                if (exitCode != 0){
                    logger.error(String.format(""Process exited with exit code %d"", exitCode));
                    logger.error(String.format(""If STDERR: %s"", stderr));
                    throw new MojoFailureException(String.format(""Error while "" +
                        ""running the %s command"", command));
                } else {
                    logger.info(String.format(""Else STDERR: %s"", stderr));
                }
            }
            return stdout;
        } catch (IOException e){
            logger.error(e);
            throw new MojoFailureException(String.format(""Error while "" +
                ""running the %s command"", command));
        } catch (InterruptedException e) {
            logger.error(e);
            throw new MojoFailureException(String.format(""Interrupted while "" +
                ""running command %s"", command));
        }
    }",1
azure-maven-plugins-2.2.2,RESOURCE_LEAK,azure-sfmesh-maven-plugin/src/main/java/com/microsoft/azure/maven/servicefabric/Utils.java,"com.microsoft.azure.maven.servicefabric.Utils.executeCommand(org.apache.maven.plugin.logging.Log,java.lang.String):java.lang.String",83,resource of type `java.lang.Process` acquired by call to `exec(...)` at line 78 is not released after line 83.,https://github.com/microsoft/azure-maven-plugins/blob/azure-webapp-maven-plugin-v2.2.2/azure-sfmesh-maven-plugin/src/main/java/com/microsoft/azure/maven/servicefabric/Utils.java,"public static String executeCommand(Log logger, String command) throws MojoFailureException{
        try {
            logger.info(String.format(""Executing command %s"", command));
            final Process p;
            if (Utils.isWindows()){
                p = Runtime.getRuntime().exec(""cmd.exe /C"" + command);
            } else {
                p = Runtime.getRuntime().exec(command);
            }
            p.waitFor();
            final int exitCode = p.exitValue();
            final String stderr = IOUtil.toString(p.getErrorStream(), ""UTF-8"");
            final String stdout = IOUtil.toString(p.getInputStream(), ""UTF-8"");
            logger.debug(String.format(""STDOUT: %s"", stdout));
            if (stderr != null && stderr.length() > 0){
                if (exitCode != 0){
                    logger.error(String.format(""Process exited with exit code %d"", exitCode));
                    logger.error(String.format(""If STDERR: %s"", stderr));
                    throw new MojoFailureException(String.format(""Error while "" +
                        ""running the %s command"", command));
                } else {
                    logger.info(String.format(""Else STDERR: %s"", stderr));
                }
            }
            return stdout;
        } catch (IOException e){
            logger.error(e);
            throw new MojoFailureException(String.format(""Error while "" +
                ""running the %s command"", command));
        } catch (InterruptedException e) {
            logger.error(e);
            throw new MojoFailureException(String.format(""Interrupted while "" +
                ""running command %s"", command));
        }
    }",1
azure-maven-plugins-2.2.2,RESOURCE_LEAK,azure-spring-cloud-maven-plugin/src/main/java/com/microsoft/azure/maven/springcloud/DeployMojo.java,com.microsoft.azure.maven.springcloud.DeployMojo.confirm(java.util.List):boolean,86,resource of type `com.microsoft.azure.maven.prompt.DefaultPrompter` acquired by call to `new()` at line 83 is not released after line 86.,https://github.com/microsoft/azure-maven-plugins/blob/azure-webapp-maven-plugin-v2.2.2/azure-spring-cloud-maven-plugin/src/main/java/com/microsoft/azure/maven/springcloud/DeployMojo.java,"protected boolean confirm(List<AzureTask<?>> tasks) throws MojoFailureException {
        try {
            final IPrompter prompter = new DefaultPrompter();
            System.out.println(CONFIRM_PROMPT_START);
            tasks.stream().filter(t -> StringUtils.isNotBlank(t.getTitle().toString())).forEach((t) -> System.out.printf(""\t- %s%n"", t.getTitle()));
            return prompter.promoteYesNo(CONFIRM_PROMPT_CONFIRM, true, true);
        } catch (IOException e) {
            throw new MojoFailureException(e.getMessage(), e);
        }
    }",1
playwright-java-1.13.0,NULL_DEREFERENCE,driver/src/main/java/com/microsoft/playwright/impl/Driver.java,com.microsoft.playwright.impl.Driver.cliFileName():java.lang.String,64,"object returned by `getProperty(""os.name"")` could be null and is dereferenced at line 64.",https://github.com/microsoft/playwright-java/blob/v1.13.0/driver/src/main/java/com/microsoft/playwright/impl/Driver.java,"protected String cliFileName() {
    return System.getProperty(""os.name"").toLowerCase().contains(""windows"") ?
      ""playwright.cmd"" : ""playwright.sh"";
  }",1
playwright-java-1.13.0,NULL_DEREFERENCE,driver-bundle/src/main/java/com/microsoft/playwright/impl/DriverJar.java,com.microsoft.playwright.impl.DriverJar.platformDir():java.lang.String,125,"object returned by `getProperty(""os.arch"")` could be null and is dereferenced at line 125.",https://github.com/microsoft/playwright-java/blob/v1.13.0/driver-bundle/src/main/java/com/microsoft/playwright/impl/DriverJar.java,"private static String platformDir() {
    String name = System.getProperty(""os.name"").toLowerCase();
    if (name.contains(""windows"")) {
      return System.getProperty(""os.arch"").equals(""amd64"") ? ""win32_x64"" : ""win32"";
    }
    if (name.contains(""linux"")) {
      return ""linux"";
    }
    if (name.contains(""mac os x"")) {
      return ""mac"";
    }
    throw new RuntimeException(""Unexpected os.name value: "" + name);
  }",1
playwright-java-1.13.0,NULL_DEREFERENCE,driver-bundle/src/main/java/com/microsoft/playwright/impl/DriverJar.java,com.microsoft.playwright.impl.DriverJar.platformDir():java.lang.String,123,"object returned by `getProperty(""os.name"")` could be null and is dereferenced at line 123.",https://github.com/microsoft/playwright-java/blob/v1.13.0/driver-bundle/src/main/java/com/microsoft/playwright/impl/DriverJar.java,"private static String platformDir() {
    String name = System.getProperty(""os.name"").toLowerCase();
    if (name.contains(""windows"")) {
      return System.getProperty(""os.arch"").equals(""amd64"") ? ""win32_x64"" : ""win32"";
    }
    if (name.contains(""linux"")) {
      return ""linux"";
    }
    if (name.contains(""mac os x"")) {
      return ""mac"";
    }
    throw new RuntimeException(""Unexpected os.name value: "" + name);
  }",1
playwright-java-1.13.0,RESOURCE_LEAK,playwright/src/main/java/com/microsoft/playwright/impl/PlaywrightImpl.java,com.microsoft.playwright.impl.PlaywrightImpl.create(com.microsoft.playwright.Playwright$CreateOptions):com.microsoft.playwright.impl.PlaywrightImpl,44,"resource of type `java.io.DataInputStream` acquired by call to `PipeTransport(...)` at line 44 is not released after line 44.
**Note**: potential exception at line 44",https://github.com/microsoft/playwright-java/blob/v1.13.0/playwright/src/main/java/com/microsoft/playwright/impl/PlaywrightImpl.java,"public static PlaywrightImpl create(CreateOptions options) {
    try {
      Map<String, String> env = Collections.emptyMap();
      if (options != null && options.env != null) {
        env = options.env;
      }
      Path driver = Driver.ensureDriverInstalled(env);
      ProcessBuilder pb = new ProcessBuilder(driver.toString(), ""run-driver"");
      pb.redirectError(ProcessBuilder.Redirect.INHERIT);
      pb.environment().putAll(env);
      Process p = pb.start();
      Connection connection = new Connection(new PipeTransport(p.getInputStream(), p.getOutputStream()));
      PlaywrightImpl result = (PlaywrightImpl) connection.waitForObjectWithKnownName(""Playwright"");
      result.driverProcess = p;
      result.initSharedSelectors(null);
      return result;
    } catch (IOException e) {
      throw new PlaywrightException(""Failed to launch driver"", e);
    }
  }",1
playwright-java-1.13.0,RESOURCE_LEAK,playwright/src/main/java/com/microsoft/playwright/impl/PlaywrightImpl.java,com.microsoft.playwright.impl.PlaywrightImpl.create(com.microsoft.playwright.Playwright$CreateOptions):com.microsoft.playwright.impl.PlaywrightImpl,45,resource of type `java.io.DataInputStream` acquired by call to `PipeTransport(...)` at line 44 is not released after line 45.,https://github.com/microsoft/playwright-java/blob/v1.13.0/playwright/src/main/java/com/microsoft/playwright/impl/PlaywrightImpl.java,"public static PlaywrightImpl create(CreateOptions options) {
    try {
      Map<String, String> env = Collections.emptyMap();
      if (options != null && options.env != null) {
        env = options.env;
      }
      Path driver = Driver.ensureDriverInstalled(env);
      ProcessBuilder pb = new ProcessBuilder(driver.toString(), ""run-driver"");
      pb.redirectError(ProcessBuilder.Redirect.INHERIT);
      pb.environment().putAll(env);
      Process p = pb.start();
      Connection connection = new Connection(new PipeTransport(p.getInputStream(), p.getOutputStream()));
      PlaywrightImpl result = (PlaywrightImpl) connection.waitForObjectWithKnownName(""Playwright"");
      result.driverProcess = p;
      result.initSharedSelectors(null);
      return result;
    } catch (IOException e) {
      throw new PlaywrightException(""Failed to launch driver"", e);
    }
  }",1
nacos-2.0.2,NULL_DEREFERENCE,client/src/main/java/com/alibaba/nacos/client/utils/EnvUtil.java,com.alibaba.nacos.client.utils.EnvUtil.setSelfEnv(java.util.Map):void,44,object `amorayTagTmpStr` last assigned on line 43 could be null and is dereferenced at line 44.,https://github.com/alibaba/nacos/blob/2.0.2/client/src/main/java/com/alibaba/nacos/client/utils/EnvUtil.java,"public static void setSelfEnv(Map<String, List<String>> headers) {
        if (headers != null) {
            List<String> amorayTagTmp = headers.get(Constants.AMORY_TAG);
            if (amorayTagTmp == null) {
                if (selfAmorayTag != null) {
                    selfAmorayTag = null;
                    LOGGER.warn(""selfAmoryTag:null"");
                }
            } else {
                String amorayTagTmpStr = listToString(amorayTagTmp);
                if (!amorayTagTmpStr.equals(selfAmorayTag)) {
                    selfAmorayTag = amorayTagTmpStr;
                    LOGGER.warn(""selfAmoryTag:{}"", selfAmorayTag);
                }
            }
            
            List<String> vipserverTagTmp = headers.get(Constants.VIPSERVER_TAG);
            if (vipserverTagTmp == null) {
                if (selfVipserverTag != null) {
                    selfVipserverTag = null;
                    LOGGER.warn(""selfVipserverTag:null"");
                }
            } else {
                String vipserverTagTmpStr = listToString(vipserverTagTmp);
                if (!vipserverTagTmpStr.equals(selfVipserverTag)) {
                    selfVipserverTag = vipserverTagTmpStr;
                    LOGGER.warn(""selfVipserverTag:{}"", selfVipserverTag);
                }
            }
            List<String> locationTagTmp = headers.get(Constants.LOCATION_TAG);
            if (locationTagTmp == null) {
                if (selfLocationTag != null) {
                    selfLocationTag = null;
                    LOGGER.warn(""selfLocationTag:null"");
                }
            } else {
                String locationTagTmpStr = listToString(locationTagTmp);
                if (!locationTagTmpStr.equals(selfLocationTag)) {
                    selfLocationTag = locationTagTmpStr;
                    LOGGER.warn(""selfLocationTag:{}"", selfLocationTag);
                }
            }
        }
    }",0
nacos-2.0.2,NULL_DEREFERENCE,naming/src/main/java/com/alibaba/nacos/naming/core/v2/upgrade/doublewrite/execute/DefaultServiceMetadataUpgradeHelper.java,"com.alibaba.nacos.naming.core.v2.upgrade.doublewrite.execute.DefaultServiceMetadataUpgradeHelper.toV1Service(com.alibaba.nacos.naming.core.Service,com.alibaba.nacos.naming.core.v2.pojo.Service,com.alibaba.nacos.naming.core.v2.metadata.ServiceMetadata):com.alibaba.nacos.naming.core.Service",48,object returned by `v1.getClusterMap()` could be null and is dereferenced at line 48.,https://github.com/alibaba/nacos/blob/2.0.2/naming/src/main/java/com/alibaba/nacos/naming/core/v2/upgrade/doublewrite/execute/DefaultServiceMetadataUpgradeHelper.java,"public Service toV1Service(Service v1, com.alibaba.nacos.naming.core.v2.pojo.Service v2, ServiceMetadata v2meta) {
        if (null == v1) {
            v1 = new Service(v2.getGroupedServiceName());
            v1.setGroupName(v2.getGroup());
            v1.setNamespaceId(v2.getNamespace());
        }
        v1.setSelector(v2meta.getSelector());
        v1.setProtectThreshold(v2meta.getProtectThreshold());
        v1.setMetadata(v2meta.getExtendData());
        for (Map.Entry<String, ClusterMetadata> entry : v2meta.getClusters().entrySet()) {
            if (!v1.getClusterMap().containsKey(entry.getKey())) {
                v1.addCluster(toV1Cluster(new Cluster(entry.getKey(), v1), entry.getValue()));
            } else {
                toV1Cluster(v1.getClusterMap().get(entry.getKey()), entry.getValue());
            }
        }
        return v1;
    }",1
nacos-2.0.2,NULL_DEREFERENCE,naming/src/main/java/com/alibaba/nacos/naming/core/HealthOperatorV1Impl.java,"com.alibaba.nacos.naming.core.HealthOperatorV1Impl.updateHealthStatusForPersistentInstance(java.lang.String,java.lang.String,java.lang.String,java.lang.String,int,boolean):void",48,object `service` last assigned on line 46 could be null and is dereferenced at line 48.,https://github.com/alibaba/nacos/blob/2.0.2/naming/src/main/java/com/alibaba/nacos/naming/core/HealthOperatorV1Impl.java,"public void updateHealthStatusForPersistentInstance(String namespace, String fullServiceName, String clusterName,
            String ip, int port, boolean healthy) throws NacosException {
        Service service = serviceManager.getService(namespace, fullServiceName);
        // Only health check ""none"" need update health status with api
        if (HealthCheckType.NONE.name().equals(service.getClusterMap().get(clusterName).getHealthChecker().getType())) {
            for (Instance instance : service.allIPs(Lists.newArrayList(clusterName))) {
                if (instance.getIp().equals(ip) && instance.getPort() == port) {
                    instance.setHealthy(healthy);
                    Loggers.EVT_LOG
                            .info((healthy ? ""[IP-ENABLED]"" : ""[IP-DISABLED]"") + "" ips: "" + instance.getIp() + "":""
                                    + instance.getPort() + ""@"" + instance.getClusterName() + "", service: ""
                                    + fullServiceName + "", msg: update thought HealthController api"");
                    pushService.serviceChanged(service);
                    break;
                }
            }
        } else {
            throw new NacosException(NacosException.INVALID_PARAM,
                    ""health check is still working, service: "" + fullServiceName);
        }
    }",1
nacos-2.0.2,NULL_DEREFERENCE,client/src/main/java/com/alibaba/nacos/client/naming/utils/SignUtil.java,"com.alibaba.nacos.client.naming.utils.SignUtil.sign(java.lang.String,java.lang.String):java.lang.String",50,object returned by `encodeBase64(signature)` could be null and is dereferenced by call to `String(...)` at line 50.,https://github.com/alibaba/nacos/blob/2.0.2/client/src/main/java/com/alibaba/nacos/client/naming/utils/SignUtil.java,"public static String sign(String data, String key) throws Exception {
        try {
            byte[] signature = sign(data.getBytes(UTF8), key.getBytes(UTF8), SignUtil.SigningAlgorithm.HmacSHA1);
            return new String(Base64.encodeBase64(signature));
        } catch (Exception ex) {
            throw new Exception(""Unable to calculate a request signature: "" + ex.getMessage(), ex);
        }
    }",1
nacos-2.0.2,NULL_DEREFERENCE,config/src/main/java/com/alibaba/nacos/config/server/utils/GroupKey2.java,com.alibaba.nacos.config.server.utils.GroupKey2.parseKey(java.lang.String):java.lang.String[],89,object `group` last assigned on line 85 could be null and is dereferenced at line 89.,https://github.com/alibaba/nacos/blob/2.0.2/config/src/main/java/com/alibaba/nacos/config/server/utils/GroupKey2.java,"public static String[] parseKey(String groupKey) {
        StringBuilder sb = new StringBuilder();
        String dataId = null;
        String group = null;
        String tenant = null;
        
        for (int i = 0; i < groupKey.length(); ++i) {
            char c = groupKey.charAt(i);
            if ('+' == c) {
                if (null == dataId) {
                    dataId = sb.toString();
                    sb.setLength(0);
                } else if (null == group) {
                    group = sb.toString();
                    sb.setLength(0);
                } else {
                    throw new IllegalArgumentException(""invalid groupkey:"" + groupKey);
                }
            } else if ('%' == c) {
                char next = groupKey.charAt(++i);
                char nextnext = groupKey.charAt(++i);
                if ('2' == next && 'B' == nextnext) {
                    sb.append('+');
                } else if ('2' == next && '5' == nextnext) {
                    sb.append('%');
                } else {
                    throw new IllegalArgumentException(""invalid groupkey:"" + groupKey);
                }
            } else {
                sb.append(c);
            }
        }
        
        if (StringUtils.isBlank(group)) {
            group = sb.toString();
        } else {
            tenant = sb.toString();
        }
        if (group.length() == 0) {
            throw new IllegalArgumentException(""invalid groupkey:"" + groupKey);
        }
    
        return new String[] {dataId, group, tenant};
    }",0
nacos-2.0.2,NULL_DEREFERENCE,naming/src/main/java/com/alibaba/nacos/naming/core/v2/upgrade/doublewrite/execute/DefaultInstanceUpgradeHelper.java,com.alibaba.nacos.naming.core.v2.upgrade.doublewrite.execute.DefaultInstanceUpgradeHelper.toV2(com.alibaba.nacos.naming.core.Instance):com.alibaba.nacos.api.naming.pojo.Instance,56,object returned by `getMetadata(v2)` could be null and is dereferenced at line 56.,https://github.com/alibaba/nacos/blob/2.0.2/naming/src/main/java/com/alibaba/nacos/naming/core/v2/upgrade/doublewrite/execute/DefaultInstanceUpgradeHelper.java,"public com.alibaba.nacos.api.naming.pojo.Instance toV2(Instance v1) {
        com.alibaba.nacos.api.naming.pojo.Instance v2 = new com.alibaba.nacos.api.naming.pojo.Instance();
        BeanUtils.copyProperties(v1, v2, IGNORE_PROPERTIES);
        v2.getMetadata().putAll(v1.getMetadata());
        return v2;
    }",1
nacos-2.0.2,NULL_DEREFERENCE,config/src/main/java/com/alibaba/nacos/config/server/utils/GroupKey.java,com.alibaba.nacos.config.server.utils.GroupKey.parseKey(java.lang.String):java.lang.String[],94,object `group` last assigned on line 90 could be null and is dereferenced at line 94.,https://github.com/alibaba/nacos/blob/2.0.2/config/src/main/java/com/alibaba/nacos/config/server/utils/GroupKey.java,"public static String[] parseKey(String groupKey) {
        StringBuilder sb = new StringBuilder();
        String dataId = null;
        String group = null;
        String tenant = null;
        
        for (int i = 0; i < groupKey.length(); ++i) {
            char c = groupKey.charAt(i);
            if ('+' == c) {
                if (null == dataId) {
                    dataId = sb.toString();
                    sb.setLength(0);
                } else if (null == group) {
                    group = sb.toString();
                    sb.setLength(0);
                } else {
                    throw new IllegalArgumentException(""invalid groupkey:"" + groupKey);
                }
            } else if ('%' == c) {
                char next = groupKey.charAt(++i);
                char nextnext = groupKey.charAt(++i);
                if ('2' == next && 'B' == nextnext) {
                    sb.append('+');
                } else if ('2' == next && '5' == nextnext) {
                    sb.append('%');
                } else {
                    throw new IllegalArgumentException(""invalid groupkey:"" + groupKey);
                }
            } else {
                sb.append(c);
            }
        }
        
        if (StringUtils.isBlank(group)) {
            group = sb.toString();
        } else {
            tenant = sb.toString();
        }
        if (group.length() == 0) {
            throw new IllegalArgumentException(""invalid groupkey:"" + groupKey);
        }
    
        return new String[] {dataId, group, tenant};
    }",0
nacos-2.0.2,NULL_DEREFERENCE,naming/src/main/java/com/alibaba/nacos/naming/core/v2/client/manager/impl/ConnectionBasedClientManager.java,com.alibaba.nacos.naming.core.v2.client.manager.impl.ConnectionBasedClientManager.clientConnected(com.alibaba.nacos.core.remote.Connection):void,63,object `clientFactory` last assigned on line 62 could be null and is dereferenced at line 63.,https://github.com/alibaba/nacos/blob/2.0.2/naming/src/main/java/com/alibaba/nacos/naming/core/v2/client/manager/impl/ConnectionBasedClientManager.java,"public void clientConnected(Connection connect) {
        if (!RemoteConstants.LABEL_MODULE_NAMING.equals(connect.getMetaInfo().getLabel(RemoteConstants.LABEL_MODULE))) {
            return;
        }
        String type = connect.getMetaInfo().getConnectType();
        ClientFactory clientFactory = ClientFactoryHolder.getInstance().findClientFactory(type);
        clientConnected(clientFactory.newClient(connect.getMetaInfo().getConnectionId()));
    }",1
nacos-2.0.2,NULL_DEREFERENCE,config/src/main/java/com/alibaba/nacos/config/server/service/repository/embedded/EmbeddedPaginationHelperImpl.java,"com.alibaba.nacos.config.server.service.repository.embedded.EmbeddedPaginationHelperImpl.fetchPage(java.lang.String,java.lang.String,java.lang.Object[],int,int,java.lang.Long,org.springframework.jdbc.core.RowMapper):com.alibaba.nacos.config.server.model.Page",93,object returned by `getPageItems(page)` could be null and is dereferenced at line 93.,https://github.com/alibaba/nacos/blob/2.0.2/config/src/main/java/com/alibaba/nacos/config/server/service/repository/embedded/EmbeddedPaginationHelperImpl.java,"public Page<E> fetchPage(final String sqlCountRows, final String sqlFetchRows, final Object[] args,
            final int pageNo, final int pageSize, final Long lastMaxId, final RowMapper rowMapper) {
        if (pageNo <= 0 || pageSize <= 0) {
            throw new IllegalArgumentException(""pageNo and pageSize must be greater than zero"");
        }
        
        // Query the total number of current records
        Integer rowCountInt = databaseOperate.queryOne(sqlCountRows, args, Integer.class);
        if (rowCountInt == null) {
            throw new IllegalArgumentException(""fetchPageLimit error"");
        }
        
        // Count pages
        int pageCount = rowCountInt / pageSize;
        if (rowCountInt > pageSize * pageCount) {
            pageCount++;
        }
        
        // Create Page object
        final Page<E> page = new Page<E>();
        page.setPageNumber(pageNo);
        page.setPagesAvailable(pageCount);
        page.setTotalCount(rowCountInt);
        
        if (pageNo > pageCount) {
            return page;
        }
        
        final int startRow = (pageNo - 1) * pageSize;
        String selectSql = sqlFetchRows + "" OFFSET "" + startRow + "" ROWS FETCH NEXT "" + pageSize + "" ROWS ONLY"";
        
        List<E> result = databaseOperate.queryMany(selectSql, args, rowMapper);
        for (E item : result) {
            page.getPageItems().add(item);
        }
        return page;
    }",1
nacos-2.0.2,NULL_DEREFERENCE,naming/src/main/java/com/alibaba/nacos/naming/consistency/ephemeral/distro/combined/DistroHttpCombinedKeyDelayTask.java,com.alibaba.nacos.naming.consistency.ephemeral.distro.combined.DistroHttpCombinedKeyDelayTask.getDistroKey():com.alibaba.nacos.core.distributed.distro.entity.DistroKey,65,object returned by `getActualResourceTypes(result)` could be null and is dereferenced at line 65.,https://github.com/alibaba/nacos/blob/2.0.2/naming/src/main/java/com/alibaba/nacos/naming/consistency/ephemeral/distro/combined/DistroHttpCombinedKeyDelayTask.java,"public DistroKey getDistroKey() {
        DistroKey taskKey = super.getDistroKey();
        DistroHttpCombinedKey result = new DistroHttpCombinedKey(KeyBuilder.INSTANCE_LIST_KEY_PREFIX,
                taskKey.getTargetServer());
        result.setResourceKey(taskKey.getResourceKey());
        result.getActualResourceTypes().addAll(actualResourceKeys);
        return result;
    }",1
nacos-2.0.2,NULL_DEREFERENCE,config/src/main/java/com/alibaba/nacos/config/server/service/repository/extrnal/ExternalStoragePaginationHelperImpl.java,"com.alibaba.nacos.config.server.service.repository.extrnal.ExternalStoragePaginationHelperImpl.fetchPage(java.lang.String,java.lang.String,java.lang.Object[],int,int,java.lang.Long,org.springframework.jdbc.core.RowMapper):com.alibaba.nacos.config.server.model.Page",101,object returned by `getPageItems(page)` could be null and is dereferenced at line 101.,https://github.com/alibaba/nacos/blob/2.0.2/config/src/main/java/com/alibaba/nacos/config/server/service/repository/extrnal/ExternalStoragePaginationHelperImpl.java,"public Page<E> fetchPage(final String sqlCountRows, final String sqlFetchRows, final Object[] args,
            final int pageNo, final int pageSize, final Long lastMaxId, final RowMapper rowMapper) {
        if (pageNo <= 0 || pageSize <= 0) {
            throw new IllegalArgumentException(""pageNo and pageSize must be greater than zero"");
        }
        
        // Query the total number of current records.
        Integer rowCountInt = jdbcTemplate.queryForObject(sqlCountRows, args, Integer.class);
        if (rowCountInt == null) {
            throw new IllegalArgumentException(""fetchPageLimit error"");
        }
        
        // Compute pages count
        int pageCount = rowCountInt / pageSize;
        if (rowCountInt > pageSize * pageCount) {
            pageCount++;
        }
        
        // Create Page object
        final Page<E> page = new Page<E>();
        page.setPageNumber(pageNo);
        page.setPagesAvailable(pageCount);
        page.setTotalCount(rowCountInt);
        
        if (pageNo > pageCount) {
            return page;
        }
        
        final int startRow = (pageNo - 1) * pageSize;
        String selectSql = """";
        if (isDerby()) {
            selectSql = sqlFetchRows + "" OFFSET "" + startRow + "" ROWS FETCH NEXT "" + pageSize + "" ROWS ONLY"";
        } else if (lastMaxId != null) {
            selectSql = sqlFetchRows + "" and id > "" + lastMaxId + "" order by id asc"" + "" limit "" + 0 + "","" + pageSize;
        } else {
            selectSql = sqlFetchRows + "" limit "" + startRow + "","" + pageSize;
        }
        
        List<E> result = jdbcTemplate.query(selectSql, args, rowMapper);
        for (E item : result) {
            page.getPageItems().add(item);
        }
        return page;
    }",1
nacos-2.0.2,NULL_DEREFERENCE,config/src/main/java/com/alibaba/nacos/config/server/remote/ConfigPublishRequestHandler.java,"com.alibaba.nacos.config.server.remote.ConfigPublishRequestHandler.handle(com.alibaba.nacos.api.config.remote.request.ConfigPublishRequest,com.alibaba.nacos.api.remote.request.RequestMeta):com.alibaba.nacos.api.config.remote.response.ConfigPublishResponse",83,object `tag` last assigned on line 76 could be null and is dereferenced by call to `checkParam(...)` at line 83.,https://github.com/alibaba/nacos/blob/2.0.2/config/src/main/java/com/alibaba/nacos/config/server/remote/ConfigPublishRequestHandler.java," public ConfigPublishResponse handle(ConfigPublishRequest request, RequestMeta meta) throws NacosException {
        
        try {
            String dataId = request.getDataId();
            String group = request.getGroup();
            String content = request.getContent();
            final String tenant = request.getTenant();
            
            final String srcIp = meta.getClientIp();
            final String requestIpApp = request.getAdditionParam(""requestIpApp"");
            final String tag = request.getAdditionParam(""tag"");
            final String appName = request.getAdditionParam(""appName"");
            final String type = request.getAdditionParam(""type"");
            final String srcUser = request.getAdditionParam(""src_user"");
            
            // check tenant
            ParamUtils.checkParam(dataId, group, ""datumId"", content);
            ParamUtils.checkParam(tag);
            Map<String, Object> configAdvanceInfo = new HashMap<String, Object>(10);
            MapUtil.putIfValNoNull(configAdvanceInfo, ""config_tags"", request.getAdditionParam(""config_tags""));
            MapUtil.putIfValNoNull(configAdvanceInfo, ""desc"", request.getAdditionParam(""desc""));
            MapUtil.putIfValNoNull(configAdvanceInfo, ""use"", request.getAdditionParam(""use""));
            MapUtil.putIfValNoNull(configAdvanceInfo, ""effect"", request.getAdditionParam(""effect""));
            MapUtil.putIfValNoNull(configAdvanceInfo, ""type"", type);
            MapUtil.putIfValNoNull(configAdvanceInfo, ""schema"", request.getAdditionParam(""schema""));
            ParamUtils.checkParam(configAdvanceInfo);
            
            if (AggrWhitelist.isAggrDataId(dataId)) {
                Loggers.REMOTE_DIGEST
                        .warn(""[aggr-conflict] {} attempt to publish single data, {}, {}"", srcIp, dataId, group);
                throw new NacosException(NacosException.NO_RIGHT, ""dataId:"" + dataId + "" is aggr"");
            }
            
            final Timestamp time = TimeUtils.getCurrentTime();
            String betaIps = request.getAdditionParam(""betaIps"");
            ConfigInfo configInfo = new ConfigInfo(dataId, group, tenant, appName, content);
            configInfo.setMd5(request.getCasMd5());
            configInfo.setType(type);
            if (StringUtils.isBlank(betaIps)) {
                if (StringUtils.isBlank(tag)) {
                    if (StringUtils.isNotBlank(request.getCasMd5())) {
                        boolean casSuccess = persistService
                                .insertOrUpdateCas(srcIp, srcUser, configInfo, time, configAdvanceInfo, false);
                        if (!casSuccess) {
                            return ConfigPublishResponse.buildFailResponse(ResponseCode.FAIL.getCode(),
                                    ""Cas publish fail,server md5 may have changed."");
                        }
                    } else {
                        persistService.insertOrUpdate(srcIp, srcUser, configInfo, time, configAdvanceInfo, false);
                    }
                    ConfigChangePublisher.notifyConfigChange(
                            new ConfigDataChangeEvent(false, dataId, group, tenant, time.getTime()));
                } else {
                    if (StringUtils.isNotBlank(request.getCasMd5())) {
                        boolean casSuccess = persistService
                                .insertOrUpdateTagCas(configInfo, tag, srcIp, srcUser, time, false);
                        if (!casSuccess) {
                            return ConfigPublishResponse.buildFailResponse(ResponseCode.FAIL.getCode(),
                                    ""Cas publish tag config fail,server md5 may have changed."");
                        }
                    } else {
                        persistService.insertOrUpdateTag(configInfo, tag, srcIp, srcUser, time, false);
                        
                    }
                    ConfigChangePublisher.notifyConfigChange(
                            new ConfigDataChangeEvent(false, dataId, group, tenant, tag, time.getTime()));
                }
            } else {
                // beta publish
                if (StringUtils.isNotBlank(request.getCasMd5())) {
                    boolean casSuccess = persistService
                            .insertOrUpdateBetaCas(configInfo, betaIps, srcIp, srcUser, time, false);
                    if (!casSuccess) {
                        return ConfigPublishResponse.buildFailResponse(ResponseCode.FAIL.getCode(),
                                ""Cas publish beta config fail,server md5 may have changed."");
                    }
                } else {
                    persistService.insertOrUpdateBeta(configInfo, betaIps, srcIp, srcUser, time, false);
                    
                }
                ConfigChangePublisher
                        .notifyConfigChange(new ConfigDataChangeEvent(true, dataId, group, tenant, time.getTime()));
            }
            ConfigTraceService
                    .logPersistenceEvent(dataId, group, tenant, requestIpApp, time.getTime(), InetUtils.getSelfIP(),
                            ConfigTraceService.PERSISTENCE_EVENT_PUB, content);
            return ConfigPublishResponse.buildSuccessResponse();
        } catch (Exception e) {
            Loggers.REMOTE_DIGEST.error(""[ConfigPublishRequestHandler] publish config error ,request ={}"", request, e);
            return ConfigPublishResponse.buildFailResponse(
                    (e instanceof NacosException) ? ((NacosException) e).getErrCode() : ResponseCode.FAIL.getCode(),
                    e.getMessage());
        }
    }",1
nacos-2.0.2,NULL_DEREFERENCE,naming/src/main/java/com/alibaba/nacos/naming/core/v2/upgrade/doublewrite/execute/DoubleWriteInstanceChangeToV1Task.java,com.alibaba.nacos.naming.core.v2.upgrade.doublewrite.execute.DoubleWriteInstanceChangeToV1Task.getNewInstances():com.alibaba.nacos.naming.core.Instances,83,object returned by `getInstanceList(result)` could be null and is dereferenced at line 83.,https://github.com/alibaba/nacos/blob/2.0.2/naming/src/main/java/com/alibaba/nacos/naming/core/v2/upgrade/doublewrite/execute/DoubleWriteInstanceChangeToV1Task.java,"private Instances getNewInstances() {
        Instances result = new Instances();
        ServiceStorage serviceStorage = ApplicationUtils.getBean(ServiceStorage.class);
        InstanceUpgradeHelper instanceUpgradeHelper = ApplicationUtils.getBean(InstanceUpgradeHelper.class);
        long currentTimeStamp = System.currentTimeMillis();
        for (Instance each : serviceStorage.getData(service).getHosts()) {
            com.alibaba.nacos.naming.core.Instance instance = instanceUpgradeHelper.toV1(each);
            instance.setLastBeat(currentTimeStamp);
            result.getInstanceList().add(instance);
        }
        return result;
    }",1
nacos-2.0.2,NULL_DEREFERENCE,naming/src/main/java/com/alibaba/nacos/naming/consistency/persistent/raft/RaftStore.java,"com.alibaba.nacos.naming.consistency.persistent.raft.RaftStore.loadDatums(com.alibaba.nacos.naming.consistency.persistent.PersistentNotifier,java.util.Map):void",80,object returned by `listCaches()` could be null and is dereferenced at line 80.,https://github.com/alibaba/nacos/blob/2.0.2/naming/src/main/java/com/alibaba/nacos/naming/consistency/persistent/raft/RaftStore.java,"public synchronized void loadDatums(PersistentNotifier notifier, Map<String, Datum> datums) throws Exception {
        
        Datum datum;
        long start = System.currentTimeMillis();
        for (File cache : listCaches()) {
            if (cache.isDirectory() && cache.listFiles() != null) {
                for (File datumFile : cache.listFiles()) {
                    datum = readDatum(datumFile, cache.getName());
                    if (datum != null) {
                        datums.put(datum.key, datum);
                        if (notifier != null) {
                            NotifyCenter.publishEvent(
                                    ValueChangeEvent.builder().key(datum.key).action(DataOperation.CHANGE).build());
                        }
                    }
                }
                continue;
            }
            datum = readDatum(cache, StringUtils.EMPTY);
            if (datum != null) {
                datums.put(datum.key, datum);
            }
        }
        
        Loggers.RAFT.info(""finish loading all datums, size: {} cost {} ms."", datums.size(),
                (System.currentTimeMillis() - start));
    }",0
nacos-2.0.2,NULL_DEREFERENCE,naming/src/main/java/com/alibaba/nacos/naming/core/v2/client/manager/impl/ConnectionBasedClientManager.java,"com.alibaba.nacos.naming.core.v2.client.manager.impl.ConnectionBasedClientManager.syncClientConnected(java.lang.String,com.alibaba.nacos.naming.core.v2.client.ClientSyncAttributes):boolean",79,object `clientFactory` last assigned on line 78 could be null and is dereferenced at line 79.,https://github.com/alibaba/nacos/blob/2.0.2/naming/src/main/java/com/alibaba/nacos/naming/core/v2/client/manager/impl/ConnectionBasedClientManager.java,"public boolean syncClientConnected(String clientId, ClientSyncAttributes attributes) {
        String type = attributes.getClientAttribute(ClientConstants.CONNECTION_TYPE);
        ClientFactory clientFactory = ClientFactoryHolder.getInstance().findClientFactory(type);
        return clientConnected(clientFactory.newSyncedClient(clientId, attributes));
    }",1
nacos-2.0.2,NULL_DEREFERENCE,console/src/main/java/com/alibaba/nacos/console/security/nacos/NacosAuthConfig.java,com.alibaba.nacos.console.security.nacos.NacosAuthConfig.configure(org.springframework.security.config.annotation.web.builders.WebSecurity):void,100,object `ignoreUrls` last assigned on line 90 could be null and is dereferenced at line 100.,https://github.com/alibaba/nacos/blob/2.0.2/console/src/main/java/com/alibaba/nacos/console/security/nacos/NacosAuthConfig.java,"public void configure(WebSecurity web) {
        
        String ignoreUrls = null;
        if (AuthSystemTypes.NACOS.name().equalsIgnoreCase(authConfigs.getNacosAuthSystemType())) {
            ignoreUrls = DEFAULT_ALL_PATH_PATTERN;
        } else if (AuthSystemTypes.LDAP.name().equalsIgnoreCase(authConfigs.getNacosAuthSystemType())) {
            ignoreUrls = DEFAULT_ALL_PATH_PATTERN;
        }
        if (StringUtils.isBlank(authConfigs.getNacosAuthSystemType())) {
            ignoreUrls = env.getProperty(PROPERTY_IGNORE_URLS, DEFAULT_ALL_PATH_PATTERN);
        }
        if (StringUtils.isNotBlank(ignoreUrls)) {
            for (String each : ignoreUrls.trim().split(SECURITY_IGNORE_URLS_SPILT_CHAR)) {
                web.ignoring().antMatchers(each.trim());
            }
        }
    }",0
nacos-2.0.2,NULL_DEREFERENCE,config/src/main/java/com/alibaba/nacos/config/server/service/repository/embedded/EmbeddedPaginationHelperImpl.java,"com.alibaba.nacos.config.server.service.repository.embedded.EmbeddedPaginationHelperImpl.fetchPageLimit(java.lang.String,java.lang.String,java.lang.Object[],int,int,org.springframework.jdbc.core.RowMapper):com.alibaba.nacos.config.server.model.Page",129,object returned by `getPageItems(page)` could be null and is dereferenced at line 129.,https://github.com/alibaba/nacos/blob/2.0.2/config/src/main/java/com/alibaba/nacos/config/server/service/repository/embedded/EmbeddedPaginationHelperImpl.java,"public Page<E> fetchPageLimit(final String sqlCountRows, final String sqlFetchRows, final Object[] args,
            final int pageNo, final int pageSize, final RowMapper rowMapper) {
        if (pageNo <= 0 || pageSize <= 0) {
            throw new IllegalArgumentException(""pageNo and pageSize must be greater than zero"");
        }
        // Query the total number of current records
        Integer rowCountInt = databaseOperate.queryOne(sqlCountRows, Integer.class);
        if (rowCountInt == null) {
            throw new IllegalArgumentException(""fetchPageLimit error"");
        }
        
        // Count pages
        int pageCount = rowCountInt / pageSize;
        if (rowCountInt > pageSize * pageCount) {
            pageCount++;
        }
        
        // Create Page object
        final Page<E> page = new Page<E>();
        page.setPageNumber(pageNo);
        page.setPagesAvailable(pageCount);
        page.setTotalCount(rowCountInt);
        
        if (pageNo > pageCount) {
            return page;
        }
        
        String selectSql = sqlFetchRows.replaceAll(""(?i)LIMIT \\?,\\?"", ""OFFSET ? ROWS FETCH NEXT ? ROWS ONLY"");
        List<E> result = databaseOperate.queryMany(selectSql, args, rowMapper);
        for (E item : result) {
            page.getPageItems().add(item);
        }
        return page;
    }",1
nacos-2.0.2,NULL_DEREFERENCE,config/src/main/java/com/alibaba/nacos/config/server/controller/ConfigOpsController.java,com.alibaba.nacos.config.server.controller.ConfigOpsController.derbyOps(java.lang.String):com.alibaba.nacos.common.model.RestResult,116,object `template` last assigned on line 115 could be null and is dereferenced at line 116.,https://github.com/alibaba/nacos/blob/2.0.2/config/src/main/java/com/alibaba/nacos/config/server/controller/ConfigOpsController.java,"public RestResult<Object> derbyOps(@RequestParam(value = ""sql"") String sql) {
        String selectSign = ""select"";
        String limitSign = ""ROWS FETCH NEXT"";
        String limit = "" OFFSET 0 ROWS FETCH NEXT 1000 ROWS ONLY"";
        try {
            if (!PropertyUtil.isEmbeddedStorage()) {
                return RestResultUtils.failed(""The current storage mode is not Derby"");
            }
            LocalDataSourceServiceImpl dataSourceService = (LocalDataSourceServiceImpl) DynamicDataSource
                    .getInstance().getDataSource();
            if (StringUtils.startsWithIgnoreCase(sql, selectSign)) {
                if (!StringUtils.containsIgnoreCase(sql, limitSign)) {
                    sql += limit;
                }
                JdbcTemplate template = dataSourceService.getJdbcTemplate();
                List<Map<String, Object>> result = template.queryForList(sql);
                return RestResultUtils.success(result);
            }
            return RestResultUtils.failed(""Only query statements are allowed to be executed"");
        } catch (Exception e) {
            return RestResultUtils.failed(e.getMessage());
        }
    }",1
nacos-2.0.2,NULL_DEREFERENCE,config/src/main/java/com/alibaba/nacos/config/server/service/repository/extrnal/ExternalStoragePaginationHelperImpl.java,"com.alibaba.nacos.config.server.service.repository.extrnal.ExternalStoragePaginationHelperImpl.fetchPageLimit(java.lang.String,java.lang.String,java.lang.Object[],int,int,org.springframework.jdbc.core.RowMapper):com.alibaba.nacos.config.server.model.Page",141,object returned by `getPageItems(page)` could be null and is dereferenced at line 141.,https://github.com/alibaba/nacos/blob/2.0.2/config/src/main/java/com/alibaba/nacos/config/server/service/repository/extrnal/ExternalStoragePaginationHelperImpl.java,"public Page<E> fetchPageLimit(final String sqlCountRows, final String sqlFetchRows, final Object[] args,
            final int pageNo, final int pageSize, final RowMapper rowMapper) {
        if (pageNo <= 0 || pageSize <= 0) {
            throw new IllegalArgumentException(""pageNo and pageSize must be greater than zero"");
        }
        // Query the total number of current records
        Integer rowCountInt = jdbcTemplate.queryForObject(sqlCountRows, Integer.class);
        if (rowCountInt == null) {
            throw new IllegalArgumentException(""fetchPageLimit error"");
        }
        
        // Compute pages count
        int pageCount = rowCountInt / pageSize;
        if (rowCountInt > pageSize * pageCount) {
            pageCount++;
        }
        
        // Create Page object
        final Page<E> page = new Page<E>();
        page.setPageNumber(pageNo);
        page.setPagesAvailable(pageCount);
        page.setTotalCount(rowCountInt);
        
        if (pageNo > pageCount) {
            return page;
        }
        
        String selectSql = sqlFetchRows;
        if (isDerby()) {
            selectSql = selectSql.replaceAll(""(?i)LIMIT \\?,\\?"", ""OFFSET ? ROWS FETCH NEXT ? ROWS ONLY"");
        }
        
        List<E> result = jdbcTemplate.query(selectSql, args, rowMapper);
        for (E item : result) {
            page.getPageItems().add(item);
        }
        return page;
    }",0
nacos-2.0.2,NULL_DEREFERENCE,naming/src/main/java/com/alibaba/nacos/naming/controllers/DistroController.java,com.alibaba.nacos.naming.controllers.DistroController.get(java.lang.String):org.springframework.http.ResponseEntity,123,object returned by `getActualResourceTypes(distroKey)` could be null and is dereferenced at line 123.,https://github.com/alibaba/nacos/blob/2.0.2/naming/src/main/java/com/alibaba/nacos/naming/controllers/DistroController.java,"public ResponseEntity get(@RequestBody String body) throws Exception {
        
        JsonNode bodyNode = JacksonUtils.toObj(body);
        String keys = bodyNode.get(""keys"").asText();
        String keySplitter = "","";
        DistroHttpCombinedKey distroKey = new DistroHttpCombinedKey(KeyBuilder.INSTANCE_LIST_KEY_PREFIX, """");
        for (String key : keys.split(keySplitter)) {
            distroKey.getActualResourceTypes().add(key);
        }
        DistroData distroData = distroProtocol.onQuery(distroKey);
        return ResponseEntity.ok(distroData.getContent());
    }",1
nacos-2.0.2,NULL_DEREFERENCE,console/src/main/java/com/alibaba/nacos/console/security/nacos/roles/NacosRoleServiceImpl.java,"com.alibaba.nacos.console.security.nacos.roles.NacosRoleServiceImpl.hasPermission(java.lang.String,com.alibaba.nacos.auth.model.Permission):boolean",130,object `roleInfoList` last assigned on line 124 could be null and is dereferenced at line 130.,https://github.com/alibaba/nacos/blob/2.0.2/console/src/main/java/com/alibaba/nacos/console/security/nacos/roles/NacosRoleServiceImpl.java,"public boolean hasPermission(String username, Permission permission) {
        //update password
        if (NacosAuthConfig.UPDATE_PASSWORD_ENTRY_POINT.equals(permission.getResource())) {
            return true;
        }

        List<RoleInfo> roleInfoList = getRoles(username);
        if (Collections.isEmpty(roleInfoList)) {
            return false;
        }
        
        // Global admin pass:
        for (RoleInfo roleInfo : roleInfoList) {
            if (GLOBAL_ADMIN_ROLE.equals(roleInfo.getRole())) {
                return true;
            }
        }
        
        // Old global admin can pass resource 'console/':
        if (permission.getResource().startsWith(NacosAuthConfig.CONSOLE_RESOURCE_NAME_PREFIX)) {
            return false;
        }
        
        // For other roles, use a pattern match to decide if pass or not.
        for (RoleInfo roleInfo : roleInfoList) {
            List<PermissionInfo> permissionInfoList = getPermissions(roleInfo.getRole());
            if (Collections.isEmpty(permissionInfoList)) {
                continue;
            }
            for (PermissionInfo permissionInfo : permissionInfoList) {
                String permissionResource = permissionInfo.getResource().replaceAll(""\\*"", "".*"");
                String permissionAction = permissionInfo.getAction();
                if (permissionAction.contains(permission.getAction()) && Pattern
                        .matches(permissionResource, permission.getResource())) {
                    return true;
                }
            }
        }
        return false;
    }",0
nacos-2.0.2,NULL_DEREFERENCE,naming/src/main/java/com/alibaba/nacos/naming/consistency/persistent/raft/RaftStore.java,com.alibaba.nacos.naming.consistency.persistent.raft.RaftStore.load(java.lang.String):com.alibaba.nacos.naming.consistency.Datum,132,object returned by `listCaches()` could be null and is dereferenced at line 132.,https://github.com/alibaba/nacos/blob/2.0.2/naming/src/main/java/com/alibaba/nacos/naming/consistency/persistent/raft/RaftStore.java,"public synchronized Datum load(String key) throws Exception {
        long start = System.currentTimeMillis();
        // load data
        for (File cache : listCaches()) {
            if (!cache.isFile()) {
                Loggers.RAFT.warn(""warning: encountered directory in cache dir: {}"", cache.getAbsolutePath());
            }
            
            if (!StringUtils.equals(cache.getName(), encodeDatumKey(key))) {
                continue;
            }
            
            Loggers.RAFT.info(""finish loading datum, key: {} cost {} ms."", key, (System.currentTimeMillis() - start));
            return readDatum(cache, StringUtils.EMPTY);
        }
        
        return null;
    }",0
nacos-2.0.2,NULL_DEREFERENCE,config/src/main/java/com/alibaba/nacos/config/server/controller/ClientMetricsController.java,"com.alibaba.nacos.config.server.controller.ClientMetricsController.getClientMetrics(java.lang.String,java.lang.String,java.lang.String,java.lang.String):java.util.Map",143,object returned by `getMetricsKeys(clientMetrics)` could be null and is dereferenced at line 143.,https://github.com/alibaba/nacos/blob/2.0.2/config/src/main/java/com/alibaba/nacos/config/server/controller/ClientMetricsController.java,"public Map<String, Object> getClientMetrics(@RequestParam(""ip"") String ip,
            @RequestParam(value = ""dataId"", required = false) String dataId,
            @RequestParam(value = ""group"", required = false) String group,
            @RequestParam(value = ""tenant"", required = false) String tenant) {
        Map<String, Object> metrics = new HashMap<>(16);
        List<Connection> connectionsByIp = connectionManager.getConnectionByIp(ip);
        for (Connection connectionByIp : connectionsByIp) {
            try {
                ClientConfigMetricRequest clientMetrics = new ClientConfigMetricRequest();
                if (StringUtils.isNotBlank(dataId)) {
                    clientMetrics.getMetricsKeys().add(ClientConfigMetricRequest.MetricsKey
                            .build(CACHE_DATA, GroupKey2.getKey(dataId, group, tenant)));
                    clientMetrics.getMetricsKeys().add(ClientConfigMetricRequest.MetricsKey
                            .build(SNAPSHOT_DATA, GroupKey2.getKey(dataId, group, tenant)));
                }
                
                ClientConfigMetricResponse request1 = (ClientConfigMetricResponse) connectionByIp
                        .request(clientMetrics, 1000L);
                metrics.putAll(request1.getMetrics());
            } catch (Exception e) {
                Loggers.CORE.error(""Get config metrics error from client ip={},dataId={},group={},tenant={},error={}"", ip, dataId,
                        group, tenant, e);
            }
        }
        return metrics;
        
    }",0
nacos-2.0.2,NULL_DEREFERENCE,naming/src/main/java/com/alibaba/nacos/naming/healthcheck/HealthCheckCommon.java,"com.alibaba.nacos.naming.healthcheck.HealthCheckCommon.checkFail(com.alibaba.nacos.naming.core.Instance,com.alibaba.nacos.naming.healthcheck.HealthCheckTask,java.lang.String):void",156,object returned by `cluster.getService()` could be null and is dereferenced at line 156.,https://github.com/alibaba/nacos/blob/2.0.2/naming/src/main/java/com/alibaba/nacos/naming/healthcheck/HealthCheckCommon.java,"public void checkFail(Instance ip, HealthCheckTask task, String msg) {
        Cluster cluster = task.getCluster();
        
        try {
            if (ip.isHealthy() || ip.isMockValid()) {
                if (ip.getFailCount().incrementAndGet() >= switchDomain.getCheckTimes()) {
                    if (distroMapper.responsible(cluster, ip)) {
                        ip.setHealthy(false);
                        ip.setMockValid(false);
                        
                        Service service = cluster.getService();
                        service.setLastModifiedMillis(System.currentTimeMillis());
                        
                        pushService.serviceChanged(service);
                        
                        Loggers.EVT_LOG
                                .info(""serviceName: {} {POS} {IP-DISABLED} invalid: {}:{}@{}, region: {}, msg: {}"",
                                        cluster.getService().getName(), ip.getIp(), ip.getPort(), cluster.getName(),
                                        UtilsAndCommons.LOCALHOST_SITE, msg);
                    } else {
                        Loggers.EVT_LOG
                                .info(""serviceName: {} {PROBE} {IP-DISABLED} invalid: {}:{}@{}, region: {}, msg: {}"",
                                        cluster.getService().getName(), ip.getIp(), ip.getPort(), cluster.getName(),
                                        UtilsAndCommons.LOCALHOST_SITE, msg);
                    }
                    
                } else {
                    Loggers.EVT_LOG.info(""serviceName: {} {OTHER} {IP-DISABLED} pre-invalid: {}:{}@{} in {}, msg: {}"",
                            cluster.getService().getName(), ip.getIp(), ip.getPort(), cluster.getName(),
                            ip.getFailCount(), msg);
                }
            }
        } catch (Throwable t) {
            Loggers.SRV_LOG.error(""[CHECK-FAIL] error when close check task."", t);
        }
        
        ip.getOkCount().set(0);
        
        ip.setBeingChecked(false);
    }",1
nacos-2.0.2,NULL_DEREFERENCE,config/src/main/java/com/alibaba/nacos/config/server/service/repository/embedded/EmbeddedPaginationHelperImpl.java,"com.alibaba.nacos.config.server.service.repository.embedded.EmbeddedPaginationHelperImpl.fetchPageLimit(java.lang.String,java.lang.Object[],java.lang.String,java.lang.Object[],int,int,org.springframework.jdbc.core.RowMapper):com.alibaba.nacos.config.server.model.Page",166,object returned by `getPageItems(page)` could be null and is dereferenced at line 166.,https://github.com/alibaba/nacos/blob/2.0.2/config/src/main/java/com/alibaba/nacos/config/server/service/repository/embedded/EmbeddedPaginationHelperImpl.java,"public Page<E> fetchPageLimit(final String sqlCountRows, final Object[] args1, final String sqlFetchRows,
            final Object[] args2, final int pageNo, final int pageSize, final RowMapper rowMapper) {
        if (pageNo <= 0 || pageSize <= 0) {
            throw new IllegalArgumentException(""pageNo and pageSize must be greater than zero"");
        }
        // Query the total number of current records
        Integer rowCountInt = databaseOperate.queryOne(sqlCountRows, args1, Integer.class);
        if (rowCountInt == null) {
            throw new IllegalArgumentException(""fetchPageLimit error"");
        }
        
        // Count pages
        int pageCount = rowCountInt / pageSize;
        if (rowCountInt > pageSize * pageCount) {
            pageCount++;
        }
        
        // Create Page object
        final Page<E> page = new Page<E>();
        page.setPageNumber(pageNo);
        page.setPagesAvailable(pageCount);
        page.setTotalCount(rowCountInt);
        
        if (pageNo > pageCount) {
            return page;
        }
        
        String selectSql = sqlFetchRows.replaceAll(""(?i)LIMIT \\?,\\?"", ""OFFSET ? ROWS FETCH NEXT ? ROWS ONLY"");
        
        List<E> result = databaseOperate.queryMany(selectSql, args2, rowMapper);
        for (E item : result) {
            page.getPageItems().add(item);
        }
        return page;
    }",1
nacos-2.0.2,NULL_DEREFERENCE,config/src/main/java/com/alibaba/nacos/config/server/service/merge/MergeDatumService.java,com.alibaba.nacos.config.server.service.merge.MergeDatumService$MergeAllDataWorker.run():void,167,object returned by `cf.getContent()` could be null and is dereferenced at line 167.,https://github.com/alibaba/nacos/blob/2.0.2/config/src/main/java/com/alibaba/nacos/config/server/service/merge/MergeDatumService.java,"public void run() {
            for (ConfigInfoChanged configInfo : configInfoList) {
                String dataId = configInfo.getDataId();
                String group = configInfo.getGroup();
                String tenant = configInfo.getTenant();
                try {
                    List<ConfigInfoAggr> datumList = new ArrayList<ConfigInfoAggr>();
                    int rowCount = persistService.aggrConfigInfoCount(dataId, group, tenant);
                    int pageCount = (int) Math.ceil(rowCount * 1.0 / PAGE_SIZE);
                    for (int pageNo = 1; pageNo <= pageCount; pageNo++) {
                        Page<ConfigInfoAggr> page = persistService
                                .findConfigInfoAggrByPage(dataId, group, tenant, pageNo, PAGE_SIZE);
                        if (page != null) {
                            datumList.addAll(page.getPageItems());
                            LOGGER.info(""[merge-query] {}, {}, size/total={}/{}"", dataId, group, datumList.size(),
                                    rowCount);
                        }
                    }
                    
                    final Timestamp time = TimeUtils.getCurrentTime();
                    
                    if (datumList.size() > 0) {
                        // merge
                        ConfigInfo cf = MergeTaskProcessor.merge(dataId, group, tenant, datumList);
                        persistService.insertOrUpdate(null, null, cf, time, null, false);
                        LOGGER.info(""[merge-ok] {}, {}, size={}, length={}, md5={}, content={}"", dataId, group,
                                datumList.size(), cf.getContent().length(), cf.getMd5(),
                                ContentUtils.truncateContent(cf.getContent()));
                    } else {
                        // remove
                        persistService.removeConfigInfo(dataId, group, tenant, InetUtils.getSelfIP(), null);
                        LOGGER.warn(""[merge-delete] delete config info because no datum. dataId="" + dataId + "", groupId=""
                                + group);
                    }
                    
                } catch (Exception e) {
                    LOGGER.info(""[merge-error] "" + dataId + "", "" + group + "", "" + e.toString(), e);
                }
                FINISHED.incrementAndGet();
                if (FINISHED.get() % 100 == 0) {
                    LOGGER.info(""[all-merge-dump] {} / {}"", FINISHED.get(), total);
                }
            }
            LOGGER.info(""[all-merge-dump] {} / {}"", FINISHED.get(), total);
        }",1
nacos-2.0.2,NULL_DEREFERENCE,config/src/main/java/com/alibaba/nacos/config/server/service/repository/extrnal/ExternalStoragePaginationHelperImpl.java,"com.alibaba.nacos.config.server.service.repository.extrnal.ExternalStoragePaginationHelperImpl.fetchPageLimit(java.lang.String,java.lang.Object[],java.lang.String,java.lang.Object[],int,int,org.springframework.jdbc.core.RowMapper):com.alibaba.nacos.config.server.model.Page",181,object returned by `getPageItems(page)` could be null and is dereferenced at line 181.,https://github.com/alibaba/nacos/blob/2.0.2/config/src/main/java/com/alibaba/nacos/config/server/service/repository/extrnal/ExternalStoragePaginationHelperImpl.java,"public Page<E> fetchPageLimit(final String sqlCountRows, final Object[] args1, final String sqlFetchRows,
            final Object[] args2, final int pageNo, final int pageSize, final RowMapper rowMapper) {
        if (pageNo <= 0 || pageSize <= 0) {
            throw new IllegalArgumentException(""pageNo and pageSize must be greater than zero"");
        }
        // Query the total number of current records
        Integer rowCountInt = jdbcTemplate.queryForObject(sqlCountRows, args1, Integer.class);
        if (rowCountInt == null) {
            throw new IllegalArgumentException(""fetchPageLimit error"");
        }
        
        // Compute pages count
        int pageCount = rowCountInt / pageSize;
        if (rowCountInt > pageSize * pageCount) {
            pageCount++;
        }
        
        // Create Page object
        final Page<E> page = new Page<E>();
        page.setPageNumber(pageNo);
        page.setPagesAvailable(pageCount);
        page.setTotalCount(rowCountInt);
        
        if (pageNo > pageCount) {
            return page;
        }
        
        String selectSql = sqlFetchRows;
        if (isDerby()) {
            selectSql = selectSql.replaceAll(""(?i)LIMIT \\?,\\?"", ""OFFSET ? ROWS FETCH NEXT ? ROWS ONLY"");
        }
        
        List<E> result = jdbcTemplate.query(selectSql, args2, rowMapper);
        for (E item : result) {
            page.getPageItems().add(item);
        }
        return page;
    }",1
nacos-2.0.2,NULL_DEREFERENCE,sys/src/main/java/com/alibaba/nacos/sys/utils/DiskUtils.java,"com.alibaba.nacos.sys.utils.DiskUtils.readFile(java.lang.String,java.lang.String):java.lang.String",151,object `file` last assigned on line 150 could be null and is dereferenced at line 151.,https://github.com/alibaba/nacos/blob/2.0.2/sys/src/main/java/com/alibaba/nacos/sys/utils/DiskUtils.java,"public static String readFile(String path, String fileName) {
        File file = openFile(path, fileName);
        if (file.exists()) {
            return readFile(file);
        }
        return null;
    }",0
nacos-2.0.2,NULL_DEREFERENCE,config/src/main/java/com/alibaba/nacos/config/server/service/repository/embedded/DerbySnapshotOperation.java,com.alibaba.nacos.config.server.service.repository.embedded.DerbySnapshotOperation.doDerbyBackup(java.lang.String):void,156,object returned by `sourceService.getJdbcTemplate()` could be null and is dereferenced at line 156.,https://github.com/alibaba/nacos/blob/2.0.2/config/src/main/java/com/alibaba/nacos/config/server/service/repository/embedded/DerbySnapshotOperation.java,"private void doDerbyBackup(String backupDirectory) throws Exception {
        DataSourceService sourceService = DynamicDataSource.getInstance().getDataSource();
        DataSource dataSource = sourceService.getJdbcTemplate().getDataSource();
        try (Connection holder = Objects.requireNonNull(dataSource, ""dataSource"").getConnection()) {
            CallableStatement cs = holder.prepareCall(backupSql);
            cs.setString(1, backupDirectory);
            cs.execute();
        }
    }",1
nacos-2.0.2,NULL_DEREFERENCE,config/src/main/java/com/alibaba/nacos/config/server/service/repository/embedded/EmbeddedPaginationHelperImpl.java,"com.alibaba.nacos.config.server.service.repository.embedded.EmbeddedPaginationHelperImpl.fetchPageLimit(java.lang.String,java.lang.Object[],int,int,org.springframework.jdbc.core.RowMapper):com.alibaba.nacos.config.server.model.Page",184,object returned by `getPageItems(page)` could be null and is dereferenced at line 184.,https://github.com/alibaba/nacos/blob/2.0.2/config/src/main/java/com/alibaba/nacos/config/server/service/repository/embedded/EmbeddedPaginationHelperImpl.java,"public Page<E> fetchPageLimit(final String sqlFetchRows, final Object[] args, final int pageNo, final int pageSize,
            final RowMapper rowMapper) {
        if (pageNo <= 0 || pageSize <= 0) {
            throw new IllegalArgumentException(""pageNo and pageSize must be greater than zero"");
        }
        // Create Page object
        final Page<E> page = new Page<E>();
        
        String selectSql = sqlFetchRows.replaceAll(""(?i)LIMIT \\?,\\?"", ""OFFSET ? ROWS FETCH NEXT ? ROWS ONLY"");
        
        List<E> result = databaseOperate.queryMany(selectSql, args, rowMapper);
        for (E item : result) {
            page.getPageItems().add(item);
        }
        return page;
    }",1
nacos-2.0.2,NULL_DEREFERENCE,naming/src/main/java/com/alibaba/nacos/naming/healthcheck/HealthCheckCommon.java,"com.alibaba.nacos.naming.healthcheck.HealthCheckCommon.checkFailNow(com.alibaba.nacos.naming.core.Instance,com.alibaba.nacos.naming.healthcheck.HealthCheckTask,java.lang.String):void",204,object returned by `cluster.getService()` could be null and is dereferenced at line 204.,https://github.com/alibaba/nacos/blob/2.0.2/naming/src/main/java/com/alibaba/nacos/naming/healthcheck/HealthCheckCommon.java,"public void checkFailNow(Instance ip, HealthCheckTask task, String msg) {
        Cluster cluster = task.getCluster();
        try {
            if (ip.isHealthy() || ip.isMockValid()) {
                if (distroMapper.responsible(cluster, ip)) {
                    ip.setHealthy(false);
                    ip.setMockValid(false);
                    
                    Service service = cluster.getService();
                    service.setLastModifiedMillis(System.currentTimeMillis());
                    
                    pushService.serviceChanged(service);
                    
                    Loggers.EVT_LOG
                            .info(""serviceName: {} {POS} {IP-DISABLED} invalid-now: {}:{}@{}, region: {}, msg: {}"",
                                    cluster.getService().getName(), ip.getIp(), ip.getPort(), cluster.getName(),
                                    UtilsAndCommons.LOCALHOST_SITE, msg);
                } else {
                    if (ip.isMockValid()) {
                        ip.setMockValid(false);
                        Loggers.EVT_LOG
                                .info(""serviceName: {} {PROBE} {IP-DISABLED} invalid-now: {}:{}@{}, region: {}, msg: {}"",
                                        cluster.getService().getName(), ip.getIp(), ip.getPort(), cluster.getName(),
                                        UtilsAndCommons.LOCALHOST_SITE, msg);
                    }
                    
                }
            }
        } catch (Throwable t) {
            Loggers.SRV_LOG.error(""[CHECK-FAIL-NOW] error when close check task."", t);
        }
        
        ip.getOkCount().set(0);
        ip.setBeingChecked(false);
    }",1
nacos-2.0.2,NULL_DEREFERENCE,config/src/main/java/com/alibaba/nacos/config/server/service/repository/extrnal/ExternalStoragePaginationHelperImpl.java,"com.alibaba.nacos.config.server.service.repository.extrnal.ExternalStoragePaginationHelperImpl.fetchPageLimit(java.lang.String,java.lang.Object[],int,int,org.springframework.jdbc.core.RowMapper):com.alibaba.nacos.config.server.model.Page",202,object returned by `getPageItems(page)` could be null and is dereferenced at line 202.,https://github.com/alibaba/nacos/blob/2.0.2/config/src/main/java/com/alibaba/nacos/config/server/service/repository/extrnal/ExternalStoragePaginationHelperImpl.java,"public Page<E> fetchPageLimit(final String sqlFetchRows, final Object[] args, final int pageNo, final int pageSize,
            final RowMapper rowMapper) {
        if (pageNo <= 0 || pageSize <= 0) {
            throw new IllegalArgumentException(""pageNo and pageSize must be greater than zero"");
        }
        // Create Page object
        final Page<E> page = new Page<E>();
        
        String selectSql = sqlFetchRows;
        if (isDerby()) {
            selectSql = selectSql.replaceAll(""(?i)LIMIT \\?,\\?"", ""OFFSET ? ROWS FETCH NEXT ? ROWS ONLY"");
        }
        
        List<E> result = jdbcTemplate.query(selectSql, args, rowMapper);
        for (E item : result) {
            page.getPageItems().add(item);
        }
        return page;
    }",1
nacos-2.0.2,NULL_DEREFERENCE,sys/src/main/java/com/alibaba/nacos/sys/utils/DiskUtils.java,"com.alibaba.nacos.sys.utils.DiskUtils.readFileBytes(java.lang.String,java.lang.String):byte[]",221,object `file` last assigned on line 220 could be null and is dereferenced by call to `readFileBytes(...)` at line 221.,https://github.com/alibaba/nacos/blob/2.0.2/sys/src/main/java/com/alibaba/nacos/sys/utils/DiskUtils.java,"public static byte[] readFileBytes(String path, String fileName) {
        File file = openFile(path, fileName);
        return readFileBytes(file);
    }",1
nacos-2.0.2,NULL_DEREFERENCE,config/src/main/java/com/alibaba/nacos/config/server/service/capacity/CapacityService.java,"com.alibaba.nacos.config.server.service.capacity.CapacityService.autoExpansion(java.lang.String,java.lang.String):void",287,object `capacity` last assigned on line 285 could be null and is dereferenced at line 287.,https://github.com/alibaba/nacos/blob/2.0.2/config/src/main/java/com/alibaba/nacos/config/server/service/capacity/CapacityService.java,"private void autoExpansion(String group, String tenant) {
        Capacity capacity = getCapacity(group, tenant);
        int defaultQuota = getDefaultQuota(tenant != null);
        Integer usage = capacity.getUsage();
        if (usage < defaultQuota) {
            return;
        }
        // Initialize the capacity information of the group. If the quota is reached,
        // the capacity will be automatically expanded to reduce the operation and maintenance cost.
        int initialExpansionPercent = PropertyUtil.getInitialExpansionPercent();
        if (initialExpansionPercent > 0) {
            int finalQuota = (int) (usage + defaultQuota * (1.0 * initialExpansionPercent / 100));
            if (tenant != null) {
                tenantCapacityPersistService.updateQuota(tenant, finalQuota);
                LogUtil.DEFAULT_LOG.warn(""[capacityManagement] The usage({}) already reach the upper limit({}) when init the tenant({}), ""
                        + ""automatic upgrade to ({})"", usage, defaultQuota, tenant, finalQuota);
            } else {
                groupCapacityPersistService.updateQuota(group, finalQuota);
                LogUtil.DEFAULT_LOG.warn(""[capacityManagement] The usage({}) already reach the upper limit({}) when init the group({}), ""
                        + ""automatic upgrade to ({})"", usage, defaultQuota, group, finalQuota);
            }
        }
    }",1
nacos-2.0.2,NULL_DEREFERENCE,client/src/main/java/com/alibaba/nacos/client/config/impl/ClientWorker.java,"com.alibaba.nacos.client.config.impl.ClientWorker.checkLocalConfig(java.lang.String,com.alibaba.nacos.client.config.impl.CacheData):void",441,object `content` last assigned on line 440 could be null and is dereferenced by call to `md5Hex(...)` at line 441.,https://github.com/alibaba/nacos/blob/2.0.2/client/src/main/java/com/alibaba/nacos/client/config/impl/ClientWorker.java,"private void checkLocalConfig(String agentName, CacheData cacheData) {
        final String dataId = cacheData.dataId;
        final String group = cacheData.group;
        final String tenant = cacheData.tenant;
        File path = LocalConfigInfoProcessor.getFailoverFile(agentName, dataId, group, tenant);
        
        if (!cacheData.isUseLocalConfigInfo() && path.exists()) {
            String content = LocalConfigInfoProcessor.getFailover(agentName, dataId, group, tenant);
            final String md5 = MD5Utils.md5Hex(content, Constants.ENCODE);
            cacheData.setUseLocalConfigInfo(true);
            cacheData.setLocalConfigInfoVersion(path.lastModified());
            cacheData.setContent(content);
            
            LOGGER.warn(
                    ""[{}] [failover-change] failover file created. dataId={}, group={}, tenant={}, md5={}, content={}"",
                    agentName, dataId, group, tenant, md5, ContentUtils.truncateContent(content));
            return;
        }
        
        // If use local config info, then it doesn't notify business listener and notify after getting from server.
        if (cacheData.isUseLocalConfigInfo() && !path.exists()) {
            cacheData.setUseLocalConfigInfo(false);
            LOGGER.warn(""[{}] [failover-change] failover file deleted. dataId={}, group={}, tenant={}"", agentName,
                    dataId, group, tenant);
            return;
        }
        
        // When it changed.
        if (cacheData.isUseLocalConfigInfo() && path.exists() && cacheData.getLocalConfigInfoVersion() != path
                .lastModified()) {
            String content = LocalConfigInfoProcessor.getFailover(agentName, dataId, group, tenant);
            final String md5 = MD5Utils.md5Hex(content, Constants.ENCODE);
            cacheData.setUseLocalConfigInfo(true);
            cacheData.setLocalConfigInfoVersion(path.lastModified());
            cacheData.setContent(content);
            LOGGER.warn(
                    ""[{}] [failover-change] failover file changed. dataId={}, group={}, tenant={}, md5={}, content={}"",
                    agentName, dataId, group, tenant, md5, ContentUtils.truncateContent(content));
        }
    }",1
nacos-2.0.2,NULL_DEREFERENCE,config/src/main/java/com/alibaba/nacos/config/server/service/dump/DumpService.java,com.alibaba.nacos.config.server.service.dump.DumpService$MergeAllDataWorker.run():void,456,object `aggrContent` last assigned on line 454 could be null and is dereferenced by call to `md5Hex(...)` at line 456.,https://github.com/alibaba/nacos/blob/2.0.2/config/src/main/java/com/alibaba/nacos/config/server/service/dump/DumpService.java,"public void run() {
            if (!canExecute()) {
                return;
            }
            for (ConfigInfoChanged configInfo : configInfoList) {
                String dataId = configInfo.getDataId();
                String group = configInfo.getGroup();
                String tenant = configInfo.getTenant();
                try {
                    List<ConfigInfoAggr> datumList = new ArrayList<ConfigInfoAggr>();
                    int rowCount = persistService.aggrConfigInfoCount(dataId, group, tenant);
                    int pageCount = (int) Math.ceil(rowCount * 1.0 / PAGE_SIZE);
                    for (int pageNo = 1; pageNo <= pageCount; pageNo++) {
                        Page<ConfigInfoAggr> page = persistService
                                .findConfigInfoAggrByPage(dataId, group, tenant, pageNo, PAGE_SIZE);
                        if (page != null) {
                            datumList.addAll(page.getPageItems());
                            LOGGER.info(""[merge-query] {}, {}, size/total={}/{}"", dataId, group, datumList.size(),
                                    rowCount);
                        }
                    }
                    
                    final Timestamp time = TimeUtils.getCurrentTime();
                    // merge
                    if (datumList.size() > 0) {
                        ConfigInfo cf = MergeTaskProcessor.merge(dataId, group, tenant, datumList);
                        String aggrContent = cf.getContent();
                        String localContentMD5 = ConfigCacheService.getContentMd5(GroupKey.getKey(dataId, group));
                        String aggrConetentMD5 = MD5Utils.md5Hex(aggrContent, Constants.ENCODE);
                        
                        if (!StringUtils.equals(localContentMD5, aggrConetentMD5)) {
                            persistService.insertOrUpdate(null, null, cf, time, null, false);
                            LOGGER.info(""[merge-ok] {}, {}, size={}, length={}, md5={}, content={}"", dataId, group,
                                    datumList.size(), cf.getContent().length(), cf.getMd5(),
                                    ContentUtils.truncateContent(cf.getContent()));
                        }
                    } else {
                        // remove config info
                        persistService.removeConfigInfo(dataId, group, tenant, InetUtils.getSelfIP(), null);
                        LOGGER.warn(
                                ""[merge-delete] delete config info because no datum. dataId="" + dataId + "", groupId=""
                                        + group);
                    }
                    
                } catch (Throwable e) {
                    LOGGER.info(""[merge-error] "" + dataId + "", "" + group + "", "" + e.toString(), e);
                }
                FINISHED.incrementAndGet();
                if (FINISHED.get() % 100 == 0) {
                    LOGGER.info(""[all-merge-dump] {} / {}"", FINISHED.get(), total);
                }
            }
            LOGGER.info(""[all-merge-dump] {} / {}"", FINISHED.get(), total);
        }
    }",1
nacos-2.0.2,NULL_DEREFERENCE,naming/src/main/java/com/alibaba/nacos/naming/core/ServiceManager.java,"com.alibaba.nacos.naming.core.ServiceManager.createServiceIfAbsent(java.lang.String,java.lang.String,boolean,com.alibaba.nacos.naming.core.Cluster):void",472,object returned by `getClusterMap(service)` could be null and is dereferenced at line 472.,https://github.com/alibaba/nacos/blob/2.0.2/naming/src/main/java/com/alibaba/nacos/naming/core/ServiceManager.java,"public void createServiceIfAbsent(String namespaceId, String serviceName, boolean local, Cluster cluster)
            throws NacosException {
        Service service = getService(namespaceId, serviceName);
        if (service == null) {
            
            Loggers.SRV_LOG.info(""creating empty service {}:{}"", namespaceId, serviceName);
            service = new Service();
            service.setName(serviceName);
            service.setNamespaceId(namespaceId);
            service.setGroupName(NamingUtils.getGroupName(serviceName));
            // now validate the service. if failed, exception will be thrown
            service.setLastModifiedMillis(System.currentTimeMillis());
            service.recalculateChecksum();
            if (cluster != null) {
                cluster.setService(service);
                service.getClusterMap().put(cluster.getName(), cluster);
            }
            service.validate();
            
            putServiceAndInit(service);
            if (!local) {
                addOrReplaceService(service);
            }
        }
    }",1
nacos-2.0.2,NULL_DEREFERENCE,config/src/main/java/com/alibaba/nacos/config/server/service/repository/extrnal/ExternalStoragePersistServiceImpl.java,com.alibaba.nacos.config.server.service.repository.extrnal.ExternalStoragePersistServiceImpl$2.doInTransaction(org.springframework.transaction.TransactionStatus):java.util.List,505,object `configInfoList` last assigned on line 502 could be null and is dereferenced at line 505.,https://github.com/alibaba/nacos/blob/2.0.2/config/src/main/java/com/alibaba/nacos/config/server/service/repository/extrnal/ExternalStoragePersistServiceImpl.java,"public List<ConfigInfo> removeConfigInfoByIds(final List<Long> ids, final String srcIp, final String srcUser) {
        if (CollectionUtils.isEmpty(ids)) {
            return null;
        }
        ids.removeAll(Collections.singleton(null));
        return tjt.execute(new TransactionCallback<List<ConfigInfo>>() {
            final Timestamp time = new Timestamp(System.currentTimeMillis());
            
            @Override
            public List<ConfigInfo> doInTransaction(TransactionStatus status) {
                try {
                    String idsStr = Joiner.on("","").join(ids);
                    List<ConfigInfo> configInfoList = findConfigInfosByIds(idsStr);
                    if (!CollectionUtils.isEmpty(configInfoList)) {
                        removeConfigInfoByIdsAtomic(idsStr);
                        for (ConfigInfo configInfo : configInfoList) {
                            removeTagByIdAtomic(configInfo.getId());
                            insertConfigHistoryAtomic(configInfo.getId(), configInfo, srcIp, srcUser, time, ""D"");
                        }
                    }
                    return configInfoList;
                } catch (CannotGetJdbcConnectionException e) {
                    LogUtil.FATAL_LOG.error(""[db-error] "" + e.toString(), e);
                    throw e;
                }
            }
        });
    }",0
nacos-2.0.2,NULL_DEREFERENCE,core/src/main/java/com/alibaba/nacos/core/cluster/ServerMemberManager.java,com.alibaba.nacos.core.cluster.ServerMemberManager$MemberInfoReportTask$2.onReceive(com.alibaba.nacos.common.model.RestResult):void,537,object `memberNew` last assigned on line 534 could be null and is dereferenced at line 537.,https://github.com/alibaba/nacos/blob/2.0.2/core/src/main/java/com/alibaba/nacos/core/cluster/ServerMemberManager.java,"protected void executeBody() {
            List<Member> members = ServerMemberManager.this.allMembersWithoutSelf();
            
            if (members.isEmpty()) {
                return;
            }
            
            this.cursor = (this.cursor + 1) % members.size();
            Member target = members.get(cursor);
            
            Loggers.CLUSTER.debug(""report the metadata to the node : {}"", target.getAddress());
            
            final String url = HttpUtils
                    .buildUrl(false, target.getAddress(), EnvUtil.getContextPath(), Commons.NACOS_CORE_CONTEXT,
                            ""/cluster/report"");
            
            try {
                Header header = Header.newInstance().addParam(Constants.NACOS_SERVER_HEADER, VersionUtils.version);
                AuthHeaderUtil.addIdentityToHeader(header);
                asyncRestTemplate
                        .post(url, header,
                                Query.EMPTY, getSelf(), reference.getType(), new Callback<String>() {
                                    @Override
                                    public void onReceive(RestResult<String> result) {
                                        if (result.getCode() == HttpStatus.NOT_IMPLEMENTED.value()
                                                || result.getCode() == HttpStatus.NOT_FOUND.value()) {
                                            Loggers.CLUSTER
                                                    .warn(""{} version is too low, it is recommended to upgrade the version : {}"",
                                                            target, VersionUtils.version);
                                            Member memberNew = null;
                                            if (target.getExtendVal(MemberMetaDataConstants.VERSION) != null) {
                                                memberNew = target.copy();
                                                // Clean up remote version info.
                                                // This value may still stay in extend info when remote server has been downgraded to old version.
                                                memberNew.delExtendVal(MemberMetaDataConstants.VERSION);
                                                memberNew.delExtendVal(MemberMetaDataConstants.READY_TO_UPGRADE);
                                                Loggers.CLUSTER.warn(""{} : Clean up version info,""
                                                        + "" target has been downgrade to old version."", memberNew);
                                            }
                                            if (target.getAbilities() != null
                                                    && target.getAbilities().getRemoteAbility() != null && target
                                                    .getAbilities().getRemoteAbility().isSupportRemoteConnection()) {
                                                if (memberNew == null) {
                                                    memberNew = target.copy();
                                                }
                                                memberNew.getAbilities().getRemoteAbility()
                                                        .setSupportRemoteConnection(false);
                                                Loggers.CLUSTER
                                                        .warn(""{} : Clear support remote connection flag,target may rollback version "",
                                                                memberNew);
                                            }
                                            if (memberNew != null) {
                                                update(memberNew);
                                            }
                                            return;
                                        }
                                        if (result.ok()) {
                                            MemberUtil.onSuccess(ServerMemberManager.this, target);
                                        } else {
                                            Loggers.CLUSTER
                                                    .warn(""failed to report new info to target node : {}, result : {}"",
                                                            target.getAddress(), result);
                                            MemberUtil.onFail(ServerMemberManager.this, target);
                                        }
                                    }
                                    
                                    @Override
                                    public void onError(Throwable throwable) {
                                        Loggers.CLUSTER
                                                .error(""failed to report new info to target node : {}, error : {}"",
                                                        target.getAddress(),
                                                        ExceptionUtil.getAllExceptionMsg(throwable));
                                        MemberUtil.onFail(ServerMemberManager.this, target, throwable);
                                    }
                                    
                                    @Override
                                    public void onCancel() {
                                    
                                    }
                                });
            } catch (Throwable ex) {
                Loggers.CLUSTER.error(""failed to report new info to target node : {}, error : {}"", target.getAddress(),
                        ExceptionUtil.getAllExceptionMsg(ex));
            }
        }",0
nacos-2.0.2,NULL_DEREFERENCE,core/src/main/java/com/alibaba/nacos/core/cluster/ServerMemberManager.java,com.alibaba.nacos.core.cluster.ServerMemberManager$MemberInfoReportTask$2.onReceive(com.alibaba.nacos.common.model.RestResult):void,548,object `memberNew` last assigned on line 546 could be null and is dereferenced at line 548.,https://github.com/alibaba/nacos/blob/2.0.2/core/src/main/java/com/alibaba/nacos/core/cluster/ServerMemberManager.java,"protected void executeBody() {
            List<Member> members = ServerMemberManager.this.allMembersWithoutSelf();
            
            if (members.isEmpty()) {
                return;
            }
            
            this.cursor = (this.cursor + 1) % members.size();
            Member target = members.get(cursor);
            
            Loggers.CLUSTER.debug(""report the metadata to the node : {}"", target.getAddress());
            
            final String url = HttpUtils
                    .buildUrl(false, target.getAddress(), EnvUtil.getContextPath(), Commons.NACOS_CORE_CONTEXT,
                            ""/cluster/report"");
            
            try {
                Header header = Header.newInstance().addParam(Constants.NACOS_SERVER_HEADER, VersionUtils.version);
                AuthHeaderUtil.addIdentityToHeader(header);
                asyncRestTemplate
                        .post(url, header,
                                Query.EMPTY, getSelf(), reference.getType(), new Callback<String>() {
                                    @Override
                                    public void onReceive(RestResult<String> result) {
                                        if (result.getCode() == HttpStatus.NOT_IMPLEMENTED.value()
                                                || result.getCode() == HttpStatus.NOT_FOUND.value()) {
                                            Loggers.CLUSTER
                                                    .warn(""{} version is too low, it is recommended to upgrade the version : {}"",
                                                            target, VersionUtils.version);
                                            Member memberNew = null;
                                            if (target.getExtendVal(MemberMetaDataConstants.VERSION) != null) {
                                                memberNew = target.copy();
                                                // Clean up remote version info.
                                                // This value may still stay in extend info when remote server has been downgraded to old version.
                                                memberNew.delExtendVal(MemberMetaDataConstants.VERSION);
                                                memberNew.delExtendVal(MemberMetaDataConstants.READY_TO_UPGRADE);
                                                Loggers.CLUSTER.warn(""{} : Clean up version info,""
                                                        + "" target has been downgrade to old version."", memberNew);
                                            }
                                            if (target.getAbilities() != null
                                                    && target.getAbilities().getRemoteAbility() != null && target
                                                    .getAbilities().getRemoteAbility().isSupportRemoteConnection()) {
                                                if (memberNew == null) {
                                                    memberNew = target.copy();
                                                }
                                                memberNew.getAbilities().getRemoteAbility()
                                                        .setSupportRemoteConnection(false);
                                                Loggers.CLUSTER
                                                        .warn(""{} : Clear support remote connection flag,target may rollback version "",
                                                                memberNew);
                                            }
                                            if (memberNew != null) {
                                                update(memberNew);
                                            }
                                            return;
                                        }
                                        if (result.ok()) {
                                            MemberUtil.onSuccess(ServerMemberManager.this, target);
                                        } else {
                                            Loggers.CLUSTER
                                                    .warn(""failed to report new info to target node : {}, result : {}"",
                                                            target.getAddress(), result);
                                            MemberUtil.onFail(ServerMemberManager.this, target);
                                        }
                                    }
                                    
                                    @Override
                                    public void onError(Throwable throwable) {
                                        Loggers.CLUSTER
                                                .error(""failed to report new info to target node : {}, error : {}"",
                                                        target.getAddress(),
                                                        ExceptionUtil.getAllExceptionMsg(throwable));
                                        MemberUtil.onFail(ServerMemberManager.this, target, throwable);
                                    }
                                    
                                    @Override
                                    public void onCancel() {
                                    
                                    }
                                });
            } catch (Throwable ex) {
                Loggers.CLUSTER.error(""failed to report new info to target node : {}, error : {}"", target.getAddress(),
                        ExceptionUtil.getAllExceptionMsg(ex));
            }
        }",0
nacos-2.0.2,NULL_DEREFERENCE,config/src/main/java/com/alibaba/nacos/config/server/service/repository/embedded/EmbeddedStoragePersistServiceImpl.java,"com.alibaba.nacos.config.server.service.repository.embedded.EmbeddedStoragePersistServiceImpl.removeConfigInfoByIds(java.util.List,java.lang.String,java.lang.String):java.util.List",594,object `configInfoList` last assigned on line 591 could be null and is dereferenced at line 594.,https://github.com/alibaba/nacos/blob/2.0.2/config/src/main/java/com/alibaba/nacos/config/server/service/repository/embedded/EmbeddedStoragePersistServiceImpl.java,"public List<ConfigInfo> removeConfigInfoByIds(final List<Long> ids, final String srcIp, final String srcUser) {
        if (CollectionUtils.isEmpty(ids)) {
            return null;
        }
        ids.removeAll(Collections.singleton(null));
        final Timestamp time = new Timestamp(System.currentTimeMillis());
        try {
            String idsStr = Joiner.on("","").join(ids);
            List<ConfigInfo> configInfoList = findConfigInfosByIds(idsStr);
            if (CollectionUtils.isNotEmpty(configInfoList)) {
                removeConfigInfoByIdsAtomic(idsStr);
                for (ConfigInfo configInfo : configInfoList) {
                    removeTagByIdAtomic(configInfo.getId());
                    insertConfigHistoryAtomic(configInfo.getId(), configInfo, srcIp, srcUser, time, ""D"");
                }
            }
            
            EmbeddedStorageContextUtils.onBatchDeleteConfigInfo(configInfoList);
            boolean result = databaseOperate.update(EmbeddedStorageContextUtils.getCurrentSqlContext());
            if (!result) {
                throw new NacosConfigException(""Failed to config batch deletion"");
            }
            
            return configInfoList;
        } finally {
            EmbeddedStorageContextUtils.cleanAllContext();
        }
    }",0
nacos-2.0.2,NULL_DEREFERENCE,naming/src/main/java/com/alibaba/nacos/naming/core/ServiceManager.java,"com.alibaba.nacos.naming.core.ServiceManager.addInstance(java.lang.String,java.lang.String,boolean,com.alibaba.nacos.naming.core.Instance[]):void",649,object `service` last assigned on line 647 could be null and is dereferenced at line 649.,https://github.com/alibaba/nacos/blob/2.0.2/naming/src/main/java/com/alibaba/nacos/naming/core/ServiceManager.java,"public void addInstance(String namespaceId, String serviceName, boolean ephemeral, Instance... ips)
            throws NacosException {
        
        String key = KeyBuilder.buildInstanceListKey(namespaceId, serviceName, ephemeral);
        
        Service service = getService(namespaceId, serviceName);
        
        synchronized (service) {
            List<Instance> instanceList = addIpAddresses(service, ephemeral, ips);
            
            Instances instances = new Instances();
            instances.setInstanceList(instanceList);
            
            consistencyService.put(key, instances);
        }
    }",1
nacos-2.0.2,NULL_DEREFERENCE,naming/src/main/java/com/alibaba/nacos/naming/core/ServiceManager.java,"com.alibaba.nacos.naming.core.ServiceManager.removeInstance(java.lang.String,java.lang.String,boolean,com.alibaba.nacos.naming.core.Instance[]):void",672,object `service` last assigned on line 670 could be null and is dereferenced at line 672.,https://github.com/alibaba/nacos/blob/2.0.2/naming/src/main/java/com/alibaba/nacos/naming/core/ServiceManager.java,"public void removeInstance(String namespaceId, String serviceName, boolean ephemeral, Instance... ips)
            throws NacosException {
        Service service = getService(namespaceId, serviceName);
        
        synchronized (service) {
            removeInstance(namespaceId, serviceName, ephemeral, service, ips);
        }
    }",1
nacos-2.0.2,NULL_DEREFERENCE,config/src/main/java/com/alibaba/nacos/config/server/service/repository/extrnal/ExternalStoragePersistServiceImpl.java,"com.alibaba.nacos.config.server.service.repository.extrnal.ExternalStoragePersistServiceImpl.findConfigInfoAdvanceInfo(java.lang.String,java.lang.String,java.lang.String,java.util.Map):com.alibaba.nacos.config.server.model.ConfigInfo",811,object `configTags` last assigned on line 798 could be null and is dereferenced at line 811.,https://github.com/alibaba/nacos/blob/2.0.2/config/src/main/java/com/alibaba/nacos/config/server/service/repository/extrnal/ExternalStoragePersistServiceImpl.java,"public ConfigInfo findConfigInfoAdvanceInfo(final String dataId, final String group, final String tenant,
            final Map<String, Object> configAdvanceInfo) {
        String tenantTmp = StringUtils.isBlank(tenant) ? StringUtils.EMPTY : tenant;
        final String appName = configAdvanceInfo == null ? null : (String) configAdvanceInfo.get(""appName"");
        final String configTags = configAdvanceInfo == null ? null : (String) configAdvanceInfo.get(""config_tags"");
        List<String> paramList = new ArrayList<String>();
        paramList.add(dataId);
        paramList.add(group);
        paramList.add(tenantTmp);
        
        StringBuilder sql = new StringBuilder(
                ""select ID,data_id,group_id,tenant_id,app_name,content from config_info where data_id=? and group_id=? and tenant_id=? "");
        if (StringUtils.isNotBlank(configTags)) {
            sql = new StringBuilder(
                    ""select a.ID,a.data_id,a.group_id,a.tenant_id,a.app_name,a.content from config_info  a left join ""
                            + ""config_tags_relation b on a.id=b.id where a.data_id=? and a.group_id=? and a.tenant_id=? "");
            sql.append("" and b.tag_name in ("");
            String[] tagArr = configTags.split("","");
            for (int i = 0; i < tagArr.length; i++) {
                if (i != 0) {
                    sql.append("", "");
                }
                sql.append(""?"");
                paramList.add(tagArr[i]);
            }
            sql.append("") "");
            
            if (StringUtils.isNotBlank(appName)) {
                sql.append("" and a.app_name=? "");
                paramList.add(appName);
            }
        } else {
            if (StringUtils.isNotBlank(appName)) {
                sql.append("" and app_name=? "");
                paramList.add(appName);
            }
        }
        
        try {
            return this.jt.queryForObject(sql.toString(), paramList.toArray(), CONFIG_INFO_ROW_MAPPER);
        } catch (EmptyResultDataAccessException e) { // Indicates that the data does not exist, returns null.
            return null;
        } catch (CannotGetJdbcConnectionException e) {
            LogUtil.FATAL_LOG.error(""[db-error] "" + e.toString(), e);
            throw e;
        }
        
    }",0
nacos-2.0.2,NULL_DEREFERENCE,config/src/main/java/com/alibaba/nacos/config/server/service/repository/embedded/EmbeddedStoragePersistServiceImpl.java,"com.alibaba.nacos.config.server.service.repository.embedded.EmbeddedStoragePersistServiceImpl.findConfigInfoAdvanceInfo(java.lang.String,java.lang.String,java.lang.String,java.util.Map):com.alibaba.nacos.config.server.model.ConfigInfo",860,object `configTags` last assigned on line 847 could be null and is dereferenced at line 860.,https://github.com/alibaba/nacos/blob/2.0.2/config/src/main/java/com/alibaba/nacos/config/server/service/repository/embedded/EmbeddedStoragePersistServiceImpl.java,"public ConfigInfo findConfigInfoAdvanceInfo(final String dataId, final String group, final String tenant,
            final Map<String, Object> configAdvanceInfo) {
        String tenantTmp = StringUtils.isBlank(tenant) ? StringUtils.EMPTY : tenant;
        final String appName = configAdvanceInfo == null ? null : (String) configAdvanceInfo.get(""appName"");
        final String configTags = configAdvanceInfo == null ? null : (String) configAdvanceInfo.get(""config_tags"");
        List<String> paramList = new ArrayList<String>();
        paramList.add(dataId);
        paramList.add(group);
        paramList.add(tenantTmp);
        
        StringBuilder sql = new StringBuilder(
                ""select ID,data_id,group_id,tenant_id,app_name,content from config_info where data_id=? and group_id=? and tenant_id=? "");
        if (StringUtils.isNotBlank(configTags)) {
            sql = new StringBuilder(
                    ""select a.ID,a.data_id,a.group_id,a.tenant_id,a.app_name,a.content from config_info  a left join ""
                            + ""config_tags_relation b on a.id=b.id where a.data_id=? and a.group_id=? and a.tenant_id=? "");
            sql.append("" and b.tag_name in ("");
            String[] tagArr = configTags.split("","");
            for (int i = 0; i < tagArr.length; i++) {
                if (i != 0) {
                    sql.append("", "");
                }
                sql.append(""?"");
                paramList.add(tagArr[i]);
            }
            sql.append("") "");
            
            if (StringUtils.isNotBlank(appName)) {
                sql.append("" and a.app_name=? "");
                paramList.add(appName);
            }
        } else {
            if (StringUtils.isNotBlank(appName)) {
                sql.append("" and app_name=? "");
                paramList.add(appName);
            }
        }
        
        return databaseOperate.queryOne(sql.toString(), paramList.toArray(), CONFIG_INFO_ROW_MAPPER);
    }",0
nacos-2.0.2,NULL_DEREFERENCE,naming/src/main/java/com/alibaba/nacos/naming/core/ServiceManager.java,com.alibaba.nacos.naming.core.ServiceManager.putServiceAndInit(com.alibaba.nacos.naming.core.Service):void,884,object `service` last assigned on line 883 could be null and is dereferenced at line 884.,https://github.com/alibaba/nacos/blob/2.0.2/naming/src/main/java/com/alibaba/nacos/naming/core/ServiceManager.java,"private void putServiceAndInit(Service service) throws NacosException {
        putService(service);
        service = getService(service.getNamespaceId(), service.getName());
        service.init();
        consistencyService
                .listen(KeyBuilder.buildInstanceListKey(service.getNamespaceId(), service.getName(), true), service);
        consistencyService
                .listen(KeyBuilder.buildInstanceListKey(service.getNamespaceId(), service.getName(), false), service);
        Loggers.SRV_LOG.info(""[NEW-SERVICE] {}"", service.toJson());
    }",1
nacos-2.0.2,NULL_DEREFERENCE,config/src/main/java/com/alibaba/nacos/config/server/service/repository/embedded/EmbeddedStoragePersistServiceImpl.java,"com.alibaba.nacos.config.server.service.repository.embedded.EmbeddedStoragePersistServiceImpl.getTenantIdList(int,int):java.util.List",1251,object returned by `pageList.getPageItems()` could be null and is dereferenced at line 1251.,https://github.com/alibaba/nacos/blob/2.0.2/config/src/main/java/com/alibaba/nacos/config/server/service/repository/embedded/EmbeddedStoragePersistServiceImpl.java,"public List<String> getTenantIdList(int page, int pageSize) {
        PaginationHelper<Map<String, Object>> helper = createPaginationHelper();
        
        String sql = ""SELECT tenant_id FROM config_info WHERE tenant_id != '' GROUP BY tenant_id LIMIT ?,?"";
        int from = (page - 1) * pageSize;
        
        Page<Map<String, Object>> pageList = helper
                .fetchPageLimit(sql, new Object[] {from, pageSize}, page, pageSize, MAP_ROW_MAPPER);
        return pageList.getPageItems().stream().map(map -> String.valueOf(map.get(""TENANT_ID"")))
                .collect(Collectors.toList());
    }",1
nacos-2.0.2,NULL_DEREFERENCE,config/src/main/java/com/alibaba/nacos/config/server/service/repository/embedded/EmbeddedStoragePersistServiceImpl.java,"com.alibaba.nacos.config.server.service.repository.embedded.EmbeddedStoragePersistServiceImpl.getGroupIdList(int,int):java.util.List",1264,object returned by `pageList.getPageItems()` could be null and is dereferenced at line 1264.,https://github.com/alibaba/nacos/blob/2.0.2/config/src/main/java/com/alibaba/nacos/config/server/service/repository/embedded/EmbeddedStoragePersistServiceImpl.java,"public List<String> getGroupIdList(int page, int pageSize) {
        PaginationHelper<Map<String, Object>> helper = createPaginationHelper();
        
        String sql = ""SELECT group_id FROM config_info WHERE tenant_id ='' GROUP BY group_id LIMIT ?,?"";
        int from = (page - 1) * pageSize;
        
        Page<Map<String, Object>> pageList = helper
                .fetchPageLimit(sql, new Object[] {from, pageSize}, page, pageSize, MAP_ROW_MAPPER);
        return pageList.getPageItems().stream().map(map -> String.valueOf(map.get(""GROUP_ID"")))
                .collect(Collectors.toList());
    }",1
nacos-2.0.2,NULL_DEREFERENCE,config/src/main/java/com/alibaba/nacos/config/server/service/repository/embedded/EmbeddedStoragePersistServiceImpl.java,"com.alibaba.nacos.config.server.service.repository.embedded.EmbeddedStoragePersistServiceImpl.findAllConfigKey(int,int,java.lang.String):com.alibaba.nacos.config.server.model.Page",1363,object returned by `getPageItems(page)` could be null and is dereferenced at line 1363.,https://github.com/alibaba/nacos/blob/2.0.2/config/src/main/java/com/alibaba/nacos/config/server/service/repository/embedded/EmbeddedStoragePersistServiceImpl.java,"public Page<ConfigKey> findAllConfigKey(final int pageNo, final int pageSize, final String tenant) {
        final String tenantTmp = StringUtils.isBlank(tenant) ? StringUtils.EMPTY : tenant;
        final String select = "" SELECT data_id,group_id,app_name FROM ""
                + "" ( SELECT id FROM config_info WHERE tenant_id LIKE ? ORDER BY id LIMIT ?, ? ) ""
                + ""g, config_info t  WHERE g.id = t.id "";
        
        final int totalCount = configInfoCount(tenant);
        int pageCount = totalCount / pageSize;
        if (totalCount > pageSize * pageCount) {
            pageCount++;
        }
        
        if (pageNo > pageCount) {
            return null;
        }
        
        final Page<ConfigKey> page = new Page<ConfigKey>();
        page.setPageNumber(pageNo);
        page.setPagesAvailable(pageCount);
        page.setTotalCount(totalCount);
        
        List<ConfigKey> result = databaseOperate
                .queryMany(select, new Object[] {generateLikeArgument(tenantTmp), (pageNo - 1) * pageSize, pageSize},
                        // new Object[0],
                        CONFIG_KEY_ROW_MAPPER);
        
        for (ConfigKey item : result) {
            page.getPageItems().add(item);
        }
        return page;
    }",1
nacos-2.0.2,NULL_DEREFERENCE,config/src/main/java/com/alibaba/nacos/config/server/service/repository/extrnal/ExternalStoragePersistServiceImpl.java,"com.alibaba.nacos.config.server.service.repository.extrnal.ExternalStoragePersistServiceImpl.findAllConfigKey(int,int,java.lang.String):com.alibaba.nacos.config.server.model.Page",1380,object returned by `getPageItems(page)` could be null and is dereferenced at line 1380.,https://github.com/alibaba/nacos/blob/2.0.2/config/src/main/java/com/alibaba/nacos/config/server/service/repository/extrnal/ExternalStoragePersistServiceImpl.java,"public Page<ConfigKey> findAllConfigKey(final int pageNo, final int pageSize, final String tenant) {
        String tenantTmp = StringUtils.isBlank(tenant) ? StringUtils.EMPTY : tenant;
        String select = "" SELECT data_id,group_id,app_name  FROM ( ""
                + "" SELECT id FROM config_info WHERE tenant_id LIKE ? ORDER BY id LIMIT ?, ?  )""
                + "" g, config_info t WHERE g.id = t.id  "";
        
        final int totalCount = configInfoCount(tenant);
        int pageCount = totalCount / pageSize;
        if (totalCount > pageSize * pageCount) {
            pageCount++;
        }
        
        if (pageNo > pageCount) {
            return null;
        }
        
        final Page<ConfigKey> page = new Page<ConfigKey>();
        page.setPageNumber(pageNo);
        page.setPagesAvailable(pageCount);
        page.setTotalCount(totalCount);
        
        try {
            List<ConfigKey> result = jt
                    .query(select, new Object[] {generateLikeArgument(tenantTmp), (pageNo - 1) * pageSize, pageSize},
                            // new Object[0],
                            CONFIG_KEY_ROW_MAPPER);
            
            for (ConfigKey item : result) {
                page.getPageItems().add(item);
            }
            return page;
        } catch (EmptyResultDataAccessException e) {
            return page;
        } catch (CannotGetJdbcConnectionException e) {
            LogUtil.FATAL_LOG.error(""[db-error] "" + e.toString(), e);
            throw e;
        }
    }",1
nacos-2.0.2,NULL_DEREFERENCE,config/src/main/java/com/alibaba/nacos/config/server/service/repository/embedded/EmbeddedStoragePersistServiceImpl.java,com.alibaba.nacos.config.server.service.repository.embedded.EmbeddedStoragePersistServiceImpl.completeMd5():java.lang.Boolean,2390,object returned by `page.getPageItems()` could be null and is dereferenced at line 2390.,https://github.com/alibaba/nacos/blob/2.0.2/config/src/main/java/com/alibaba/nacos/config/server/service/repository/embedded/EmbeddedStoragePersistServiceImpl.java,"public Boolean completeMd5() {
        DEFAULT_LOG.info(""[start completeMd5]"");
        int perPageSize = 1000;
        int rowCount = configInfoCount();
        int pageCount = (int) Math.ceil(rowCount * 1.0 / perPageSize);
        int actualRowCount = 0;
        for (int pageNo = 1; pageNo <= pageCount; pageNo++) {
            Page<ConfigInfoWrapper> page = findAllConfigInfoForDumpAll(pageNo, perPageSize);
            if (page != null) {
                for (ConfigInfoWrapper cf : page.getPageItems()) {
                    String md5InDb = cf.getMd5();
                    final String content = cf.getContent();
                    final String tenant = cf.getTenant();
                    final String md5 = MD5Utils.md5Hex(content, Constants.ENCODE);
                    if (StringUtils.isBlank(md5InDb)) {
                        try {
                            updateMd5(cf.getDataId(), cf.getGroup(), tenant, md5, new Timestamp(cf.getLastModified()));
                        } catch (Throwable e) {
                            LogUtil.DEFAULT_LOG
                                    .error(""[completeMd5-error] datId:{} group:{} lastModified:{}"", cf.getDataId(),
                                            cf.getGroup(), new Timestamp(cf.getLastModified()));
                        }
                    } else {
                        if (!md5InDb.equals(md5)) {
                            try {
                                updateMd5(cf.getDataId(), cf.getGroup(), tenant, md5,
                                        new Timestamp(cf.getLastModified()));
                            } catch (Throwable e) {
                                LogUtil.DEFAULT_LOG
                                        .error(""[completeMd5-error] datId:{} group:{} lastModified:{}"", cf.getDataId(),
                                                cf.getGroup(), new Timestamp(cf.getLastModified()));
                            }
                        }
                    }
                }
                
                actualRowCount += page.getPageItems().size();
                DEFAULT_LOG.info(""[completeMd5] {} / {}"", actualRowCount, rowCount);
            }
        }
        return true;
    }",0
nacos-2.0.2,RESOURCE_LEAK,naming/src/main/java/com/alibaba/nacos/naming/consistency/persistent/raft/RaftStore.java,com.alibaba.nacos.naming.consistency.persistent.raft.RaftStore.loadMeta():java.util.Properties,116,"resource of type `java.io.FileInputStream` acquired to `inStream` by call to `FileInputStream(...)` at line 116 is not released after line 116.
**Note**: potential exception at line 117",https://github.com/alibaba/nacos/blob/2.0.2/naming/src/main/java/com/alibaba/nacos/naming/consistency/persistent/raft/RaftStore.java,"public synchronized Properties loadMeta() throws Exception {
        File metaFile = new File(META_FILE_NAME);
        if (!metaFile.exists() && !metaFile.getParentFile().mkdirs() && !metaFile.createNewFile()) {
            throw new IllegalStateException(""failed to create meta file: "" + metaFile.getAbsolutePath());
        }
        
        try (FileInputStream inStream = new FileInputStream(metaFile)) {
            meta.load(inStream);
        }
        return meta;
    }",0
nacos-2.0.2,RESOURCE_LEAK,sys/src/main/java/com/alibaba/nacos/sys/utils/DiskUtils.java,com.alibaba.nacos.sys.utils.DiskUtils.readFile(java.io.File):java.lang.String,198,resource of type `java.io.FileInputStream` acquired by call to `FileInputStream(...)` at line 183 is not released after line 198.,https://github.com/alibaba/nacos/blob/2.0.2/sys/src/main/java/com/alibaba/nacos/sys/utils/DiskUtils.java,"public static String readFile(File file) {
        try (FileChannel fileChannel = new FileInputStream(file).getChannel()) {
            StringBuilder text = new StringBuilder();
            ByteBuffer buffer = ByteBuffer.allocate(4096);
            CharBuffer charBuffer = CharBuffer.allocate(4096);
            while (fileChannel.read(buffer) != -1) {
                buffer.flip();
                DECODER.decode(buffer, charBuffer, false);
                charBuffer.flip();
                while (charBuffer.hasRemaining()) {
                    text.append(charBuffer.get());
                }
                buffer.clear();
                charBuffer.clear();
            }
            return text.toString();
        } catch (IOException e) {
            return null;
        }
    }",0
nacos-2.0.2,RESOURCE_LEAK,sys/src/main/java/com/alibaba/nacos/sys/utils/DiskUtils.java,"com.alibaba.nacos.sys.utils.DiskUtils.writeFile(java.io.File,byte[],boolean):boolean",237,resource of type `java.io.FileOutputStream` acquired by call to `FileOutputStream(...)` at line 233 is not released after line 237.,https://github.com/alibaba/nacos/blob/2.0.2/sys/src/main/java/com/alibaba/nacos/sys/utils/DiskUtils.java,"public static boolean writeFile(File file, byte[] content, boolean append) {
        try (FileChannel fileChannel = new FileOutputStream(file, append).getChannel()) {
            ByteBuffer buffer = ByteBuffer.wrap(content);
            fileChannel.write(buffer);
            return true;
        } catch (IOException ioe) {
            if (ioe.getMessage() != null) {
                String errMsg = ioe.getMessage();
                if (NO_SPACE_CN.equals(errMsg) || NO_SPACE_EN.equals(errMsg) || errMsg.contains(DISK_QUATA_CN) || errMsg
                        .contains(DISK_QUATA_EN)) {
                    LOGGER.warn(""磁盘满，自杀退出"");
                    System.exit(0);
                }
            }
        }
        return false;
    }",0
nacos-2.0.2,RESOURCE_LEAK,common/src/main/java/com/alibaba/nacos/common/utils/IoUtils.java,"com.alibaba.nacos.common.utils.IoUtils.copyFile(java.lang.String,java.lang.String):void",328,resource of type `java.io.FileInputStream` acquired by call to `FileInputStream(...)` at line 325 is not released after line 328.,https://github.com/alibaba/nacos/blob/2.0.2/common/src/main/java/com/alibaba/nacos/common/utils/IoUtils.java,"public static void copyFile(String source, String target) throws IOException {
        File sf = new File(source);
        if (!sf.exists()) {
            throw new IllegalArgumentException(""source file does not exist."");
        }
        File tf = new File(target);
        if (!tf.getParentFile().mkdirs()) {
            throw new RuntimeException(""failed to create parent directory."");
        }
        if (!tf.exists() && !tf.createNewFile()) {
            throw new RuntimeException(""failed to create target file."");
        }
        
        FileChannel sc = null;
        FileChannel tc = null;
        try {
            tc = new FileOutputStream(tf).getChannel();
            sc = new FileInputStream(sf).getChannel();
            sc.transferTo(0, sc.size(), tc);
        } finally {
            closeQuietly(sc);
            closeQuietly(tc);
        }
    }",0
nacos-2.0.2,RESOURCE_LEAK,common/src/main/java/com/alibaba/nacos/common/utils/IoUtils.java,"com.alibaba.nacos.common.utils.IoUtils.copyFile(java.lang.String,java.lang.String):void",329,"resource of type `java.io.FileOutputStream` acquired by call to `FileOutputStream(...)` at line 324 is not released after line 329.
**Note**: potential exception at line 325",https://github.com/alibaba/nacos/blob/2.0.2/common/src/main/java/com/alibaba/nacos/common/utils/IoUtils.java,"public static void copyFile(String source, String target) throws IOException {
        File sf = new File(source);
        if (!sf.exists()) {
            throw new IllegalArgumentException(""source file does not exist."");
        }
        File tf = new File(target);
        if (!tf.getParentFile().mkdirs()) {
            throw new RuntimeException(""failed to create parent directory."");
        }
        if (!tf.exists() && !tf.createNewFile()) {
            throw new RuntimeException(""failed to create target file."");
        }
        
        FileChannel sc = null;
        FileChannel tc = null;
        try {
            tc = new FileOutputStream(tf).getChannel();
            sc = new FileInputStream(sf).getChannel();
            sc.transferTo(0, sc.size(), tc);
        } finally {
            closeQuietly(sc);
            closeQuietly(tc);
        }
    }",0
nacos-2.0.2,RESOURCE_LEAK,naming/src/main/java/com/alibaba/nacos/naming/consistency/persistent/raft/RaftStore.java,com.alibaba.nacos.naming.consistency.persistent.raft.RaftStore.updateTerm(long):void,333,"resource of type `java.io.FileOutputStream` acquired to `outStream` by call to `FileOutputStream(...)` at line 333 is not released after line 333.
**Note**: potential exception at line 336",https://github.com/alibaba/nacos/blob/2.0.2/naming/src/main/java/com/alibaba/nacos/naming/consistency/persistent/raft/RaftStore.java,"public void updateTerm(long term) throws Exception {
        File file = new File(META_FILE_NAME);
        if (!file.exists() && !file.getParentFile().mkdirs() && !file.createNewFile()) {
            throw new IllegalStateException(""failed to create meta file"");
        }
        
        try (FileOutputStream outStream = new FileOutputStream(file)) {
            // write meta
            meta.setProperty(""term"", String.valueOf(term));
            meta.store(outStream, null);
        }
    }",0
nacos-2.0.2,RESOURCE_LEAK,config/src/main/java/com/alibaba/nacos/config/server/service/repository/embedded/DistributedDatabaseOperateImpl.java,com.alibaba.nacos.config.server.service.repository.embedded.DistributedDatabaseOperateImpl.lambda$dataImport$0(java.io.File):com.alibaba.nacos.common.model.RestResult,408,"resource of type `com.alibaba.nacos.sys.utils.DiskUtils$LineIterator` acquired by call to `lineIterator(...)` at line 380 is not released after line 408.
**Note**: potential exception at line 394",https://github.com/alibaba/nacos/blob/2.0.2/config/src/main/java/com/alibaba/nacos/config/server/service/repository/embedded/DistributedDatabaseOperateImpl.java,"public CompletableFuture<RestResult<String>> dataImport(File file) {
        return CompletableFuture.supplyAsync(() -> {
            try (DiskUtils.LineIterator iterator = DiskUtils.lineIterator(file)) {
                int batchSize = 1000;
                List<String> batchUpdate = new ArrayList<>(batchSize);
                List<CompletableFuture<Response>> futures = new ArrayList<>();
                while (iterator.hasNext()) {
                    String sql = iterator.next();
                    if (StringUtils.isNotBlank(sql)) {
                        batchUpdate.add(sql);
                    }
                    boolean submit = batchUpdate.size() == batchSize || !iterator.hasNext();
                    if (submit) {
                        List<ModifyRequest> requests = batchUpdate.stream().map(ModifyRequest::new)
                                .collect(Collectors.toList());
                        CompletableFuture<Response> future = protocol.writeAsync(WriteRequest.newBuilder().setGroup(group())
                                .setData(ByteString.copyFrom(serializer.serialize(requests)))
                                .putExtendInfo(DATA_IMPORT_KEY, Boolean.TRUE.toString()).build());
                        futures.add(future);
                        batchUpdate.clear();
                    }
                }
                CompletableFuture.allOf(futures.toArray(new CompletableFuture[0])).join();
                for (CompletableFuture<Response> future : futures) {
                    Response response = future.get();
                    if (!response.getSuccess()) {
                        return RestResultUtils.failed(response.getErrMsg());
                    }
                }
                return RestResultUtils.success();
            } catch (Throwable ex) {
                LogUtil.DEFAULT_LOG.error(""data import has error :"", ex);
                return RestResultUtils.failed(ex.getMessage());
            }
        });
    }",1